"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/specifications/specs/sysext/",title:"Sysext",section:"Specs",content:`This content has moved to Extension Images
`}),e.add({id:1,href:"/specifications/specs/boot_loader_specification/",title:"Boot Loader Specification",section:"Specs",content:` The Boot Loader Specification # Version Changes 1.0 Initial Release This document defines a set of file formats and naming conventions that allow the boot loader menu entries to be shared between multiple operating systems and boot loaders installed on one device.
Operating systems cooperatively manage boot loader menu entry directories that contain drop-in files, making multi-boot scenarios easy to support. Boot menu entries are defined via two simple formats that can be understood by different boot loader implementations, operating systems, and userspace programs. The same scheme can be used to prepare OS media for cases where the firmware includes a boot loader.
Target Audience # The target audience for this specification is:
Boot loader developers, to write a boot loader that directly reads its menu entries from these files Firmware developers, to add generic boot loading support directly to the firmware itself OS installer developers, to create appropriate partitions and set up the initial boot loader menu entries Distribution developers, to create appropriate menu entry snippets when installing or updating kernel packages UI developers, to implement user interfaces that list and select among the available boot options The Partitions # Everything described below is located on one or two partitions. The boot loader or user-space programs reading the boot loader menu entries should locate them in the following manner:
On disks with an MBR partition table:
The boot partition — a partition with the type ID of 0xEA — shall be used as the single location for boot loader menu entries. On disks with GPT (GUID Partition Table)
The EFI System Partition (ESP for short) — a partition with a GPT type GUID of c12a7328-f81f-11d2-ba4b-00a0c93ec93b — may be used as one of two locations for boot loader menu entries.
Optionally, an Extended Boot Loader Partition (XBOOTLDR partition for short) — a partition with GPT type GUID of bc13c2ff-59e6-4262-a352-b275fd6f7172 — may be used as the second of two locations for boot loader menu entries. This partition must be located on the same disk as the ESP.
Each partition type mentioned above can be present only once on the same disk.
Note: These partitions are shared among all OS installations on the same disk. Instead of maintaining one boot partition per installed OS (as /boot/ was traditionally handled), all installed OSes use the same place for boot loader menu entries.
For systems where the firmware is able to read file systems directly, the ESP and XBOOTLDR must use a file system readable by the firmware. For most systems this means VFAT (16 or 32 bit). The same file system type must be used for both partitions.
Inode types other than directories and regular files are not allowed as any part of the paths defined by this specification. If for some reason a file system type allowing those is used, those must not be created by any tools supporting this specification, and such paths must be ignored by tools supporting this specification.
Applications should not expect case sensitivity, and need to be able to deal with case insensitive behaviour of the file system.
Note that the partitions described here are not the exclusive territory of this specification. This specification only defines semantics of the /loader/entries/ directory (along with the companion file /loader/entries.srel) and the /EFI/Linux/ directory inside the file system, but it doesn\u0026rsquo;t define other contents of the file system. Boot loaders, firmware, and other software implementing this specification may choose to place other files and directories in the same file system. For example, boot loaders might install their own boot code on the same partition; this is particularly common in the case of the ESP. Implementations of this specification must be able to operate correctly if files or directories other than /loader/entries/ and /EFI/Linux/ are found in the top level directory. Implementations that add their own files or directories to the file systems should use well-named directories, to make name collisions between multiple users of the file system unlikely.
The \$BOOT Partition Placeholder # In the text below, the placeholder \$BOOT will be used to refer to the partition determined as follows:
On disks with an MBR partition table: → the boot partition, as described above
On disks with a GPT partition table: → the XBOOTLDR partition if it exists
Otherwise, on disks with a GPT partition table: → the ESP
\$BOOT is the primary place to put boot menu entry resources into, but typically not the only one. Most importantly, boot loaders should also pick up menu entries from the ESP, even if XBOOTLDR exists (for details see below).
Creating These Partitions # An installer for an operating system should use this logic when selecting or creating partitions:
If a boot partition (in case of MBR) or an XBOOTLDR partition (in case of GPT) already exists it should be used as \$BOOT and used as primary location to place boot loader menu resources in.
Otherwise, if on GPT and an ESP is found and it is large enough (let\u0026rsquo;s say at least 1G) it should be used as \$BOOT and used as primary location to place boot loader menu resources in.
Otherwise, if on GPT and neither XBOOTLDR nor ESP exist, an ESP should be created of the appropriate size and be used as \$BOOT, and used as primary location to place boot loader menu resources in.
Otherwise, a boot partition (in case of MBR) or XBOOTLDR partition (in case of GPT) should be created of an appropriate size, and be used as \$BOOT, and used as primary location to place boot loader menu resources in.
These partitions shall be determined during installation time, and /etc/fstab entries may be created.
Mount Points # It is recommended to mount \$BOOT (either XBOOTLDR or the ESP) to /boot/. If both XBOOTLDR and the ESP are present, the ESP should be mounted to /efi/.
Effectively, this means that /boot/ is the location where new boot entries shall be written to. For the boot loader itself, the situation is more complicated, because its files may be located under /boot/ or /efi/, depending on whether XBOOTLDR exists.
(Mounting the ESP to /boot/efi/, as was traditionally done, is not recommended. Such a nested setup complicates an implementation via direct autofs mounts — as implemented by systemd for example —, as establishing the inner autofs will trigger the outer one. Mounting the two partitions via autofs is recommended because the simple VFAT file system has weak data integrity properties and should remain unmounted whenever possible.)
From Linux, the file systems must be mounted with MS_NOEXEC, MS_NODEV, MS_NOSUID, MS_NOSYMFOLLOW.
Boot Loader Entries # This specification defines two types of boot loader entries. The first type is text based, very simple, and suitable for a variety of firmware, architecture and image types (\u0026ldquo;Type #1\u0026rdquo;). The second type is specific to EFI, but allows single-file images that combine the kernel binary with the configuration, initrd, and other components of the boot loader entry. This is also useful because the file can be cryptographically signed for the purposes of SecureBoot (\u0026ldquo;Type #2\u0026rdquo;, Unified Kernel Images).
Not all boot loader entries will apply to all systems. For example, Type #1 entries that use the efi key and all Type #2 entries only apply to EFI systems. Entries using the architecture key might specify an architecture that doesn\u0026rsquo;t match the local one. Boot loaders should ignore all entries that don\u0026rsquo;t match the local platform and what the boot loader can support, and hide them from the user. Only entries matching the feature set of boot loader and system shall be considered and displayed. This allows image builders to put together images that transparently support multiple different architectures.
Type #1 Boot Loader Specification Entries # /loader/entries/ in \$BOOT is the primary directory containing Type #1 drop-in snippets defining boot entries, one .conf file for each boot menu item. Each OS may provide one or more such entries.
If the ESP is separate from \$BOOT it may also contain a /loader/entries/ directory, where the boot loader should look for boot entry snippets, as an additional source. The boot loader should enumerate both directories and present a merged list to the user. Note that this is done for compatibility only: while boot loaders should look in both places, OSes should only add their files to \$BOOT.
Note: In all cases the /loader/entries/ directory should be located directly in the root of the ESP or XBOOTLDR filesystem. Specifically, the /loader/entries/ directory should not be located under the /EFI/ subdirectory on the ESP.
The file name of the boot entry snippets is used for identification of the boot item but shall never be presented to the user in the UI. The file name may be chosen freely but should be unique enough to avoid clashes between OS installations. More specifically, it is suggested to include the entry-token (see kernel-install) or machine ID (see /etc/machine-id), and the kernel version (as returned by uname -r, including the OS identifier), so that the whole filename is \$BOOT/loader/entries/\u0026lt;entry-token-or-machine-id\u0026gt;-\u0026lt;version\u0026gt;.conf.
Example: \$BOOT/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf.
In order to maximize compatibility with file system implementations and restricted boot loader environments, and to minimize conflicting character use with other programs, file names shall be chosen from a restricted character set: ASCII upper and lower case characters, digits, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;_\u0026rdquo; and \u0026ldquo;.\u0026rdquo;. Also, the file names should have a length of at least one and at most 255 characters (including the file name suffix).
These boot loader menu snippets shall be UNIX-style text files (i.e. lines separated by a single newline character), in the UTF-8 encoding. The boot loader menu snippets are loosely inspired by Grub1\u0026rsquo;s configuration syntax. Lines beginning with \u0026ldquo;#\u0026rdquo; are used for comments and shall be ignored. The first word of a line is used as key and is separated by one or more spaces from the value. The rest of the line contains the value, a literal string.
Type #1 Boot Loader Entry Keys # The following keys are recognized:
title is a human-readable title for this menu item to be displayed in the boot menu. It is a good idea to initialize this from the PRETTY_NAME= of os-release. This name should be descriptive and does not have to be unique. If a boot loader discovers two entries with the same title it should show more than just the raw title in the UI, for example by appending the version field. This field is optional.
Example: title Fedora 18 (Spherical Cow)
version is a human-readable version for this menu item. This is usually the kernel version and is intended for use by OSes to install multiple kernel versions with the same title field. This field is used for sorting entries, so that the boot loader can order entries by age or select the newest one automatically. This field is optional.
See Sorting below.
Example: version 3.7.2-201.fc18.x86_64
machine-id is the machine ID of the OS. This can be used by boot loaders and applications to filter out boot entries, for example to show only a single newest kernel per OS, to group items by OS, or to filter out the currently booted OS when showing only other installed operating systems. This ID shall be formatted as 32 lower case hexadecimal characters (i.e. without any UUID formatting). This key is optional.
Example: machine-id 4098b3f648d74c13b1f04ccfba7798e8
sort-key is a short string used for sorting entries on display. This should typically be initialized from the IMAGE_ID= or ID= fields of os-release, possibly with an additional suffix. This field is optional.
Example: sort-key fedora
linux specifies the Linux kernel image to execute. The value is a path relative to the root of the file system containing the boot entry snippet itself.
It is recommended that every distribution creates a subdirectory specific to the entry-token or machine-id, and underneath that, subdirectories specific to the kernel version, and places places the kernel and initrd images there (see below).
Example: linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux
initrd specifies the initrd to use when executing the kernel (cpio image). The value is a path relative to the root of the file system containing the boot entry snippet itself. This key may appear more than once, in which case all specified images are used, in the order they are listed.
Example:
initrd /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd initrd /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/modules efi refers to an arbitrary EFI program. If this key is set, and the system is not an EFI system, this entry should be hidden.
uki is a combination of the linux key, the efi key and Type #2 semantics: if this key is used the specified path shall refer to a unified kernel image (UKI). This informs the boot loader to use UKI semantics (as exposed by Type #2) even though it is referenced via a Type #1 entry. This is useful to parameterize the UKI differently, to place it in a directory other than /EFI/Linux, or to share a single UKI image among multiple menu entries.
If this key is set, and the system is not an EFI system, this entry should be hidden.
Example: uki /fooos/bar.efi
uki-url is similar to uki, but takes an RFC 3986 URI instead of a file path. It may be used to reference remotely stored UKIs, which shall be downloaded using network boot support of the boot loader or firmware on activation.
Example: uki-url http://example.com/fooos.efi
Optionally, in place of an URL a simple filename prefixed with : may be specified. In this case, if the boot loader itself was booted via the network and knows its originating URL it shall replace the last path component of that URL (i.e. the filename part) with the specified filename.
Example: uki-url :fooos.efi
This example would mean: if the boot loader was acquired from http://example.com/somedir/fooosbootldr.img such a line would be treated equivalent to uki-url http://example.com/somedir/fooos.efi.
If this key is set, and the system is not an EFI system, or the boot loader/firmware does not support network booting, this entry shall be hidden. Similarly, if the : syntax is used, but the boot loader was not invoked via network booting (or doesn\u0026rsquo;t know its originating URL) entries of this type shall be hidden.
options shall contain kernel parameters to pass to the Linux kernel to spawn. This key is optional and may appear more than once in which case all specified parameters are combined in the order they are listed.
Example: options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet
devicetree refers to the binary device tree to use when executing the kernel. This key is optional.
Example: devicetree 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.armv7hl/tegra20-paz00.dtb
devicetree-overlay refers to a list of device tree overlays that should be applied by the boot loader. Multiple overlays are separated by spaces and applied in the same order as they are listed. This key is optional but depends on the devicetree key.
Example: devicetree-overlay /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo
architecture refers to the architecture this entry is for. The argument should be an architecture identifier, using the architecture vocabulary defined by the EFI specification (i.e. IA32, x64, IA64, ARM, AA64, …). If specified and it does not match the local system architecture this entry should be hidden. The comparison should be done case-insensitively.
Example: architecture aa64
profile refers to the profile number to use in multi-profile EFI programs. See the section multi-profile UKIs in the UKI Specification for more information. This should only be used when uki or uki-url is set to a multi-profile UKI. Behaviour is implementation-defined for any other case and implementors may choose to ignore the field or issue a warning.
Example: profile 1
Each boot loader menu entry drop-in snippet must include at least a linux or an efi key. Here is an example for a complete drop-in file:
# /boot/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf title Fedora 19 (Rawhide) sort-key fedora machine-id 6a9857a393724b7a981ebb5b8495b9ea version 3.8.0-2.fc19.x86_64 options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet architecture x64 linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux initrd /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd On EFI systems all Linux kernel images should be EFI PE images, or in case of the uki or uki-url key must be EFI PE images conforming to the UKI Specification. In order to increase compatibility with EFI systems it is highly recommended only to install EFI kernel images, even on non-EFI systems, if that\u0026rsquo;s applicable and supported on the specific architecture.
Conversely, in order to increase compatibility it is recommended to install generic kernel images that make few assumptions about the firmware they run on, i.e. it is a good idea that both images shipped as UEFI PE images and those which are not don\u0026rsquo;t make unnecessary assumption on the underlying firmware, i.e. don\u0026rsquo;t hard depend on legacy BIOS calls or UEFI boot services.
When Type #1 boot loader menu entry snippets refer to other files (for linux, initrd, efi, devicetree, and devicetree-overlay), those files must be located on the same partition, and the paths must be absolute paths relative to the root of that file system. The naming of those files can be chosen by the installer. A recommended scheme is described in the next section. Paths should be normalized, i.e. not include .., . or a sequence of more than one /. Paths may be prefixed with a /, but this is optional and has the same effect as paths without it: all paths are always relative to the root directory of the partition they are referenced from.
Even though the backing file system is typically case-insensitive (i.e. VFAT) it is strongly recommended to reference files in the casing actually used for the directories/files, so that placing these files on other file systems is still safe and robust.
Recommended Directory Layout for Additional Files # It is recommended to place the kernel and other other files comprising a single boot loader entry in a separate directory: /\u0026lt;entry-token-or-machine-id\u0026gt;/\u0026lt;version\u0026gt;/. This naming scheme uses the same elements as the boot loader menu entry snippet, providing the same level of uniqueness.
Example: \$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux \$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd
Other naming schemes are possible. In particular, traditionally a flat naming scheme with files in the root directory was used. This is not recommended because it is hard to avoid conflicts in a multi-boot installation.
Standard-conformance Marker File # Unfortunately, there are implementations of boot loading infrastructure that are also using the /loader/entries/ directory, but install files that do not follow this specification. In order to minimize confusion, a boot loader implementation may place the file /loader/entries.srel next to the /loader/entries/ directory containing the ASCII string type1 (followed by a UNIX newline). Tools that need to determine whether an existing directory implements the semantics described here may check for this file and contents: if it exists and contains the mentioned string, it shall assume a standards-compliant implementation is in place. If it exists but contains a different string it shall assume other semantics are implemented. If the file does not exist, no assumptions should be made.
Type #2 EFI Unified Kernel Images # A unified kernel image is a single EFI PE executable combining an EFI stub loader, a kernel image, and possibly other, optional resources. See the UKI Specification for details. The primary place for such unified images is the /EFI/Linux/ directory in \$BOOT. Operating systems should place unified EFI kernels only in the \$BOOT partition. Boot loaders should also look in the /EFI/Linux/ of the ESP — if it is different from \$BOOT — and present a merged list of menu entries from both partitions. Regardless if placed in the primary or secondary location: the files must have the extension .efi. Support for images of this type is of course specific to systems with EFI firmware. Ignore this section if you work on systems not supporting EFI.
Type #2 file names should be chosen from the same restricted character set as Type #1 described above (but with the file name suffix of .efi instead of .conf).
Images of this type have the advantage that all metadata and payload that makes up the boot entry is contained in a single PE file that can be signed cryptographically as one for the purpose of EFI SecureBoot.
A unified kernel image in the /EFI/Linux/ directory contains PE sections described in the UKI Specification.
Of these sections, the .osrel section is used to generate boot entries. The PRETTY_NAME= and VERSION_ID= fields in the embedded os-release file are used the same as title and version in the Type #1 entries. The .cmdline section is used instead of the options field. linux and initrd fields are not necessary, and there is no counterpart for the machine-id field.
On EFI, any such images shall be added to the list of valid boot entries. Absent these fields, other metadata may be used to display the images as boot entries. For a full list of mandatory and allowed fields, see the UKI Specification.
Additional Notes # Note that these boot entry snippets and unified kernels do not need to be the only menu entry sources for a boot loader. It may extend this list of entries with additional items from other configuration files (for example its own native configuration files) or automatically detected other entries without explicit configuration.
To make this explicitly clear: this specification is designed with \u0026ldquo;free\u0026rdquo; operating systems in mind, starting Windows or MacOS is out of focus with these boot loader menu entry snippets, use boot-loader specific solutions for that. In the text above, if we say \u0026ldquo;OS\u0026rdquo; we hence imply \u0026ldquo;free\u0026rdquo;, i.e. primarily Linux (though this could be easily be extended to the BSDs and whatnot).
Note that all paths used in the boot loader menu entry snippets use a Unix-style \u0026ldquo;/\u0026rdquo; as path separator. This needs to be converted to an EFI-style \u0026ldquo;\\\u0026rdquo; separator in EFI boot loaders.
Locating Boot Entries # A boot loader locates the XBOOTLDR partition and the ESP, then simply reads all the files /loader/entries/*.conf in them, and populates its boot menu (and handle gracefully if one of the two partitions is missing). On EFI, it then extends this with any unified kernel images found in /EFI/Linux/*.efi in the two partitions. It may also add additional entries, for example a \u0026ldquo;Reboot into firmware\u0026rdquo; option. Optionally it may sort the menu based on the sort-key, machine-id and version fields, and possibly others. It uses the file name to identify specific items, for example in case it supports storing away default entry information somewhere. A boot loader should generally not modify these files.
For \u0026ldquo;Boot Loader Specification Entries\u0026rdquo; (Type #1), the kernel package installer installs the kernel and initrd images to \$BOOT. It is recommended to place these files in a vendor and OS and installation specific directory. It then generates a boot loader menu entry snippet, placing it in \$BOOT/loader/entries/xyz.conf, with \u0026ldquo;xyz\u0026rdquo; as concatenation of entry-token/machine-id and version information (see above). The files created by a kernel package are tied to the kernel package and should be removed along with it.
For \u0026ldquo;EFI Unified Kernel Images\u0026rdquo; (Type #2), the vendor or kernel package installer should create the combined image and drop it into \$BOOT/EFI/Linux/. This file is also tied to the kernel package and should be removed along with it.
A UI application intended to show available boot options shall operate similarly to a boot loader (and thus search both \$BOOT and the ESP if distinct), but might apply additional filters, for example by filtering the booted OS via the machine ID, or by suppressing all but the newest kernel versions.
An OS installer picks the right place for \$BOOT as defined above (possibly creating a partition and file system for it) and creates the /loader/entries/ directory and the /loader/entries.srel file in it (the latter only if the directory didn\u0026rsquo;t exist yet). It then installs an appropriate boot loader that can read these snippets. Finally, it installs one or more kernel packages.
Boot counting # The main idea is that when boot entries are initially installed, they are marked as \u0026ldquo;indeterminate\u0026rdquo; and assigned a number of boot attempts. Each time the boot loader tries to boot an entry, it decreases this count by one. If the operating system considers the boot as successful, it removes the counter altogether and the entry becomes \u0026ldquo;good\u0026rdquo;. Otherwise, once the assigned number of boots is exhausted, the entry is marked as \u0026ldquo;bad\u0026rdquo;.
Which boots are \u0026ldquo;successful\u0026rdquo; is determined by the operating system. systemd provides a generic mechanism that can be extended with arbitrary checks and actions, see Automatic Boot Assessment, but the boot counting mechanism described in this specification can also be used with other implementations.
The boot counting data is stored in the name of the boot loader entry. A boot loader entry file name may contain a plus (+) followed by a number. This may optionally be followed by a minus (-) followed by a second number. The dot (.) and file name suffix (conf or efi) must immediately follow. Boot counting is enabled for entries which match this pattern.
The first number is the \u0026ldquo;tries left\u0026rdquo; counter signifying how many attempts to boot this entry shall still be made. The second number is the \u0026ldquo;tries done\u0026rdquo; counter, showing how many failed attempts to boot it have already been made. Each time a boot loader entry marked this way is booted, the first counter is decremented, and the second one incremented. (If the second counter is missing, then it is assumed to be equivalent to zero.) If the \u0026ldquo;tries left\u0026rdquo; counter is above zero the entry is still considered \u0026ldquo;indeterminate\u0026rdquo;. A boot entry with the \u0026ldquo;tries left\u0026rdquo; counter at zero is considered \u0026ldquo;bad\u0026rdquo;.
When decrementing the \u0026ldquo;tries left\u0026rdquo; counter, implementations should preserve the total number of digits by padding with leading zeroes if needed. For example, +10 becomes +09 instead of +9. This ensures that the filename length and structure remain constant during counter updates.
The \u0026ldquo;tries done\u0026rdquo; counter should be pre-initialized with fixed number of digits, initially all zero. The number of digits should be sufficient for the expected range of increments (e.g. -00 or -0000). During boot counting, this counter is incremented without changing its width. If the counter would overflow its allocated width, it shall be capped at the maximum representable value (e.g. -99 for two digits) and processing shall continue as normal.
If the boot attempt completed successfully the entry\u0026rsquo;s counters are removed from the name (entry state becomes \u0026ldquo;good\u0026rdquo;), thus turning off boot counting for this entry.
Sorting # The boot loader menu should generally show entries in some order meaningful to the user. The title key is free-form and not suitable to be used as the primary sorting key. Instead, the boot loader should use the following rules:
Entries which are subject to boot counting and are marked as \u0026ldquo;bad\u0026rdquo;, should be sorted later than all other entries. Entries which are marked as \u0026ldquo;indeterminate\u0026rdquo; or \u0026ldquo;good\u0026rdquo; (or were not subject to boot counting at all), are thus sorted earlier.
If sort-key is set on both entries, use in order of priority, the sort-key (A-Z, increasing alphanumerical order), machine-id (A-Z, increasing alphanumerical order), and version keys (decreasing version order).
If sort-key is set on one entry, it sorts earlier.
At the end, if necessary, when sort-key is not set or those fields are not set or are all equal, the boot loader should sort using the file name of the entry (decreasing version sort), with the suffix removed.
Note: This description assumes that the boot loader shows entries in a traditional menu, with newest and \u0026ldquo;best\u0026rdquo; entries at the top, thus entries with a higher version number are sorter earlier. The boot loader is free to use a different direction (or none at all) during display.
Note: The boot loader should allow booting \u0026ldquo;bad\u0026rdquo; entries, e.g. in case no other entries are left or they are unusable for other reasons. It may deemphasize or hide such entries by default.
Note: \u0026ldquo;Bad\u0026rdquo; boot entries have a suffix of \u0026ldquo;+0-n\u0026rdquo;, where n is the number of failed boot attempts. Removal of the suffix is not necessary for comparisons described by the last point above. In the unlikely scenario that we have multiple such boot entries that differ only by the boot counting data, we would sort them by n.
Alphanumerical Order # Free-form strings and machine IDs should be compared using a method equivalent to strcmp(3) on their UTF-8 representations. If just one of the strings is unspecified or empty, it compares lower. If both strings are unspecified or empty, they compare equal.
Version Order # The version format and the comparison algorithm are defined in the Version Format Specification. A specific separator character between the version and other tokens in a string is not mandated by this specification, as it often depends on existing kernel packages which differ between distributions and packaging formats.
Additional discussion # Why is there a need for this specification? # This specification brings the following advantages:
Installation of new boot entries is more robust, as no explicit rewriting of configuration files is required.
It allows an out-of-the-box boot experience on any platform without the need of traditional firmware mechanisms (e.g. BIOS calls, UEFI Boot Services).
It improves dual-boot scenarios. Without cooperation, multiple Linux installations tend to fight over which boot loader becomes the primary one in possession of the MBR or the boot partition, and only that one installation can then update the boot loader configuration. Other Linux installs have to be manually configured to never touch the MBR and instead install a chain-loaded boot loader in their own partition headers. In this new scheme all installations share a loader directory and no manual configuration has to take place. All participants implicitly cooperate due to removal of name collisions and can install/remove their own boot menu entries without interfering with the entries of other installed operating systems.
Drop-in directories are now pretty ubiquitous on Linux as an easy way to extend boot loader menus without having to edit, regenerate or manipulate configuration files. For the sake of uniformity, we should do the same for the boot menu.
Userspace code can sanely parse boot loader menu entries which is essential with modern firmware which does not necessarily initialize USB keyboards during boot, which makes boot menus hard to reach for the user. If userspace code can parse the boot loader menu entries too, UI can be written that select a boot menu item to boot into before rebooting the machine, thus not requiring interactivity during early boot.
To unify and thus simplify menu entries of the various boot loaders, which makes configuration of the boot loading process easier for users, administrators, and developers alike.
For boot loaders with configuration scripts such as grub2, adopting this spec allows for mostly static scripts that are generated only once at first installation, but then do not need to be updated anymore as that is done via drop-in files exclusively.
Why not simply rely on the EFI boot menu logic? # EFI is not ubiquitous, especially not in embedded systems. But even on systems with EFI, which provides a boot options logic that can offer similar functionality, this specification is still needed for the following reasons:
The various EFI implementations implement the boot order/boot item logic to different levels. Some firmware implementations do not offer a boot menu at all and instead unconditionally follow the EFI boot order, booting the first item that is working.
If the firmware setup is used to reset data, usually all EFI boot entries are lost, making the system entirely unbootable, as the firmware setups generally do not offer a UI to define additional boot items. By placing the menu item information on disk, it is always available, even if the firmware configuration is lost.
Harddisk images should be movable between machines and be bootable without requiring firmware configuration. This also requires that the list of boot options is defined on disk, and not in EFI variables alone.
EFI is not universal yet (especially on non-x86 platforms), this specification is useful both for EFI and non-EFI boot loaders.
Many EFI systems disable USB support during early boot to optimize boot times, thus making keyboard input unavailable in the EFI menu. It is thus useful if the OS UI has a standardized way to discover available boot options which can be booted to.
Why is the version comparison logic so complicated? # The sort-key allows us to group entries by \u0026ldquo;operating system\u0026rdquo;, e.g. all versions of Fedora together, no matter if they identify themselves as \u0026ldquo;Fedora Workstation\u0026rdquo; or \u0026ldquo;Fedora Rawhide (prerelease)\u0026rdquo;. The sort-key was introduced only recently, so we need to provide a meaningful order for entries both with and without it. Since it is a new concept, it is assumed that entries with sort-key are newer.
In a traditional menu with entries displayed vertically, we want names to be sorter alpabetically (CentOS, Debian, Fedora, OpenSUSE, …), it would be strange to have them in reverse order. But when multiple kernels are available for the same installation, we want to display the latest kernel with highest priority, i.e. earlier in the list.
Why do you use file renames to store the counter? Why not a regular file? # Mainly two reasons: it\u0026rsquo;s relatively likely that renames can be implemented atomically even in simpler file systems, as renaming generally avoids allocating or releasing data blocks. Writing to file contents has a much bigger chance to be result in incomplete or corrupt data. Moreover renaming has the benefit that the boot count metadata is directly attached to the boot loader entry file, and thus the lifecycle of the metadata and the entry itself are bound together. This means no additional clean-up needs to take place to drop the boot loader counting information for an entry when it is removed.
This is also why the size of the counters should remain fixed while boot counting is active: renames that change the filename length may no longer be atomic on some file systems. On FAT32, for example, long filenames are stored using multiple consecutive directory records, and growing or shrinking a filename can require allocating or releasing these entries. To keep such updates effectively atomic, the specification requires fixed-width counters and pre-allocation of the \u0026ldquo;tries done\u0026rdquo; field so that counter updates do not change the filename length.
Why not use EFI variables for storing the boot counter? # The memory chips used to back the persistent EFI variables are generally not of the highest quality, hence shouldn\u0026rsquo;t be written to more than necessary. This means we can\u0026rsquo;t really use it for changes made regularly during boot, but should use it only for seldom-made configuration changes.
Out of Focus # There are a couple of items that are out of focus for this specification:
If userspace can figure out the available boot options, then this is only useful so much: we\u0026rsquo;d still need to come up with a way how userspace could communicate to the boot loader the default boot loader entry temporarily or persistently. Defining a common scheme for this is certainly a good idea, but out of focus for this specification.
This specification is just about \u0026ldquo;Free\u0026rdquo; Operating systems. Hooking in other operating systems (like Windows and macOS) into the boot menu is a different story and should probably happen outside of this specification. For example, boot loaders might choose to detect other available OSes dynamically at runtime without explicit configuration (like systemd-boot does it), or via native configuration (for example via explicit Grub2 configuration generated once at installation).
This specification leaves undefined what to do about systems which are upgraded from an OS that does not implement this specification. As the previous boot loader logic was largely handled by in distribution-specific ways we probably should leave the upgrade path (and whether there actually is one) to the distributions. The simplest solution might be to simply continue with the old scheme for old installations and use this new scheme only for new installations.
Referencing kernels or initrds on other partitions other than the partition containing the Type #1 boot loader entry. This is by design, as specifying other partitions or devices would require a non-trivial language for denoting device paths. In particular this means that on non-EFI systems boot loader menu entry snippets following this specification cannot be used to spawn other operating systems (such as Windows).
Links # GUID Partition Table
Boot Loader Interface
Discoverable Partitions Specification
systemd-boot(7)
bootctl(1)
systemd-gpt-auto-generator(8)
`}),e.add({id:2,href:"/specifications/specs/configuration_files_specification/",title:"Configuration Files Specification",section:"Specs",content:` Configuration Files Specification # Version Changes 1.0 Initial Release Introduction # Various specifications attempt to define configuration files and file formats. This specification establishes where these files should be looked for, in which order, and how precedence, masking, extensions and overrides work.
The purpose of the rules defined here is to allow OS vendors to implement the hermetic-usr pattern, where all vendor files are shipped in the vendor tree itself (/usr/), including configuration files with system defaults, while allowing local or vendor overrides without modifying the original files, for easier management. This is especially beneficial for image-based deployments, where the vendor tree is read-only.
These rules are derived from existing real-world usage from the systemd project and the libeconf project. It is highly recommended to use libeconf, which is readily available and maintained in all major distributions, rather than reimplementing this specification locally.
This specification is agnostic toward the actual format and content of the configuration files, the precise path used under each top-level hierarchy, and also toward the filenames and extensions, with the exception of the .d/ notation for drop-ins directories. It is strongly encouraged to enforce a specific suffix for the configuration files, in order to disambiguate (e.g.: with backup files), but the choice of which suffix to use is left to each implementation.
Storage Directories and Overrides # In order to allow shipping system defaults owned by the OS vendor, while at the same time letting local users or admins override those defaults, /usr/ and /etc/ are both supported for storage of configuration files, with the latter having higher priority. The precise location under /usr/ is left open for the implementation to decide - it could be hard-coded to /usr/lib/ or it could be left to each application to pick from various options, such as /usr/share/ or /usr/etc/. Programs must work correctly if no configuration files are found in /etc/. Optionally, /run/ is also supported for ephemeral overrides.
For example, /usr/lib/foo/bar.conf provides the default configuration file. If /run/foo/bar.conf is present and supported, it would take precedence over /usr/lib/foo/bar.conf. Finally, a user can create /etc/foo/bar.conf which would take precedence and completely override both.
Masking # As a special override case, it must be possible to mask files across different locations by creating a symlink to /dev/null or an empty file.
For example, an empty /etc/foo/bar.conf means that /usr/lib/foo/bar.conf is masked and thus not parsed.
Drop-ins # All configuration paths must support drop-ins, except for configuration file formats where automatic combining of multiple files is not feasible, for example scripts or structured documents. Supporting drop-ins means that in addition to parsing a full configuration file, an implementation also parses the drop-in files in the drop-in directories associated with it.
Drop-ins always have higher precedence than the configuration file they refer to. Drop-ins are sorted in the lexicographic order using the file name without the path, regardless of the hierarchy under which they are stored. The drop-ins that are later in this order have higher precedence.
Considering the following files are present on the filesystem, this would be the order in which the files are parsed. Note, that files with the same name override each other. The configuration in bar.conf has the lowest priority, and is read before a.conf and b.conf. b.conf has the highest priority:
/usr/lib/foo/bar.conf (overridden by /etc/foo/bar.conf) /etc/foo/bar.conf /usr/lib/foo/bar.conf.d/a.conf (overridden by /etc/foo/bar.conf.d/a.conf) /etc/foo/bar.conf.d/a.conf /usr/lib/foo/bar.conf.d/b.conf If a config file is masked, drop-ins must still be parsed, unless they are masked themselves.
For example, even if /usr/lib/foo/bar.conf is masked by an empty /etc/foo/bar.conf, /usr/lib/foo/bar.conf.d/a.conf must still be parsed and applied, unless there is also an empty /etc/foo/bar.conf.d/a.conf, in which case the drop-in is masked too.
Drop-ins are not recursive, so a drop-in cannot have a directory of drop-ins.
For example, /etc/foo/bar.conf.d/a.conf cannot be overridden by /etc/foo/bar.conf.d/a.conf.d/b.conf, and the latter must be ignored if it exists.
Drop-ins without Main Configuration File # Optionally, schemes with only drop-ins, without a \u0026lsquo;main\u0026rsquo; configuration file, should also be supported by implementations. In such schemes many drop-ins are loaded from a common directory in each hierarchy.
For example, /usr/lib/foo.d/a.conf, /usr/lib/foo.d/b.conf and /etc/foo.d/c.conf are all loaded and parsed in this scheme, in this order.
`}),e.add({id:3,href:"/specifications/specs/discoverable_disk_image/",title:"Discoverable Disk Image",section:"Specs",content:` Discoverable Disk Image (DDI) # Version Changes 1.0 Initial Release DDIs (Discoverable Disk Images) are self-describing file system images that follow the DPS ( Discoverable Partitions Specification), wrapped in a GPT partition table, that may contain root (or /usr/) filesystems for bootable OS images, system extensions, configuration extensions, portable services, containers and more, and shall be protected by signed dm-verity all combined into one. They are designed to be composable and stackable, and provide security by default.
Image Format # The images use the GPT partition table verbatim, so it will not be redefined here. Each partition contains a standard Linux filesystem (e.g.: erofs), so again this will not be redefined here. The DPS defines the GUIDs to use and the format of the dm-verity signature partition\u0026rsquo;s JSON content.
It is recommended to use a sector size of 512 bytes or 4096 for DDIs. Software operating with DDIs should automatically derive the sector size used for a DDI by looking for the EFI PART magic string at offsets 512 or 4096, as per GPT specification.
Naming # DDIs should use .raw as file suffix. A secondary suffix may be used to clarify the specific usage class of a DDI. For now the two secondary suffixes .sysext.raw and .confext.raw are defined (for system extension DDIs and configuration extension DDIs, see Extension Images for details).
The MIME type for DDIs is application/vnd.efi.img, as per IANA.
Image Version # If the DDI is versioned, the version format described in the Version Format Specification must be used. The underscore character (_) must be used to separate the version from the name of the image. For example: foo_1.2.raw denotes a foo DDI with version 1.2.
`}),e.add({id:4,href:"/specifications/specs/discoverable_partitions_specification/",title:"Discoverable Partitions Specification",section:"Specs",content:` The Discoverable Partitions Specification (DPS) # Version Changes 1.0 Initial Release TL;DR: Let\u0026rsquo;s automatically discover, mount and enable the root partition, /home/, /srv/, /var/ and /var/tmp/ and the swap partitions based on GUID Partition Tables (GPT)!
This specification describes the use of GUID Partition Table (GPT) UUIDs to enable automatic discovery of partitions and their intended mountpoints. Traditionally Linux has made little use of partition types, mostly just defining one UUID for file system/data partitions and another one for swap partitions. With this specification, we introduce additional partition types for specific uses. This has many benefits:
OS installers can automatically discover and make sense of partitions of existing Linux installations. The OS can discover and mount the necessary file systems with a non-existent or incomplete /etc/fstab file and without the root= kernel command line option. Container managers (such as nspawn and libvirt-lxc) can introspect and set up file systems contained in GPT disk images automatically and mount them to the right places, thus allowing booting the same, identical images on bare metal and in Linux containers. This enables true, natural portability of disk images between physical machines and Linux containers. As a help to administrators and users partition manager tools can show more descriptive information about partitions tables. Note that the OS side of this specification is currently implemented in systemd 211 and newer in the systemd-gpt-auto-generator(8) generator tool. Note that automatic discovery of the root only works if the boot loader communicates this information to the OS, by implementing the Boot Loader Interface.
Defined Partition Type UUIDs # Name Partition Type UUID Allowed File Systems Explanation Root Partition (Alpha) 6523f8ae-3eb1-4e2a-a05a-18b695ae656f SD_GPT_ROOT_ALPHA Any native, optionally in LUKS On systems with matching architecture, the first partition with this type UUID on the disk containing the active EFI ESP is automatically mounted to the root directory /. If the partition is encrypted with LUKS or has dm-verity integrity data (see below), the device mapper file will be named /dev/mapper/root. Root Partition (ARC) d27f46ed-2919-4cb8-bd25-9531f3c16534 SD_GPT_ROOT_ARC ditto ditto Root Partition (32-bit ARM) 69dad710-2ce4-4e3c-b16c-21a1d49abed3 SD_GPT_ROOT_ARM ditto ditto Root Partition (64-bit ARM/AArch64) b921b045-1df0-41c3-af44-4c6f280d3fae SD_GPT_ROOT_ARM64 ditto ditto Root Partition (Itanium/IA-64) 993d8d3d-f80e-4225-855a-9daf8ed7ea97 SD_GPT_ROOT_IA64 ditto ditto Root Partition (LoongArch 64-bit) 77055800-792c-4f94-b39a-98c91b762bb6 SD_GPT_ROOT_LOONGARCH64 ditto ditto Root Partition (32-bit MIPS BigEndian (mips)) e9434544-6e2c-47cc-bae2-12d6deafb44c ditto ditto Root Partition (64-bit MIPS BigEndian (mips64)) d113af76-80ef-41b4-bdb6-0cff4d3d4a25 ditto ditto Root Partition (32-bit MIPS LittleEndian (mipsel)) 37c58c8a-d913-4156-a25f-48b1b64e07f0 SD_GPT_ROOT_MIPS_LE ditto ditto Root Partition (64-bit MIPS LittleEndian (mips64el)) 700bda43-7a34-4507-b179-eeb93d7a7ca3 SD_GPT_ROOT_MIPS64_LE ditto ditto Root Partition (HPPA/PARISC) 1aacdb3b-5444-4138-bd9e-e5c2239b2346 SD_GPT_ROOT_PARISC ditto ditto Root Partition (32-bit PowerPC) 1de3f1ef-fa98-47b5-8dcd-4a860a654d78 SD_GPT_ROOT_PPC ditto ditto Root Partition (64-bit PowerPC BigEndian) 912ade1d-a839-4913-8964-a10eee08fbd2 SD_GPT_ROOT_PPC64 ditto ditto Root Partition (64-bit PowerPC LittleEndian) c31c45e6-3f39-412e-80fb-4809c4980599 SD_GPT_ROOT_PPC64_LE ditto ditto Root Partition (RISC-V 32-bit) 60d5a7fe-8e7d-435c-b714-3dd8162144e1 SD_GPT_ROOT_RISCV32 ditto ditto Root Partition (RISC-V 64-bit) 72ec70a6-cf74-40e6-bd49-4bda08e8f224 SD_GPT_ROOT_RISCV64 ditto ditto Root Partition (s390) 08a7acea-624c-4a20-91e8-6e0fa67d23f9 SD_GPT_ROOT_S390 ditto ditto Root Partition (s390x) 5eead9a9-fe09-4a1e-a1d7-520d00531306 SD_GPT_ROOT_S390X ditto ditto Root Partition (TILE-Gx) c50cdd70-3862-4cc3-90e1-809a8c93ee2c SD_GPT_ROOT_TILEGX ditto ditto Root Partition (x86) 44479540-f297-41b2-9af7-d131d5f0458a SD_GPT_ROOT_X86 ditto ditto Root Partition (amd64/x86_64) 4f68bce3-e8cd-4db1-96e7-fbcaf984b709 SD_GPT_ROOT_X86_64 ditto ditto /usr/ Partition (Alpha) e18cf08c-33ec-4c0d-8246-c6c6fb3da024 SD_GPT_USR_ALPHA Any native, optionally in LUKS Similar semantics to root partition, but just the /usr/ partition. /usr/ Partition (ARC) 7978a683-6316-4922-bbee-38bff5a2fecc SD_GPT_USR_ARC ditto ditto /usr/ Partition (32-bit ARM) 7d0359a3-02b3-4f0a-865c-654403e70625 SD_GPT_USR_ARM ditto ditto /usr/ Partition (64-bit ARM/AArch64) b0e01050-ee5f-4390-949a-9101b17104e9 SD_GPT_USR_ARM64 ditto ditto /usr/ Partition (Itanium/IA-64) 4301d2a6-4e3b-4b2a-bb94-9e0b2c4225ea SD_GPT_USR_IA64 ditto ditto /usr/ Partition (LoongArch 64-bit) e611c702-575c-4cbe-9a46-434fa0bf7e3f SD_GPT_USR_LOONGARCH64 ditto ditto /usr/ Partition (32-bit MIPS BigEndian (mips)) 773b2abc-2a99-4398-8bf5-03baac40d02b ditto ditto /usr/ Partition (64-bit MIPS BigEndian (mips64)) 57e13958-7331-4365-8e6e-35eeee17c61b ditto ditto /usr/ Partition (32-bit MIPS LittleEndian (mipsel)) 0f4868e9-9952-4706-979f-3ed3a473e947 SD_GPT_USR_MIPS_LE ditto ditto /usr/ Partition (64-bit MIPS LittleEndian (mips64el)) c97c1f32-ba06-40b4-9f22-236061b08aa8 SD_GPT_USR_MIPS64_LE ditto ditto /usr/ Partition (HPPA/PARISC) dc4a4480-6917-4262-a4ec-db9384949f25 SD_GPT_USR_PARISC ditto ditto /usr/ Partition (32-bit PowerPC) 7d14fec5-cc71-415d-9d6c-06bf0b3c3eaf SD_GPT_USR_PPC ditto ditto /usr/ Partition (64-bit PowerPC BigEndian) 2c9739e2-f068-46b3-9fd0-01c5a9afbcca SD_GPT_USR_PPC64 ditto ditto /usr/ Partition (64-bit PowerPC LittleEndian) 15bb03af-77e7-4d4a-b12b-c0d084f7491c SD_GPT_USR_PPC64_LE ditto ditto /usr/ Partition (RISC-V 32-bit) b933fb22-5c3f-4f91-af90-e2bb0fa50702 SD_GPT_USR_RISCV32 ditto ditto /usr/ Partition (RISC-V 64-bit) beaec34b-8442-439b-a40b-984381ed097d SD_GPT_USR_RISCV64 ditto ditto /usr/ Partition (s390) cd0f869b-d0fb-4ca0-b141-9ea87cc78d66 SD_GPT_USR_S390 ditto ditto /usr/ Partition (s390x) 8a4f5770-50aa-4ed3-874a-99b710db6fea SD_GPT_USR_S390X ditto ditto /usr/ Partition (TILE-Gx) 55497029-c7c1-44cc-aa39-815ed1558630 SD_GPT_USR_TILEGX ditto ditto /usr/ Partition (x86) 75250d76-8cc6-458e-bd66-bd47cc81a812 SD_GPT_USR_X86 ditto ditto /usr/ Partition (amd64/x86_64) 8484680c-9521-48c6-9c11-b0720656f69e SD_GPT_USR_X86_64 ditto ditto Root Verity Partition (Alpha) fc56d9e9-e6e5-4c06-be32-e74407ce09a5 SD_GPT_ROOT_ALPHA_VERITY A dm-verity superblock followed by hash data Contains dm-verity integrity hash data for the matching root partition. If this feature is used the partition UUID of the root partition should be the first 128 bits of the root hash of the dm-verity hash data, and the partition UUID of this dm-verity partition should be the final 128 bits of it, so that the root partition and its Verity partition can be discovered easily, simply by specifying the root hash. Root Verity Partition (ARC) 24b2d975-0f97-4521-afa1-cd531e421b8d SD_GPT_ROOT_ARC_VERITY ditto ditto Root Verity Partition (32-bit ARM) 7386cdf2-203c-47a9-a498-f2ecce45a2d6 SD_GPT_ROOT_ARM_VERITY ditto ditto Root Verity Partition (64-bit ARM/AArch64) df3300ce-d69f-4c92-978c-9bfb0f38d820 SD_GPT_ROOT_ARM64_VERITY ditto ditto Root Verity Partition (Itanium/IA-64) 86ed10d5-b607-45bb-8957-d350f23d0571 SD_GPT_ROOT_IA64_VERITY ditto ditto Root Verity Partition (LoongArch 64-bit) f3393b22-e9af-4613-a948-9d3bfbd0c535 SD_GPT_ROOT_LOONGARCH64_VERITY ditto ditto Root Verity Partition (32-bit MIPS BigEndian (mips)) 7a430799-f711-4c7e-8e5b-1d685bd48607 ditto ditto Root Verity Partition (64-bit MIPS BigEndian (mips64)) 579536f8-6a33-4055-a95a-df2d5e2c42a8 ditto ditto Root Verity Partition (32-bit MIPS LittleEndian (mipsel)) d7d150d2-2a04-4a33-8f12-16651205ff7b SD_GPT_ROOT_MIPS_LE_VERITY ditto ditto Root Verity Partition (64-bit MIPS LittleEndian (mips64el)) 16b417f8-3e06-4f57-8dd2-9b5232f41aa6 SD_GPT_ROOT_MIPS64_LE_VERITY ditto ditto Root Verity Partition (HPPA/PARISC) d212a430-fbc5-49f9-a983-a7feef2b8d0e SD_GPT_ROOT_PARISC_VERITY ditto ditto Root Verity Partition (64-bit PowerPC LittleEndian) 906bd944-4589-4aae-a4e4-dd983917446a SD_GPT_ROOT_PPC64_LE_VERITY ditto ditto Root Verity Partition (64-bit PowerPC BigEndian) 9225a9a3-3c19-4d89-b4f6-eeff88f17631 SD_GPT_ROOT_PPC64_VERITY ditto ditto Root Verity Partition (32-bit PowerPC) 98cfe649-1588-46dc-b2f0-add147424925 SD_GPT_ROOT_PPC_VERITY ditto ditto Root Verity Partition (RISC-V 32-bit) ae0253be-1167-4007-ac68-43926c14c5de SD_GPT_ROOT_RISCV32_VERITY ditto ditto Root Verity Partition (RISC-V 64-bit) b6ed5582-440b-4209-b8da-5ff7c419ea3d SD_GPT_ROOT_RISCV64_VERITY ditto ditto Root Verity Partition (s390) 7ac63b47-b25c-463b-8df8-b4a94e6c90e1 SD_GPT_ROOT_S390_VERITY ditto ditto Root Verity Partition (s390x) b325bfbe-c7be-4ab8-8357-139e652d2f6b SD_GPT_ROOT_S390X_VERITY ditto ditto Root Verity Partition (TILE-Gx) 966061ec-28e4-4b2e-b4a5-1f0a825a1d84 SD_GPT_ROOT_TILEGX_VERITY ditto ditto Root Verity Partition (amd64/x86_64) 2c7357ed-ebd2-46d9-aec1-23d437ec2bf5 SD_GPT_ROOT_X86_64_VERITY ditto ditto Root Verity Partition (x86) d13c5d3b-b5d1-422a-b29f-9454fdc89d76 SD_GPT_ROOT_X86_VERITY ditto ditto /usr/ Verity Partition (Alpha) 8cce0d25-c0d0-4a44-bd87-46331bf1df67 SD_GPT_USR_ALPHA_VERITY A dm-verity superblock followed by hash data Similar semantics to root Verity partition, but just for the /usr/ partition. /usr/ Verity Partition (ARC) fca0598c-d880-4591-8c16-4eda05c7347c SD_GPT_USR_ARC_VERITY ditto ditto /usr/ Verity Partition (32-bit ARM) c215d751-7bcd-4649-be90-6627490a4c05 SD_GPT_USR_ARM_VERITY ditto ditto /usr/ Verity Partition (64-bit ARM/AArch64) 6e11a4e7-fbca-4ded-b9e9-e1a512bb664e SD_GPT_USR_ARM64_VERITY ditto ditto /usr/ Verity Partition (Itanium/IA-64) 6a491e03-3be7-4545-8e38-83320e0ea880 SD_GPT_USR_IA64_VERITY ditto ditto /usr/ Verity Partition (LoongArch 64-bit) f46b2c26-59ae-48f0-9106-c50ed47f673d SD_GPT_USR_LOONGARCH64_VERITY ditto ditto /usr/ Verity Partition (32-bit MIPS BigEndian (mips)) 6e5a1bc8-d223-49b7-bca8-37a5fcceb996 ditto ditto /usr/ Verity Partition (64-bit MIPS BigEndian (mips64)) 81cf9d90-7458-4df4-8dcf-c8a3a404f09b ditto ditto /usr/ Verity Partition (32-bit MIPS LittleEndian (mipsel)) 46b98d8d-b55c-4e8f-aab3-37fca7f80752 SD_GPT_USR_MIPS_LE_VERITY ditto ditto /usr/ Verity Partition (64-bit MIPS LittleEndian (mips64el)) 3c3d61fe-b5f3-414d-bb71-8739a694a4ef SD_GPT_USR_MIPS64_LE_VERITY ditto ditto /usr/ Verity Partition (HPPA/PARISC) 5843d618-ec37-48d7-9f12-cea8e08768b2 SD_GPT_USR_PARISC_VERITY ditto ditto /usr/ Verity Partition (64-bit PowerPC LittleEndian) ee2b9983-21e8-4153-86d9-b6901a54d1ce SD_GPT_USR_PPC64_LE_VERITY ditto ditto /usr/ Verity Partition (64-bit PowerPC BigEndian) bdb528a5-a259-475f-a87d-da53fa736a07 SD_GPT_USR_PPC64_VERITY ditto ditto /usr/ Verity Partition (32-bit PowerPC) df765d00-270e-49e5-bc75-f47bb2118b09 SD_GPT_USR_PPC_VERITY ditto ditto /usr/ Verity Partition (RISC-V 32-bit) cb1ee4e3-8cd0-4136-a0a4-aa61a32e8730 SD_GPT_USR_RISCV32_VERITY ditto ditto /usr/ Verity Partition (RISC-V 64-bit) 8f1056be-9b05-47c4-81d6-be53128e5b54 SD_GPT_USR_RISCV64_VERITY ditto ditto /usr/ Verity Partition (s390) b663c618-e7bc-4d6d-90aa-11b756bb1797 SD_GPT_USR_S390_VERITY ditto ditto /usr/ Verity Partition (s390x) 31741cc4-1a2a-4111-a581-e00b447d2d06 SD_GPT_USR_S390X_VERITY ditto ditto /usr/ Verity Partition (TILE-Gx) 2fb4bf56-07fa-42da-8132-6b139f2026ae SD_GPT_USR_TILEGX_VERITY ditto ditto /usr/ Verity Partition (amd64/x86_64) 77ff5f63-e7b6-4633-acf4-1565b864c0e6 SD_GPT_USR_X86_64_VERITY ditto ditto /usr/ Verity Partition (x86) 8f461b0d-14ee-4e81-9aa9-049b6fb97abd SD_GPT_USR_X86_VERITY ditto ditto Root Verity Signature Partition (Alpha) d46495b7-a053-414f-80f7-700c99921ef8 SD_GPT_ROOT_ALPHA_VERITY_SIG A serialized JSON object, see below Contains a root hash and a PKCS#7 signature for it, permitting signed dm-verity GPT images. Root Verity Signature Partition (ARC) 143a70ba-cbd3-4f06-919f-6c05683a78bc SD_GPT_ROOT_ARC_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit ARM) 42b0455f-eb11-491d-98d3-56145ba9d037 SD_GPT_ROOT_ARM_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit ARM/AArch64) 6db69de6-29f4-4758-a7a5-962190f00ce3 SD_GPT_ROOT_ARM64_VERITY_SIG ditto ditto Root Verity Signature Partition (Itanium/IA-64) e98b36ee-32ba-4882-9b12-0ce14655f46a SD_GPT_ROOT_IA64_VERITY_SIG ditto ditto Root Verity Signature Partition (LoongArch 64-bit) 5afb67eb-ecc8-4f85-ae8e-ac1e7c50e7d0 SD_GPT_ROOT_LOONGARCH64_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit MIPS BigEndian (mips)) bba210a2-9c5d-45ee-9e87-ff2ccbd002d0 ditto ditto Root Verity Signature Partition (64-bit MIPS BigEndian (mips64)) 43ce94d4-0f3d-4999-8250-b9deafd98e6e ditto ditto Root Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) c919cc1f-4456-4eff-918c-f75e94525ca5 SD_GPT_ROOT_MIPS_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) 904e58ef-5c65-4a31-9c57-6af5fc7c5de7 SD_GPT_ROOT_MIPS64_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (HPPA/PARISC) 15de6170-65d3-431c-916e-b0dcd8393f25 SD_GPT_ROOT_PARISC_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit PowerPC LittleEndian) d4a236e7-e873-4c07-bf1d-bf6cf7f1c3c6 SD_GPT_ROOT_PPC64_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit PowerPC BigEndian) f5e2c20c-45b2-4ffa-bce9-2a60737e1aaf SD_GPT_ROOT_PPC64_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit PowerPC) 1b31b5aa-add9-463a-b2ed-bd467fc857e7 SD_GPT_ROOT_PPC_VERITY_SIG ditto ditto Root Verity Signature Partition (RISC-V 32-bit) 3a112a75-8729-4380-b4cf-764d79934448 SD_GPT_ROOT_RISCV32_VERITY_SIG ditto ditto Root Verity Signature Partition (RISC-V 64-bit) efe0f087-ea8d-4469-821a-4c2a96a8386a SD_GPT_ROOT_RISCV64_VERITY_SIG ditto ditto Root Verity Signature Partition (s390) 3482388e-4254-435a-a241-766a065f9960 SD_GPT_ROOT_S390_VERITY_SIG ditto ditto Root Verity Signature Partition (s390x) c80187a5-73a3-491a-901a-017c3fa953e9 SD_GPT_ROOT_S390X_VERITY_SIG ditto ditto Root Verity Signature Partition (TILE-Gx) b3671439-97b0-4a53-90f7-2d5a8f3ad47b SD_GPT_ROOT_TILEGX_VERITY_SIG ditto ditto Root Verity Signature Partition (amd64/x86_64) 41092b05-9fc8-4523-994f-2def0408b176 SD_GPT_ROOT_X86_64_VERITY_SIG ditto ditto Root Verity Signature Partition (x86) 5996fc05-109c-48de-808b-23fa0830b676 SD_GPT_ROOT_X86_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (Alpha) 5c6e1c76-076a-457a-a0fe-f3b4cd21ce6e SD_GPT_USR_ALPHA_VERITY_SIG A serialized JSON object, see below Similar semantics to root Verity signature partition, but just for the /usr/ partition. /usr/ Verity Signature Partition (ARC) 94f9a9a1-9971-427a-a400-50cb297f0f35 SD_GPT_USR_ARC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit ARM) d7ff812f-37d1-4902-a810-d76ba57b975a SD_GPT_USR_ARM_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit ARM/AArch64) c23ce4ff-44bd-4b00-b2d4-b41b3419e02a SD_GPT_USR_ARM64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (Itanium/IA-64) 8de58bc2-2a43-460d-b14e-a76e4a17b47f SD_GPT_USR_IA64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (LoongArch 64-bit) b024f315-d330-444c-8461-44bbde524e99 SD_GPT_USR_LOONGARCH64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit MIPS BigEndian (mips)) 97ae158d-f216-497b-8057-f7f905770f54 ditto ditto /usr/ Verity Signature Partition (64-bit MIPS BigEndian (mips64)) 05816ce2-dd40-4ac6-a61d-37d32dc1ba7d ditto ditto /usr/ Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) 3e23ca0b-a4bc-4b4e-8087-5ab6a26aa8a9 SD_GPT_USR_MIPS_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) f2c2c7ee-adcc-4351-b5c6-ee9816b66e16 SD_GPT_USR_MIPS64_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (HPPA/PARISC) 450dd7d1-3224-45ec-9cf2-a43a346d71ee SD_GPT_USR_PARISC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit PowerPC LittleEndian) c8bfbd1e-268e-4521-8bba-bf314c399557 SD_GPT_USR_PPC64_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit PowerPC BigEndian) 0b888863-d7f8-4d9e-9766-239fce4d58af SD_GPT_USR_PPC64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit PowerPC) 7007891d-d371-4a80-86a4-5cb875b9302e SD_GPT_USR_PPC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (RISC-V 32-bit) c3836a13-3137-45ba-b583-b16c50fe5eb4 SD_GPT_USR_RISCV32_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (RISC-V 64-bit) d2f9000a-7a18-453f-b5cd-4d32f77a7b32 SD_GPT_USR_RISCV64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (s390) 17440e4f-a8d0-467f-a46e-3912ae6ef2c5 SD_GPT_USR_S390_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (s390x) 3f324816-667b-46ae-86ee-9b0c0c6c11b4 SD_GPT_USR_S390X_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (TILE-Gx) 4ede75e2-6ccc-4cc8-b9c7-70334b087510 SD_GPT_USR_TILEGX_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (amd64/x86_64) e7bb33fb-06cf-4e81-8273-e543b413e2e2 SD_GPT_USR_X86_64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (x86) 974a71c0-de41-43c3-be5d-5c5ccd1ad2c0 SD_GPT_USR_X86_VERITY_SIG ditto ditto EFI System Partition c12a7328-f81f-11d2-ba4b-00a0c93ec93b SD_GPT_ESP VFAT The ESP used for the current boot is automatically mounted to /boot/ or /efi/, unless a different partition is mounted there (possibly via /etc/fstab) or the mount point directory is non-empty on the root disk. If both ESP and XBOOTLDR exist, the /efi/ mount point shall be used for ESP. This partition type is defined by the UEFI Specification. Extended Boot Loader Partition bc13c2ff-59e6-4262-a352-b275fd6f7172 SD_GPT_XBOOTLDR Typically VFAT The Extended Boot Loader Partition (XBOOTLDR) used for the current boot is automatically mounted to /boot/, unless a different partition is mounted there (possibly via /etc/fstab) or the mount point directory is non-empty on the root disk. This partition type is defined by the Boot Loader Specification. Swap 0657fd6d-a4ab-43c4-84e5-0933c84b4f4f SD_GPT_SWAP Swap, optionally in LUKS All swap partitions on the disk containing the root partition are automatically enabled. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/swap. This partition type predates the Discoverable Partitions Specification. Home Partition 933ac7e1-2eb4-4f13-b844-0e14e2aef915 SD_GPT_HOME Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /home/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/home. Server Data Partition 3b8f8425-20e0-4f3b-907f-1a25a76f98e8 SD_GPT_SRV Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /srv/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/srv. Variable Data Partition 4d21b016-b534-45c2-a9fb-5c16e091fd2d SD_GPT_VAR Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/ — under the condition that its partition UUID matches the first 128 bits of HMAC-SHA256(machine-id, 0x4d21b016b53445c2a9fb5c16e091fd2d) (i.e. the SHA256 HMAC hash of the binary type UUID keyed by the machine ID as read from /etc/machine-id. This special requirement is made because /var/ (unlike the other partition types listed here) is inherently private to a specific installation and cannot possibly be shared between multiple OS installations on the same disk, and thus should be bound to a specific instance of the OS, identified by its machine ID. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/var. Temporary Data Partition 7ec6f557-3bc5-4aca-b293-16ef5df639d1 SD_GPT_TMP Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/tmp/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/tmp. Note that the intended mount point is indeed /var/tmp/, not /tmp/. The latter is typically maintained in memory via tmpfs and does not require a partition on disk. In some cases it might be desirable to make /tmp/ persistent too, in which case it is recommended to make it a symlink or bind mount to /var/tmp/, thus not requiring its own partition type UUID. Per-user Home Partition 773f91ef-66d4-49b5-bd83-d683bf40ad16 SD_GPT_USER_HOME Any native, optionally in LUKS A home partition of a user, managed by systemd-homed. Generic Linux Data Partition 0fc63daf-8483-4772-8e79-3d69d8477de4 SD_GPT_LINUX_GENERIC Any native, optionally in LUKS No automatic mounting takes place for other Linux data partitions. This partition type should be used for all partitions that carry Linux file systems. The installer needs to mount them explicitly via entries in /etc/fstab. Optionally, these partitions may be encrypted with LUKS. This partition type predates the Discoverable Partitions Specification. Other GPT type IDs might be used on Linux, for example to mark software RAID or LVM partitions. The definitions of those GPT types is outside of the scope of this specification.
systemd-id128(1)\u0026rsquo;s show command may be used to list those GPT partition type UUIDs.
Partition Names # For partitions of the types listed above it is recommended to use human-friendly, descriptive partition names in the GPT partition table, for example \u0026ldquo;Home\u0026rdquo;, \u0026ldquo;Server Data\u0026rdquo;, \u0026ldquo;Fedora Root\u0026rdquo; and similar, possibly localized.
For the Root/Verity/Verity signature partitions it might make sense to use a versioned naming scheme reflecting the OS name and its version, e.g. \u0026ldquo;fooOS_2021.4\u0026rdquo; or similar. For details about the version format see the Version Format Specification. The underscore character (_) must be used to separate the version from the name of the image.
Partition Attribute Flags # This specification defines three GPT partition attribute flags that may be set for the partition types defined above:
For the root, /usr/, Verity, Verity signature, home, server data, variable data, temporary data, swap, and extended boot loader partitions, the partition flag bit 63 (\u0026quot;no-auto\u0026quot;, SD_GPT_FLAG_NO_AUTO) may be used to turn off auto-discovery for the specific partition. If set, the partition will not be automatically mounted or enabled.
For the root, /usr/, Verity, Verity signature home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 60 (\u0026quot;read-only\u0026quot;, SD_GPT_FLAG_READ_ONLY) may be used to mark a partition for read-only mounts only. If set, the partition will be mounted read-only instead of read-write. Note that the variable data partition and the temporary data partition will generally not be able to serve their purpose if marked read-only, since by their very definition they are supposed to be mutable. (The home and server data partitions are generally assumed to be mutable as well, but the requirement for them is not equally strong.) Because of that, while the read-only flag is defined and supported, it\u0026rsquo;s almost never a good idea to actually use it for these partitions. Also note that Verity and signature partitions are by their semantics always read-only. The flag is hence of little effect for them, and it is recommended to set it unconditionally for the Verity and signature partition types.
For the root, /usr/, home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 59 (\u0026quot;grow-file-system\u0026quot;, SD_GPT_FLAG_GROWFS) may be used to mark a partition for automatic growing of the contained file system to the size of the partition when mounted. Tools that automatically mount disk image with a GPT partition table are suggested to implicitly grow the contained file system to the partition size they are contained in, if they are found to be smaller. This flag is without effect on partitions marked \u0026ldquo;read-only\u0026rdquo;.
Note that the first two flag definitions happen to correspond nicely to the same ones used by Microsoft Basic Data Partitions.
All three of these flags generally affect only auto-discovery and automatic mounting of disk images. If partitions marked with these flags are mounted using low-level commands like mount(8) or directly with mount(2), they typically have no effect.
Verity # The Root//usr/ partition types and their matching Verity and Verity signature partitions enable relatively automatic handling of dm-verity protected setups. These types are defined with two modes of operation in mind:
A trusted Verity root hash is passed in externally, for example is specified on the kernel command line that is signed along with the kernel image using SecureBoot PE signing (which in turn is tested against a set of firmware-provided set of signing keys). If so, discovery and setup of a Verity volume may be fully automatic: if the root partition\u0026rsquo;s UUID is chosen to match the first 128 bit of the root hash, and the matching Verity partition UUIDs is chosen to match the last 128bit of the root hash, then automatic discovery and match-up of the two partitions is possible, as the root hash is enough to both find the partitions and then combine them in a Verity volume. In this mode a Verity signature partition is not used and unnecessary.
A Verity signature partition is included on the disk, with a signature to be tested against a system-provided set of signing keys. The signature partition primarily contains two fields: the root hash to use, and a PKCS#7 signature of it, using a signature key trusted by the OS. If so, discovery and setup of a Verity volume may be fully automatic. First, the specified root hash is validated with the signature and the OS-provided trusted keys. If the signature checks out the root hash is then used in the same way as in the first mode of operation described above.
Both modes of operation may be combined in a single image. This is particularly useful for images that shall be usable in two different contexts: for example an image that shall be able to boot directly on UEFI systems (in which case it makes sense to include the root hash on the kernel command line that is included in the signed kernel image to boot, as per mode of operation #1 above), but also be able to used as image for a container engine (such as systemd-nspawn), which can use the signature partition to validate the image, without making use of the signed kernel image (and thus following mode of operation #2).
The Verity signature partition\u0026rsquo;s contents should be a serialized JSON object in text form, padded with NUL bytes to the next multiple of 4096 bytes in size. Currently three fields are defined for the JSON object:
The (mandatory) rootHash field should be a string containing the Verity root hash, formatted as series of (lowercase) hex characters.
The (mandatory) signature field should be a string containing the PKCS#7 signature of the root hash, in Base64-encoded DER format. This should be the same format used by the Linux kernel\u0026rsquo;s dm-verity signature logic, i.e. the signed data should be the exact string representation of the hash, as stored in rootHash above.
The (optional) certificateFingerprint field should be a string containing a SHA256 fingerprint of the X.509 certificate in DER format for the key that signed the root hash, formatted as series of (lowercase) hex characters (no : separators or such).
More fields might be added in later revisions of this specification.
Suggested Mode of Operation # An installer that repartitions the hard disk should use the above UUID partition types for appropriate partitions it creates.
An installer which supports a \u0026ldquo;manual partitioning\u0026rdquo; interface may choose to pre-populate the interface with swap, /home/, /srv/, /var/tmp/ partitions of pre-existing Linux installations, identified with the GPT type UUIDs above. The installer should not pre-populate such an interface with any identified root, /usr or /var/ partition unless the intention is to overwrite an existing operating system that might be installed.
An installer may omit creating entries in /etc/fstab for root, /home/, /srv/, /var/, /var/tmp and for the swap partitions if they use these UUID partition types, and are the first partitions on the disk of each type. If the ESP shall be mounted to /efi/ (or /boot/), it may additionally omit creating the entry for it in /etc/fstab. If the EFI partition shall not be mounted to /efi/ or /boot/, it must create /etc/fstab entries for them. If other partitions are used (for example for /usr/local/ or /var/lib/mysql/), the installer must register these in /etc/fstab. The root= parameter passed to the kernel by the boot loader may be omitted if the root partition is the first one on the disk of its type. If the root partition is not the first one on the disk, the root= parameter must be passed to the kernel by the boot loader. An installer that mounts a root, /usr/, /home/, /srv/, /var/, or /var/tmp/ file system with the partition types defined as above which contains a LUKS header must call the device mapper device \u0026ldquo;root\u0026rdquo;, \u0026ldquo;usr\u0026rdquo;, \u0026ldquo;home\u0026rdquo;, \u0026ldquo;srv\u0026rdquo;, \u0026ldquo;var\u0026rdquo; or \u0026ldquo;tmp\u0026rdquo;, respectively. This is necessary to ensure that the automatic discovery will never result in different device mapper names than any static configuration by the installer, thus eliminating possible naming conflicts and ambiguities.
An operating system should automatically discover and mount the first root partition that does not have the no-auto flag set (as described above) by scanning the disk containing the currently used EFI ESP. It should automatically discover and mount the first /usr/, /home/, /srv/, /var/, /var/tmp/ and swap partitions that do not have the no-auto flag set by scanning the disk containing the discovered root partition. It should automatically discover and mount the partition containing the currently used EFI ESP to /efi/ (or /boot/ as fallback). It should automatically discover and mount the partition containing the currently used Extended Boot Loader Partition to /boot/. It should not discover or automatically mount partitions with other UUID partition types, or partitions located on other disks, or partitions with the no-auto flag set. User configuration shall always override automatic discovery and mounting. If a root, /usr/, /home/, /srv/, /boot/, /var/, /var/tmp/, /efi/, /boot/ or swap partition is listed in /etc/fstab or with root= on the kernel command line, it must take precedence over automatically discovered partitions. If a /home/, /usr/, /srv/, /boot/, /var/, /var/tmp/, /efi/ or /boot/ directory is found to be populated already in the root partition, the automatic discovery must not mount any discovered file system over it. Optionally, in case of the root, /usr/ and their Verity partitions instead of strictly mounting the first suitable partition an OS might choose to mount the partition whose label compares the highest according to strverscmp() or similar logic, in order to implement a simple partition-based A/B versioning scheme. The precise rules are left for the implementation to decide, but when in doubt earlier partitions (by their index) should always win over later partitions if the label comparison is inconclusive.
A container manager should automatically discover and mount the root, /usr/, /home/, /srv/, /var/, /var/tmp/ partitions inside a container disk image. It may choose to mount any discovered ESP and/or XBOOTLDR partition to /efi/ or /boot/. It should ignore any swap should they be included in a container disk image.
If a btrfs file system is automatically discovered and mounted by the operating system/container manager it will be mounted with its default subvolume. The installer should make sure to set the default subvolume correctly using \u0026ldquo;btrfs subvolume set-default\u0026rdquo;.
Sharing of File Systems between Installations # If two Linux-based operating systems are installed on the same disk, the scheme above suggests that they may share the swap, /home/, /srv/, /var/tmp/, ESP, XBOOTLDR. However, they should each have their own root, /usr/ and /var/ partition.
Frequently Asked Questions # Why are you taking my /etc/fstab away? # We are not. /etc/fstab always overrides automatic discovery and is indeed mentioned in the specifications. We are simply trying to make the boot and installation processes of Linux a bit more robust and self-descriptive.
Why did you only define the root partition for these listed architectures? # Please submit a patch that adds appropriate partition type UUIDs for the architecture of your choice should they be missing so far. The only reason they aren\u0026rsquo;t defined yet is that nobody submitted them yet.
Why define distinct root partition UUIDs for the various architectures? # This allows disk images that may be booted on multiple architectures to use discovery of the appropriate root partition on each architecture.
Doesn\u0026rsquo;t this break multi-boot scenarios? # No, it doesn\u0026rsquo;t. The specification says that installers may not stop creating /etc/fstab or stop including root= on the kernel command line, unless the used partitions are the first ones of their type on the disk. Additionally, /etc/fstab and root= both override automatic discovery. Multi-boot is hence well supported, since it doesn\u0026rsquo;t change anything for anything but the first installation.
That all said, it\u0026rsquo;s not expected that generic installers generally stop setting root= and creating /etc/fstab anyway. The option to drop these configuration bits is primarily something for appliance-like devices. However, generic installers should still set the right GPT partition types for the partitions they create so that container managers, partition tools and administrators can benefit. Phrased differently, this specification introduces A) the recommendation to use the newly defined partition types to tag things properly and B) the option to then drop root= and /etc/fstab. While we advertise A) to all installers, we only propose B) for simpler, appliance-like installations.
What partitioning tools will create a DPS-compliant partition table? # As of util-linux 2.25.2, the fdisk tool provides type codes to create the root, home, and swap partitions that the DPS expects. By default, fdisk will create an old-style MBR, not a GPT, so typing l to list partition types will not show the choices to let you set the correct UUID. Make sure to first create an empty GPT, then type l in order for the DPS-compliant type codes to be available.
The gdisk tool (from version 1.0.5 onward) and its variants (sgdisk, cgdisk) also support creation of partitions with a matching type code.
Links # Boot Loader Specification
Boot Loader Interface
Safely Building Images
systemd-boot(7)
bootctl(1)
systemd-gpt-auto-generator(8)
`}),e.add({id:5,href:"/specifications/specs/elf_dlopen_metadata/",title:"Dlopen Metadata for ELF Files",section:"Specs",content:" dlopen() Metadata for ELF Files # Version Changes 1.0 Initial Release Target Audience # The target audience for this specification is:\nDevelopers working on userspace subsystems that create ELF binaries that dynamically load libraries Developers working on userspace subsystems that package ELF binaries that dynamically load libraries Motivation # Using dlopen() to load optional dependencies brings several advantages: programs can gracefully downgrade a feature when a library is not available, and the shared library is only loaded into the process (and its ELF constructors are run) only when the requested feature is actually used. But it also has some drawbacks, and the main one is that it is harder to track a program\u0026rsquo;s dependencies, since unlike build-time dynamic linking there will not be a mention in the ELF metadata. This specification aims to solve this problem by providing a standardized specification for a custom ELF note that can be used to list dlopen() dependencies.\nImplementation # This document will attempt to define a common metadata format specification, so that multiple implementers might use it when coding upstream software, and packagers might use it when building packages and setting dependencies.\nThe metadata will be embedded in a series of new, 4-byte-aligned, allocated, 0-padded, read-only ELF header sections, in a JSON array containing name-value objects, either one ELF note per dependency or as a single note listing multiple dependencies in the top-level array. Implementers working on parsing ELF files should not assume a specific list of names, but parse anything that is included in the section, and should look for the note using the note type. Implementers working on build tools should strive to use the same names, for consistency. The most common will be listed here.\nSection header SECTION: `.note.dlopen` note type: `0x407c0c0a` Owner: `FDO` (FreeDesktop.org) Value: an array of JSON objects encoded as a zero-terminated UTF-8 string JSON payload [ { \u0026#34;soname\u0026#34;: [\u0026#34;libfoo.so.1\u0026#34;], \u0026#34;feature\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Enables the foo feature\u0026#34;, \u0026#34;priority\u0026#34;: \u0026#34;recommended\u0026#34; } ] The format is a single JSON array containing objects, encoded as a zero-terminated UTF-8 string. Each key in each object shall be unique as per recommendations of RFC8259. Strings shall not contain any control characters or use \\uXXX escaping.\nReference implementations of packaging tools for .deb and .rpm are available, and provide macros/helpers to parse the note when building packages and adding dependencies.\nWell-known keys # The metadata format is intentionally extensible, so that upstreams and later revisions of this spec can add their own information. The \u0026lsquo;soname\u0026rsquo; array is required, with at least one element, everything else is optional. If alternative soname versions for the same library are supported at the same time, an array can be used, listing the most preferred first, and parsers are expected to select only the first one that is available on the system, as it is a mechanism to specify alternatives. If the priority field is used, it must follow the specification and use one of the values specified in the table. If it is not specified, a parser should assume \u0026lsquo;recommended\u0026rsquo; if a priority is needed. If the feature field is used, it will identify an individual feature, and multiple entries using the same feature denote functionality that requires all of the libraries they specify in order to be enabled.\nKey name Key type Mandatory Key description Example value soname array of strings yes The library names loaded by dlopen() [ \u0026ldquo;libfoo.so.1\u0026rdquo;, \u0026ldquo;libfoo.so.0\u0026rdquo; ] feature string no A keyword identifying the feature that the library contributes to enable \u0026ldquo;foo\u0026rdquo; description string no A human-readable text string describing the feature \u0026ldquo;Enables the foo feature\u0026rdquo; priority string no The priority of the feature, one of: required, recommended, suggested \u0026ldquo;recommended\u0026rdquo; Priority definition # Priority Semantics required Core functionality needs the dependency, the binary will not work if it cannot be found recommended Important functionality needs the dependency, the binary will work but in most cases the dependency should be provided suggested Secondary functionality needs the dependency, the binary will work and the dependency is only needed for full-featured installations Displaying dlopen() notes # The raw ELF section can be extracted using objdump:\n$ objdump -j .note.dlopen -s /usr/lib64/systemd/libsystemd-shared-257.so /usr/lib64/systemd/libsystemd-shared-257.so: file format elf64-x86-64 Contents of section .note.dlopen: 0334 04000000 8e000000 0a0c7c40 46444f00 ..........|@FDO. 0344 5b7b2266 65617475 7265223a 22627066 [{\u0026#34;feature\u0026#34;:\u0026#34;bpf 0354 222c2264 65736372 69707469 6f6e223a \u0026#34;,\u0026#34;description\u0026#34;: 0364 22537570 706f7274 20666972 6577616c \u0026#34;Support firewal 0374 6c696e67 20616e64 2073616e 64626f78 ling and sandbox 0384 696e6720 77697468 20425046 222c2270 ing with BPF\u0026#34;,\u0026#34;p 0394 72696f72 69747922 3a227375 67676573 riority\u0026#34;:\u0026#34;sugges 03a4 74656422 2c22736f 6e616d65 223a5b22 ted\u0026#34;,\u0026#34;soname\u0026#34;:[\u0026#34; 03b4 6c696262 70662e73 6f2e3122 2c226c69 libbpf.so.1\u0026#34;,\u0026#34;li 03c4 62627066 2e736f2e 30225d7d 5d000000 bbpf.so.0\u0026#34;]}]... 03d4 04000000 9e000000 0a0c7c40 46444f00 ..........|@FDO. ... It is more convenient to use a higher level tool:\n$ dlopen-notes /usr/lib64/systemd/libsystemd-shared-257.so # /usr/lib64/systemd/libsystemd-shared-257.so [ { \u0026#34;feature\u0026#34;: \u0026#34;archive\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Support for decompressing archive files\u0026#34;, \u0026#34;priority\u0026#34;: \u0026#34;suggested\u0026#34;, \u0026#34;soname\u0026#34;: [ \u0026#34;libarchive.so.13\u0026#34; ] }, { \u0026#34;feature\u0026#34;: \u0026#34;bpf\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Support firewalling and sandboxing with BPF\u0026#34;, \u0026#34;priority\u0026#34;: \u0026#34;suggested\u0026#34;, \u0026#34;soname\u0026#34;: [ \u0026#34;libbpf.so.1\u0026#34;, \u0026#34;libbpf.so.0\u0026#34; ] }, ... dlopen-notes can display the notes grouped in a few different ways. One option is to filter the libraries by \u0026ldquo;feature\u0026rdquo;. This answers the question \u0026ldquo;what libraries are needed to provide specified features\u0026rdquo;:\n$ dlopen-notes.py -f archive,bpf /usr/lib64/systemd/libsystemd-shared-257.so # grouped by feature { \u0026#34;bpf\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Support firewalling and sandboxing with BPF\u0026#34;, \u0026#34;sonames\u0026#34;: { \u0026#34;libbpf.so.1\u0026#34;: \u0026#34;suggested\u0026#34;, \u0026#34;libbpf.so.0\u0026#34;: \u0026#34;suggested\u0026#34; } }, \u0026#34;archive\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Support for decompressing archive files\u0026#34;, \u0026#34;sonames\u0026#34;: { \u0026#34;libarchive.so.13\u0026#34;: \u0026#34;suggested\u0026#34; } } } The format that is used when building `deb` packages: ```console $ dlopen-notes -s /usr/lib64/systemd/libsystemd-shared-257.so libarchive.so.13 suggested libbpf.so.0 suggested libbpf.so.1 suggested ... The format that can be useful when building rpm packages:\n$ dlopen-notes --rpm-requires archive --rpm-recommends bpf /usr/lib64/systemd/libsystemd-shared-257.so Requires: libarchive.so.13()(64bit) Recommends: libbpf.so.1()(64bit) "}),e.add({id:6,href:"/specifications/specs/extension_image/",title:"Extension Images",section:"Specs",content:` Extension Images # Version Changes 1.0 Initial Release Extension Images are DDIs ( Discoverable Disk Images) that are built to extend a base system via an overlay. A base system or a root DDI can be extended by several extension DDIs via, usually, a read-only OverlayFS. The defining characteristic of an Extension Image is that it contains an extension-release.\u0026lt;IMAGE\u0026gt; file that identifies itself and the base system or root DDI it applies to, and must not contain an os-release file.
Ordering # The default order in which extensions are applied is based on lexicographic sorting as defined in the Version Format Specification, with images sorting as older being placed lower in the overlay. Implementations may allow a different order to be explicitly specified instead.
Image Format # Extensions are DDIs ( Discoverable Disk Images), so the file format will not be redefined here.
Extension Types # There are two types of extension images, sysext (System Extension) and confext (Configuration Extension). They are differentiated by the directory hierarchies they contain.
sysext (System Extension) # sysext images extend /usr/ (OS vendor tree) and/or /opt/ (third-party vendor tree). They must contain a /usr/lib/extension-release.d/extension-release.\u0026lt;IMAGE\u0026gt; file to identify them.
confext (Configuration Extension) # confext images extend /etc. They must contain a /etc/extension-release.d/extension-release.\u0026lt;IMAGE\u0026gt; file to identify them.
Image Content Extension Images should be additive, and not override content present in the base image or other DDIs. However, there currently is no safe and efficient way to detect collisions and to enforce content uniqueness across the stack of images. In a future version of this specification options for enforcing uniqueness may be provided. Base Directory Immutability / Mutability # By default, applying (\u0026ldquo;merging\u0026rdquo;) an Extension Image on a mutable filesystem renders the underlying base directory (/etc/, /usr/, /opt/) immutable. By implication, merging a confext on a mutable filesystem will result in /etc/ becoming read-only, and merging a sysext might render /usr/ and/or /opt/ read-only, depending on the sysext\u0026rsquo;s contents.
This affects base directories actually contained in extensions merged to a root filesystem: for instance, if a sysext extends /usr/ but not /opt/, /opt/ will remain mutable if it\u0026rsquo;s on a mutable filesystem. However, immutability affects the full base directory. Merging an extension on a mutable filesystem that ships a single custom path e.g. below /etc/appconfig-extra/some/sub/path/ will still render the entirety of /etc/ immutable. The base directory or directories remain immutable for as long as extensions are merged. Mutability, if present before the merge, is regained only after all extensions overlaying a base directory have been un-merged.
Optional Mutability # While overlaid base directories are immutable by default, implementations may provide options for mutability. Retaining mutability may for instance be useful for compatibility with general purpose applications, enabling users to operate a \u0026ldquo;mixed mode\u0026rdquo; with both system and configuration extensions and traditional applications. Mixed mode may also be integrated by distributions to facilitate a smooth transition from traditional package management to a purely image-based composition of the root file system. Lastly, mutability mode may be used on an originally immutable filesystem to allow and to capture temporary changes.
Extension Overlay [Im]Mutability Modes # System and configuration extensions may operate in one of three modes.
Immutable mode - The overlaid base directory is immutable. This is the default. Mutable mode - Writes are directed to an upperdir specified by the user or operator (see \u0026ldquo;Mutability Mode Configuration\u0026rdquo; below). This upperdir will contain all changes made to the overlaid base directory. Upperdir may be specified to be the base directory: may be used to retain mutability of the base directory after extensions have been merged. Alternatively, upperdir may be an entirely separate directory: modifications will be captured but the base directory will remain unchanged, retaining its state from before the extension was merged. Ephemeral Mode - Similar to mutable mode (2.) above but writes are only stored temporarily while extensions are merged, and discarded as soon as extensions are un-merged. Location of temporary storage is implementation-specific. Useful for e.g. development and for one-shot validation operations. Mutability Mode Configuration # Immutable mode is the default. If none of the configurations outlined below were specified then extension overlays operate in immutable mode and base directories are read-only. Implementation of any of the below mutable configurations is optional. If mutable modes are supported by an implementation, configuration option 1. below must be supported for compatibility across implementations.
Mutability modes may be configured in the following ways:
By creating qualified paths or soft-links below /var/lib/extensions.mutable/. See \u0026ldquo;Qualified Paths Definition\u0026rdquo; below for details. This is the most portable option across different implementations. If an implementation supports base directory mutability then this mode must be supported. By setting a respective option in an implementation\u0026rsquo;s configuration file. This option is implementation-specific. Implementations may choose to support a single option, multiple options for system and configuration extensions, and/or multiple options per base directory. Using this option should selectively override any qualified path definitions from 1. By passing a command line parameter upon extension merge or refresh. This option is implementation-specific. Implementations may choose to support a single option and/or multiple options per base directory. Using this option should selectively override any configurations from 1. and 2. Qualified Paths Definition # Mutability Mode 1 enables mutability by creating paths or soft-links below /var/lib/extensions.mutable/. Qualified paths are:
/var/lib/extensions.mutable/etc/ - directory or soft-link to a directory to store writes to /etc/. This is for configuration extensions. /var/lib/extensions.mutable/usr/ - directory or soft-link to a directory to store writes to /usr/. This is for system extensions. /var/lib/extensions.mutable/opt/ - directory or soft-link to a directory to store writes to /opt/. This is for system extensions. Each base directory is treated separately. The existence and the type of each qualified path determines the mutability mode used. The following mutability modes are supported:
Path does not exist - immutable mode. Path is a directory, subvolume, or mount point - the path at /var/lib/extensions.mutable/\u0026lt;basedir\u0026gt;/ is used to store writes to /\u0026lt;basedir\u0026gt;/. A tmpfs mount at the qualified path may be used for a custom ephemeral mode. In this case, clean-up of the tmpfs is left to the user and/or is implementation-specific. Path is a soft link - the soft link is followed and writes are stored at the link\u0026rsquo;s destination. If the destination is the base directory - i.e. /var/lib/extensions.mutable/\u0026lt;basedir\u0026gt;/ points to /\u0026lt;basedir\u0026gt;/ - then the stacking order changes and \u0026lt;basedir\u0026gt; becomes upperdir. Writes are directed to the base directory and files and paths present in the base directory override files and paths in extensions if present. The soft link may point to a tmpfs destination for custom ephemeral mode. In this case, clean-up of the tmpfs is left to the user and/or is implementation-specific. If the destination does not exist, immutable mode is used. File Suffix # Since extensions images are DDIs, they should carry the .raw suffix. In order to make discerning system extensions and configuration extensions easy it is recommended to use the .sysext.raw suffix for system extensions, and .confext.raw for configuration extensions.
Identification # An Extension Image must contain a extension-release.\u0026lt;IMAGE\u0026gt; file, where \u0026lt;IMAGE\u0026gt; must either match the name of the sysext minus the suffix, or alternatively extension-release.\u0026lt;IMAGE\u0026gt; must be tagged with a user.extension-release.strict xattr set to the string \u0026quot;0\u0026quot; in order to be valid. This is to make it obvious to users that a sysext is used for its purpose. The format of extension-release.\u0026lt;IMAGE\u0026gt; is the same as the os-release file, and it is a newline-separated list of environment-like shell-compatible variable assignments. New fields SYSEXT_LEVEL= and CONFEXT_LEVEL= have been introduced to allow an implementation to match a sysext or a confext with the base image upon which it is layered: if the field is present, it must match between the layers or the Extension Image must be ignored, while if it is not present, but VERSION_ID= is, then the latter must match instead. In addition, the ID= field must be present and match the base image\u0026rsquo;s, or be set to the special value _any, in case the Extension Image can be used on any Linux distribution.
Fields in extension-release — Matching with the base system or DDI # The following fields are used in order to match with the base system or DDI.
SYSEXT_LEVEL= CONFEXT_LEVEL= # A lower-case string (mostly numeric, no spaces or other characters outside of 0–9, a–z, \u0026ldquo;.\u0026rdquo;, \u0026ldquo;_\u0026rdquo; and \u0026ldquo;-\u0026rdquo;) identifying the operating system extensions support level, to indicate which extension images are supported.
Examples: \u0026quot;SYSEXT_LEVEL=2\u0026quot;, \u0026quot;CONFEXT_LEVEL=15.14\u0026quot;.
If not present, and if VERSION_ID= is present instead, then this will be checked instead.
VERSION_ID=, ID=, ARCHITECTURE= # VERSION_ID= and ID= are used to match the Extension Image with the root DDI, and ARCHITECTURE= is used to match with the host\u0026rsquo;s CPU architecture, as defined in the os-release specification. ID= and ARCHITECTURE= also support specifying the _any wildcard, which allows the matching mechanism to be bypassed.
Fields in extension-release — Identifying the Extension Image # The identification fields defined in the os-release specification can be used to also identify the sysext itself, by prefixing them with SYSEXT_. For example, SYSEXT_ID=myext SYSEXT_VERSION_ID=0.1 denotes a \u0026lsquo;myext\u0026rsquo; sysext of version \u0026lsquo;0.1\u0026rsquo;. There are also extension-specific fields that do not apply to \u0026lsquo;os-release\u0026rsquo;, SYSEXT_SCOPE=, CONFEXT_SCOPE= and ARCHITECTURE=.
SYSEXT_SCOPE=, CONFEXT_SCOPE= # Takes a space-separated list of one or more of the strings \u0026quot;system\u0026quot;, \u0026quot;initrd\u0026quot; and \u0026quot;portable\u0026quot;. This field is optional and indicates what environments the system extension is applicable to: i.e. to regular systems, to initrds, or to portable service images. If unspecified, \u0026quot;SYSEXT_SCOPE=system portable\u0026quot; is implied, i.e. any system extension without this field is applicable to regular systems and to portable service environments, but not to initrd environments.
ARCHITECTURE= # A string that specifies which CPU architecture the userspace binaries require. This field is optional and should only be used when just single architecture is supported. It may provide redundant information when used in a GPT partition with a GUID type that already encodes the architecture. If this is not the case, the architecture should be specified in e.g., an extension image, to prevent an incompatible host from loading it.
Valid values:
Architecture x86 x86-64 alpha arc arc-be arm arm-be arm64 arm64-be cris ia64 loongarch64 m68k mips mips-le mips64 mips64-le parisc parisc64 ppc ppc-le ppc64 ppc64-le riscv32 riscv64 s390 s390x sh sh64 sparc64 sparc tilegx native any `}),e.add({id:7,href:"/specifications/specs/file_hierarchy_for_the_verification_of_os_artifacts/",title:"File Hierarchy for the Verification of OS Artifacts (VOA)",section:"Specs",content:` File Hierarchy for the Verification of OS Artifacts (VOA) # Version Changes 0.1 Work in progress Motivation # Cryptographic validation of artifacts with the help of digital signatures is a use-case of most Linux distributions. Different cryptographic technologies exist and can be used for this purpose. Currently, OpenPGP and X.509 are widely adopted.
As of this writing, no technology-agnostic, standardized location for the distribution of cryptograpic material that serves as verifier for digital signatures exists. This leaves consumers to either do guesswork, or rely on proprietary, stateful or technology-specific keystore formats and per-application locations.
The File Hierarchy for the Verification of OS Artifacts (VOA) defines a generic approach for storage and retrieval of signature verifiers, supporting a wide range of cryptographic technologies.
VOA aims to cover all verification needs around OS artifacts.
Unlike e.g. Mozilla\u0026rsquo;s Network Security Services ( NSS), which concerns itself with secure network communication, including a curated set of X.509 CA certificates (e.g. often provided on Linux distributions via /etc/pki/ or /etc/ca-certificates/), VOA focusses on the verification of artifacts with support for a diverse set of cryptographic technologies.
Terminology # This text uses the generic term \u0026ldquo;signature verifier\u0026rdquo; for cryptographic objects that are used to verify signatures. In practice, those may be for example X.509 or OpenPGP certificates (the latter are also referred to as public keys).
All technologies for validation of signatures rely on public key material. However, some systems use bare public key material, while others combine key material with additional metadata, forming composite objects that may e.g. also make identity assertions.
This text uses the term signature verifier to refer to two types of verifiers:
artifact verifiers, which are used for the validation of signatures on artifacts, trust anchors, which are used to ascertain the authenticity of artifact verifiers. Revocation of verifiers # Some technologies have a concept of invalidation of verifiers, using a mechanism that signals to users that a verifier should not be relied on anymore (e.g. because the private key material has been compromised).
Classification of signature verification models # For the use in the VOA structure, digital signature technologies may be regarded outside of their usual context. To simplify and allow a unified view on these technologies, VOA classifies these three distinct families:
Point to Point # (e.g. SSH, minisign, signify)
Keys are \u0026ldquo;atomic\u0026rdquo; and don\u0026rsquo;t have formal relationships with each other: A key issues a number of signatures, which can be verified.
These systems use \u0026ldquo;set-style trust\u0026rdquo;: Users choose to rely on some set of keys/verifiers, and are willing to accept signatures made with those.
This model doesn\u0026rsquo;t require or support the use of trust anchors in VOA. In this model, the set of artifact verifiers is considered implicitly trusted and used directly for the verification of artifacts.
Decentralized delegation # (e.g. OpenPGP)
In these systems, key material and certifications (as used in the OpenPGP \u0026ldquo;Web of Trust\u0026rdquo;) are decentralized, forming a non-hierarchical network. Users need to specify the trust anchors they want to rely on, within their context.
Two approaches are possible for applications using VOA:
Directly rely on artifact verifiers for a purpose. Rely on trust anchors which delegate to one or more artifact verifiers. Anchors must be explicitly defined in the relevant \u0026ldquo;trust-anchor\u0026rdquo; VOA directory (see purpose). Hierarchical delegation # (e.g. X.509, SSH+CA)
Other systems have an inherent assumption of hierarchical delegation, formalized by cryptographic certifications. In such systems, globally or locally accepted trust anchors are used as starting points in signature validation. Certificates and the delegation relations between them in practice often form a tree structure. Such hierarchical key structures are often referred to as public key infrastructure (PKI). In many X.509 ecosystems a shared set of trust anchors exist, that all actors agree upon (e.g. Web PKI).
This model requires explicitly defined trust anchors in VOA, that delegate to artifact verifiers.
Application of signature verification models # Although the classification of signature verification models categorizes various technologies for the verification of digital signatures, the reality is more diverse. In practice VOA only distinguishes between direct verifications and those relying on some form of delegation. The details of delegation are technology specific and described in their respective technology sections.
Typical distribution format of verifers / short vs. long-lived keys # VOA\u0026rsquo;s goal is to provide a uniform representation of verifiers, to the degree that this is possible with differing technologies. To achieve this, verifiers are stored in a central file hierarchy that can be used with different technologies.
Some concerns may be handled differently in supported technologies:
The separation between trust anchors and artifact verifiers may not be reasonable to model in separated directories, because the native representation of a given technology is to store both in a shared file, as a type of \u0026ldquo;certificate chain\u0026rdquo;. By default, VOA suggests that each verifier is stored in an individual file (that ideally reflects a unique identifier of that verifier in its filename). However, in some technologies, separating verifiers into individual files may be uncommon or unreasonable. In these technologies, bundles of verifiers may be stored in a shared file (this can apply equally to artifact verifiers and trust anchors). As an edge case, in some technologies, artifact verifiers may be extremely short lived, so it may not be reasonable to store them in VOA. In these cases, only a set of trust anchors may be stored in VOA, while the artifact verifiers are distributed with the signed artifacts. File Hierarchy # The File Hierarchy for the Verification of OS Artifacts (VOA) is maintained as a directory structure on a system. It contains cryptographic public-key material for one or more technologies.
The VOA hierarchy organizes signature verifiers by os, purpose, context and technology, and stores them in a directory structure of the form \$os/\$purpose/\$context/\$technology/.
Vendors provide a set of signature verifier files for their OS, in the VOA hierarchy format.
Users of a VOA hierarchy (such as package installation software) can pick the relevant set of signature verifiers for the verification of a specific artifact based on their location in the hierarchy.
VOA does not concern itself with the retrieval of additional signature verifiers or the update of existing ones in the file hierarchy.
Load paths # VOA defines a list of load paths with descending priority for system mode and user mode.
Signature verifiers are retrieved from hierarchies in these directories to validate artifacts based on specific load logic. This is referred to as verifier lookup.
The existence of multiple load paths allows system administrators and users to define custom sets of signature verifiers for their system and applications.
System mode # The priority of load paths in system mode follows the definition of [\u0026ldquo;Storage Directories and Overrides\u0026rdquo; in the Configuration Files Specification], which is also reflected in the following list of paths:
/etc/voa/ /run/voa/ /usr/local/share/voa/ /usr/share/voa/ User mode # The priority of load paths in user mode mirrors that of the system mode. Refer to the XDG Base Directory Specification for details on default values.
\$XDG_CONFIG_HOME/voa/ the ./voa/ directory in each directory defined in \$XDG_CONFIG_DIRS \$XDG_RUNTIME_DIR/voa/ \$XDG_DATA_HOME/voa/ the ./voa/ directory in each directory defined in \$XDG_DATA_DIRS Symlinking # Load paths are constrained to self-contained locations on a host as they provide vital data for the integrity and verification of all components on a system. However, relative symlinks can be used in the VOA hierarchy to point to files or directories below the same load path or one of the load paths in descending priority.
As an example, symlinks to files below the same load path or to another load path with lower priority may be used to deduplicate the use of a single signature verifier for multiple use-cases. As another example, using symlinks allows to automatically keep signature verifiers in sync with canonical upstream data.
VOA implementations must not consider symlinks under the following conditions and raise a warning for them instead:
the symlink is for a file or directory in an ephemeral load path (i.e. /run/voa/ and \$XDG_RUNTIME_DIR/voa/), the symlink is for a file or directory outside of the specified load paths, the symlink is broken (a.k.a. \u0026ldquo;dangling\u0026rdquo;), the file name of the symlink (also those of intermediate symlinks in the case of a symlink chain) does not match that of the target, or the file type of the source and target of the fully resolved symlink do not match (e.g. a verifier file points to a directory, or a directory to a verifier file). Masking # Individual signature verifiers may be masked using a symlink to /dev/null, independent of technology. This constitutes the only allowed exception to the rule of not symlinking to files or directories external to the load paths. These symlinks are only expected to be used in writable load paths (that is, only below /etc/voa/ or /run/voa/ when in system mode, or below \$XDG_CONFIG_HOME/voa/ or \$XDG_RUNTIME_DIR/voa/ when in user mode). A signature verifier that is masked is considered invalid in all load paths independent of technology and load logic.
Masking signature verifiers may be desirable in situations where a verifier is considered compromised, but a revocation for it can not be provided to users in time. VOA offers this mechanism as an alternative to revocation.
Masking is explicitly designed to be used on individual signature verifiers. The masking (of parts) of the directory structures that contain them on the other hand does not yield meaningful or intelligible results for end-users and would be very complex to reason about. VOA implementations must not consider masking symlinks for directories and should raise a warning if such symlinks are encountered.
Load logic # Load logic depends on the technology in use. It is the mechanism by which relevant verifier information from all load paths is retrieved, while considering the os, purpose, context and technology request of a calling application.
For some technologies, the first suitable signature verifier found in the list of load paths is used, effectively overriding files with the same name in directories lower in the list.
However, in other technologies, more complex merging logic may apply, that effectively combines information from different representations of one verifier.
Additionally, the concept of masking applies for all technologies.
Overriding # In technologies that use overriding, verifier files shadow other variants of the same verifier based on filename equality.
For example, /etc/voa/fedora/packages/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub overrides /usr/share/voa/fedora/package/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub.
Overriding depends on file name equality and directory structure.
For example, /etc/voa/fedora/packages/default/ssh/7d865e959b2466918c9863afca942d0fb89d7c9ac0c99bafc3749504ded97730.pub does not override /usr/share/voa/fedora/package/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub, but instead adds an additional signature verifier.
Great care has to be taken to ensure the naming scheme has the desired overriding behavior (e.g. to make sure that a revoked version of an SSH public key overrides a non-revoked version of the same SSH public key found in a different load path).
Merging # Some technologies use a business logic that \u0026ldquo;merges\u0026rdquo; different versions of the same signature verifier (instead of applying overriding semantics). The purpose is to use the latest available information about each verifier, combining the information from all sources.
When merging, information about a verifier found anywhere in the current verifier lookup must be applied for all uses of a verifier (e.g. for revocation status).
Wherever it is applicable and feasible, VOA technology backend implementations should implement \u0026ldquo;merging\u0026rdquo; to obtain a unified view of the latest information for each verifier.
For example, if a verifier has been revoked, but only one of two copies of that verifier in VOA reflects this revocation, \u0026ldquo;merging\u0026rdquo; the two leads to stable visibility of the revocation status. Summarized, in technologies that implement merging, load path priority is not relevant (e.g. a non-revoked version in /etc/voa/ of the same verifier never overrides the revoked version in /usr/share/voa/). The \u0026ldquo;latest normalized view\u0026rdquo; of a verifier is not impacted by load path priority.
Future compatibility # No changes to the overall VOA structure are anticipated, which is why versioning is not encoded in the directory structure. However, if it turns out that a breaking change to the VOA specification is necessary a separate directory structure (e.g. /usr/share/voa2/) can be specified.
Independently, breaking changes of the VOA format within individual technologies may occur. In this case, versioned variants of the technology in question are added (e.g. openpgp:2). The : delimiter is chosen to signify VOA-specific versioning. This differentiates clearly between versions of the technology itself, as specified upstream (e.g. OpenPGPv4, OpenPGPv6) and how these technologies are used in the context of VOA.
Identifiers # Signature verifiers are located in directory structures described by the file hierarchy. Each of the following identifiers represents a subdirectory layer in that hierarchy.
OS # The os identifier is used to uniquely identify an Operating System (OS).
The identifier relies on data provided by the ubiquitous os-release. The following keywords are understood and their value format follows that established by os-release (i.e. no spaces and no characters outside of 0–9, a–z, \u0026quot;.\u0026quot;, \u0026quot;_\u0026quot;, and \u0026quot;-\u0026quot; are allowed):
ID: name of OS (e.g. arch or debian) VERSION_ID: the version of the OS (e.g. 1.0.0 or 24.12) VARIANT_ID: the variant of the OS (e.g. server or workstation) IMAGE_ID: the image of an OS (e.g. cashier-system) IMAGE_VERSION: version of the image (e.g. 1.0.0 or 24.12) The values for these parts must be provided, in the above order, as a colon-separated string that defines a specific os identifier (e.g. debian:12:server:company-x:25.01). At least the ID part must be set, an empty os identifier is invalid. Trailing colons must be omitted for all parts that are unset (e.g. arch instead of arch::::).
The os identifier may be extended with further parts in an updated specification. Users encountering an os identifier with more than 5 parts should ignore these directories.
Users of VOA (e.g. a Linux distribution creator) are free to store and retrieve verifiers in more or less specific os identifiers, at their own discretion. VOA supports both generic identifiers (e.g. arch), and very specific identifiers (e.g. fedora:41:workstation:cashier-system:1.0.0).
VOA is not flexible regarding os strings: When an application looks up verifiers for e.g. fedora:41:workstation, then no verifiers from alternate os strings are implicitly considered (e.g. from the more general location fedora:41).
However, VOA libraries may offer an API that allows applications to use a list of os strings (e.g. a list of both fedora:41:workstation and fedora:41). Such a call will use the combination of all verifiers found in both directory hierarchies. Applications that use VOA (via a VOA library) can therefore opt to pass a list of os strings, if verifiers are known to be spread over different os directories. VOA users can omit specific parts, e.g. IMAGE_ID and IMAGE_VERSION, if they know that these parts are not used in the VOA hierarchy for their os.
Purpose # A purpose combines a role and a usage mode:
A role acts as a trust domain (e.g. the \u0026ldquo;package\u0026rdquo; role is used for signatures for package verification). There are two modes in which signature verifiers can be stored in VOA: Verifiers used for direct artifact verification Verifiers that serve as trust anchors A role and a mode in combination form a purpose.
Trust anchor verifiers are always used to ascertain the validity of the associated artifact verifiers (e.g. trust anchor verifiers for the \u0026ldquo;package\u0026rdquo; role are used to validate the artifact verifiers for the \u0026ldquo;package\u0026rdquo; role).
To use signature verifiers in more than one mode symlinking may be used.
Directory naming # Purpose directories for direct artifact verifiers are named \$role (e.g. package), while trust anchors are stored below directories named trust-anchor-\$role (e.g. trust-anchor-package).
Note that trust anchor directory names always start with a \u0026ldquo;trust-anchor-\u0026rdquo; fragment.
Either two or one purpose directories may exist per role:
One directory which contains artifact verifiers (e.g. package), and a second directory which contains the corresponding trust anchors (e.g. trust-anchor-package). Just one directory which contains artifact verifiers (e.g. package). The purpose directory name must not contain characters outside of 0–9, a–z, \u0026quot;.\u0026quot;, \u0026quot;_\u0026quot;, and \u0026quot;-\u0026quot;. VOA implementations must not consider invalid directories and should raise a warning if such a directory is encountered.
A role\u0026rsquo;s name must not start with the string \u0026ldquo;trust-anchor-\u0026rdquo;, so that there can be no confusion with a purpose with trust anchor usage mode.
Two purpose directories: Verification relying on trust anchors # For example, verifiers for the \u0026ldquo;package\u0026rdquo; role may be stored in two purpose directories:
package (\u0026quot;artifact verifiers of actors who are designated for package signing\u0026quot;), and trust-anchor-package (\u0026quot;trust anchors for artifact verifiers used for package signing\u0026quot;) In this scenario, verification based on trust anchors is performed.
One purpose directory: Direct verification # In another example, verifiers for the \u0026ldquo;image\u0026rdquo; role may be stored in only one purpose directory:
image (\u0026quot;artifact verifiers of actors who are designated for OS image signing\u0026quot;) In this scenario, only direct verification can be performed.
Roles as trust domains # Having distinct roles allows the use of separate sets of signature verifiers per role. This is useful if different actors are expected to issue signatures for each role. Thus, each role acts as a trust domain, e.g. the \u0026ldquo;package\u0026rdquo; role is used for signatures for packages, while the \u0026ldquo;image\u0026rdquo; role is used for signatures for OS images. The work on each of the roles may be performed by different teams, using different verifiers.
Standard roles # The standard roles defined by the VOA specification are:
package: Verifying signatures for packages repository-metadata: Verifying signatures for repository metadata image: Verifying signatures for OS images The corresponding purpose directories are:
package and trust-anchor-package repository-metadata and trust-anchor-repository-metadata image and trust-anchor-image The above list of standard roles can be extended by users of VOA.
For more in-depth explanation on the use of the purpose identifier, see the examples section.
Context # The context identifier allows defining specific verifiers for a particular context within an os\u0026rsquo;s purpose.
The context identifier allows modelling finer grained trust domains within a purpose. This can be necessary if different actors are responsible for signing in subsets of a purpose.
Specific examples for context are
the name of a specific software repository when certificates are used within the package purpose (e.g. core for a repository named \u0026ldquo;core\u0026rdquo;) how an OS image is used within the image purpose (e.g. installation-medium, virtual-machine) If no specific context is required, the context directory default must be used.
Analogous to the os-release data, context strings may only contain [a-z], [0-9], _, ., and -.
For more in-depth discussion on the use of the context identifier, see the examples section.
Technology # The following sections outline specifics about the supported technologies.
In VOA, technology-specific backends implement the logic for each supported technology. Different parties can implement different backends and this document outlines the approach, including the commonalities between all technology backends.
The details of verifier load logic is defined per technology to leverage the individual features and strengths of each technology, while offering semantics that are closely shared between all VOA technologies.
Currently, only the OpenPGP technology is specified in detail. Further specification work is required before implementing further technologies.
Each technology specifies file suffixes for verifiers. Note that these suffixes may overlap.
A technology directory name must not contain characters outside of 0–9, a–z, \u0026quot;.\u0026quot;, \u0026quot;_\u0026quot;, and \u0026quot;-\u0026quot;. VOA implementations must not consider invalid directories and should raise a warning if such a directory is encountered.
OpenPGP # OpenPGP is a widely adopted decentralized system for signature verification and user authentication.
This technology is named openpgp in the VOA structure.
Most Linux distributions use OpenPGP, often combined with PGPKI (a.k.a. Web of Trust (WoT)), in which chains of trust are evaluated during signature validation.
OpenPGP has a rich model of validity, both for certificates and signatures. Certificates can expire or be revoked by the key holder (via OpenPGP certificate revocation). Similarly, third-party identity certifications (as used in the PGPKI) can be revoked by their issuers (using OpenPGP signature revocation).
OpenPGP VOA backends are expected to handle validity. In particular they should take expiration and revocation into account in all layers of the VOA hierarchy, by implementing merging semantics. For example, even if a revoked version of a certificate is overlaid by an unrevoked version, the revocation must be considered.
OpenPGP VOA backends implementations must offer appropriate facilities to calculate the validity of artifact verifiers. This may include:
specifying how many trust anchors are required to have valid paths to each artifact verifier, limiting potentially accepted User IDs of artifact verifiers (e.g. by domain of the email address). In VOA, by convention, OpenPGP certificates must be stored in individual files and provided in ASCII armored form.
These files must be named by certificate fingerprint (in lowercase hex notation) with the file ending .openpgp (e.g. d8afdda07a5b6edfa7d8ccdad6d055f927843f1c.openpgp).
OpenPGP VOA backends must reject files where the certificate fingerprint of the file name does not match the actual fingerprint of the contained OpenPGP certificate\u0026rsquo;s primary key and should emit a warning if such a file is encountered.
By default, in VOA, OpenPGP certificates that act as trust anchors are considered with a trust amount of 40 at a trust depth of 1. More complex delegation setups are possible, but must be implemented using an application specific configuration mechanism.
SSH # NOTE: This technology is in draft mode. Before implementing an SSH VOA backend, this section needs to be specified further to describe dedicated semantics for key revocation lists.
SSH can be used in two distinct signature verification models:
point to point: with this model the targeted purpose only requires artifact verifiers, it does not support trust anchors hierarchical delegation: when relying on SSH CA this model expects both artifact verifiers and trust anchors In both cases the technology is referred to as ssh in the VOA structure.
The file ending .pub is used for artifact verifier files, following the default naming convention of OpenSSH\u0026rsquo;s ssh-keygen output.
File names must consist of the sha256 fingerprint of the SSH public key, encoded in lowercase hex notation (e.g. b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub). This format can for example be generated via ssh-keygen -l -f ~/.ssh/id_rsa.pub | cut -f 2 -d ' ' | cut -d ':' -f 2 | base64 -d | xxd -p -c32. SSH VOA backends must reject files where the sha256 fingerprint of the file name does not match the actual sha256 fingerprint of the contained SSH public key and should emit a warning if such a file is encountered.
SSH signatures support the concept of namespaces, which declare a specific scope in which a signature is to be created and used. In VOA, the equivalent to an SSH namespace is the combination of signature verifier purpose and context. When verifying SSH signatures with a signature verifier, their namespaces should be matched against the combination of the signature verifier\u0026rsquo;s purpose/ context (e.g. package/core ).
SSH has various concepts for revoking keys (see sshd.8#SSH_KNOWN_HOSTS_FILE_FORMAT and ssh-keygen.1#KEY_REVOCATION_LISTS).
VOA does not interpret the global revocation lists and configurations used by sshd or ssh, but expects revocation information in VOA-specific well-known locations.
Revocations must be handled with merging semantics. For example, a revocation found in any location considered in the current verifier lookup must be applied for all uses of a verifier.
X.509 # NOTE: This technology is in draft mode. Before implementing an X.509 VOA backend, this section needs to be specified further to describe dedicated semantics.
X.509 is a widely adopted hierarchical model, that is often used for signature validation.
This technology is named x509 in the VOA structure.
X.509 artifact verifier files must be used in Privacy-Enhanced Mail (PEM) format, with the file ending .pem. Analogous to the use in systemd, file names of the form *-certificate.pem must be used for X.509 certificates and *-public-key.pem for X.509 public keys.
X.509 VOA backends must implement appropriate merging semantics. In particular, revocations must be considered for all uses of a certificate in a verifier lookup, even if some copies don\u0026rsquo;t contain the revocation information. Further, an implementation must check that the extended key usage of a signature verifier is aligned with its purpose (e.g. codesigning for certain artifact verifiers and certificate authority for trust anchors).
It is strongly recommended to use signature formats that include metadata about the raw signature, in particular the signature creation time (e.g. PKCS#7/ CMS).
Minisign # NOTE: This technology is in draft mode. Before implementing a minisign VOA backend, this section needs to be specified further to describe dedicated semantics.
This technology is referred to as minisign in the VOA structure.
Minisign is a \u0026ldquo;point to point\u0026rdquo; signing technology. The targeted purpose only requires plain artifact verifiers, as there is no support for trust anchors in this technology (i.e. any verifiers in \u0026ldquo;trust-anchor-*\u0026rdquo; purpose directories must be ignored, also when the target of a symlink).
There is no concept of verifier revocation.
The file ending .pub is used for artifact verifier files, following the default naming convention of the canonical minisign output.
Signify # NOTE: This technology is in draft mode. Before implementing a signify VOA backend, this section needs to be specified further to describe dedicated semantics.
This technology is referred to as signify in the VOA structure.
Signify is a point to point signing technology. The targeted purpose only requires plain artifact verifiers, as there is no support for trust anchors in this technology (i.e. any verifiers in \u0026ldquo;trust-anchor-*\u0026rdquo; purpose directories must be ignored, also when the target of a symlink).
There is no concept of verifier revocation.
The file ending .pub is used for artifact verifier files, following the default naming convention of the canonical signify output.
Examples # The following examples provide an overview for several (hypothetical) scenarios in which VOA may be used. For more details on valid components for os identifiers refer to the documentation of os-release.
Package manager verifies package signatures, with trust anchor # In this example, we\u0026rsquo;ll consider the use case of a package management software that uses VOA to verify the signature of a package file on a custom image-based Arch Linux OS.
The package manager issues a lookup for OpenPGP signature verifiers from VOA, based on two os strings: arch:::cashier-system:1.0.0 and arch.
A VOA library will search in the load path /usr/share - in our example the only location with verifier data - and consider both the trust anchor and the artifact verifier paths. In our example, it will find the following verifier files for the arch:::cashier-system:1.0.0 os string:
/usr/share/voa/arch:::cashier-system:1.0.0/trust-anchor-package/default/openpgp/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33.openpgp /usr/share/voa/arch:::cashier-system:1.0.0/package/default/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp And additionally, the following verifier files for the arch os string:
/usr/share/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp The VOA library will also check for verifier files in the other layers, in our example, there is one additional verifier file in the /etc VOA layer:
/etc/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp Note that this verifier has the same filename as the one above, under /usr/share/voa/. This signifies that both files contain information about the same artifact verifier. If the contents of the files differ, the VOA library will calculate a merged view of both sources, consolidating all available information. In this example, the OpenPGP certificate in /usr/share/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp, while the OpenPGP certificate in /etc/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp is not. Due to merging semantics, the OpenPGP certificate is considered revoked.
The VOA library has effectively found one trust anchor verifier file, and one valid artifact verifier file. This means that package files will be verified using the one artifact verifier (/usr/share/voa/arch:::cashier-system:1.0.0/package/default/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp), which in turn is checked for validity based on the trust anchor verifier (/usr/share/voa/arch:::cashier-system:1.0.0/trust-anchor-package/default/openpgp/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33.openpgp).
Download tool verifies installation medium, without trust anchor # In this example, we\u0026rsquo;ll consider the use case of a download tool that uses VOA to verify the signature of a Fedora 41 installation medium.
The download tool issues a lookup for OpenPGP verifiers from VOA, based on a single os string: fedora:41. The tool is configured to perform validation with artifact verifiers (i.e. it specifies that it does not require the use of trust anchors).
A VOA library will search in the load path /usr/share/voa/ - in our example the only location with verifier data - and consider the basic verifier paths. In our example, it will find the following verifier file for the fedora:41 os string:
/usr/share/voa/fedora:41/image/installation-medium/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp The VOA library will also check for verifier files in the other layers, but in in this example, there are none.
The VOA library has found one artifact verifier file (/usr/share/voa/fedora:41/image/installation-medium/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp) and proceeds to use it to verify the installation medium file.
Considerations for implementers and users # Avoiding duplication of data in the directory structure # Symlinks are explicitly supported when forming VOA structures. In many cases, it will be desirable to make heavy use of symlinks, to form the appropriate directory structures while avoiding duplication of data. However, the VOA hierarchy is intended as a self-contained data structure that specifies how to authenticate signatures. Therefore, symlinks in VOA should only point to other files or directories in any of the VOA hierarchy paths. Symlinks may be relative or absolute. Symlinking files external to the VOA structure is not permitted and should be ignored while raising a warning.
The use of hardlinks in the VOA structure is discouraged to prevent confusion. However, VOA implementations are not required to check for the use of hardlinks.
Access library API considerations # As os strings are relatively complex, a VOA access library may offer convenient APIs for enumeration/searching of os directories (e.g. looking up a particular os in the set of available os strings, by searching by the ID part of the os-release information).
Constraining verifiers # A VOA library may allow applications to set constraints on successful verification.
These constraints may include scenarios such as:
an application may require that trust anchors must be present an application may mandate the set of verifiers that must be present (either as trust anchors, or as artifact verifiers) Verifier optimization # When importing verifiers, a VOA library may support normalization operations on the verifier representation. For example, OpenPGP decryption and authentication component keys may be dropped, as they are not needed in any VOA context.
Masking verifiers # The action of masking signature verifiers should be able to distinguish between persistent and runtime directories (e.g. /etc/voa/ and /run/voa/). By default, persistent locations should be preferred over runtime ones.
Threshold signing # In some scenarios users of VOA may want to rely on verification schemes that require more than one valid digital signature for a given artifact. These scenarios are explicitly not part of VOA, but may be implemented using dedicated configuration-based approaches per technology.
Retrieval of signature verifiers # By default the signature verifiers found in VOA are usually either provided by vendor updates to the operating system (e.g. in /usr/share/voa/) or are created by system administrators (e.g. in /etc/voa/).
In certain scenarios, applications may want to retrieve additional or updated signature verifiers from locations outside of the VOA hierarchy. These signature verifiers should be placed in ephemeral runtime directories (e.g. /run/voa/).
Validity of signatures # Each technology may handle validity differently. Generally, signature validity should be considered at the time of signature creation. The signature verifier must be valid at creation time. If the signature verifier has expired after signature creation, this does not impact signature validity. Only in the case of revocations, that indicate a key material compromise, all signatures by the key in question should be considered invalid, regardless of creation time.
Use of Time Stamp Authority # VOA is mainly used for the verification of data signatures. Often these signatures contain a claimed creation time.
Some technologies support the use of Time Stamp Authorities (e.g. based on the time stamp protocol) to validate the creation time claims of signatures. It is recommended to use timestamping services to validate signature creation time, where possible. Details on how to use timestamping services are currently out of scope for this specification.
Extending the purpose scheme for verifiers used for timestamping purposes may be desired and is possible. If the need arises, this specification should be extended accordingly.
`}),e.add({id:8,href:"/specifications/specs/linux_file_system_hierarchy/",title:"Linux File System Hierarchy",section:"Specs",content:` Linux File System Hierarchy # Version Changes 0.1 Work in progress Description # This page describes the layout of a modern Linux system. This hierarchy is an evolution of the historical UNIX layout, and includes concepts described in the File System Hierarchy specification and hier(7) man page, and various extensions documented in the XDG Base Directory Specification and XDG User Directories.
In some areas this document is stricter than those older documents. In particular it makes additional restrictions and recommendations to separate vendor defaults and local configuration, and also static installed files, persistent data, and ephemeral runtime files. In other areas it is simpler, with the vendor files using a single hierarchy under /usr.
This document doesn\u0026rsquo;t define the directory structure comprehensively, it only documents a skeleton of a directory tree, to be extended by additional directories lower in the hierarchy. Some directories like /var/spool/ are not covered, even though it might make sense to include them in the structure of an actually deployed OS.
Some directories are described for compatibility with current Linux distributions, but their use is not recommended. The subsections that describe those directories are marked with ⚠️.
Many of the paths described here can be queried with the systemd-path(1) tool, on systems where this tool is available.
General Structure # / # The file system root. Usually writable, but this is not required. Possibly a temporary file system (tmpfs). Not shared with other hosts (unless read-only).
/boot/ # The partition where kernels and other assets used to bring up the system are stored. On EFI systems, this is possibly the EFI System Partition (ESP), also see systemd-gpt-auto-generator(8). This directory is usually strictly local to the host, and should be considered read-only, except when a kernel or boot loader is installed or updated. This directory is only populated on systems that run on physical or emulated hardware that requires a boot loader.
/efi/ # If the EFI System Partition (ESP) is maintained separately from the boot partition described in the previous section, it is mounted here. Tools that need to operate on the ESP should look for it at this mount point first, and fall back to /boot/ — if the first location does not qualify (for example if it is not a mount point or does not have the correct file system type MSDOS_SUPER_MAGIC).
/etc/ # System-specific configuration. This directory may be read-only. Frequently, this directory is pre-populated with vendor-supplied configuration files, but applications should not make assumptions about this directory being fully populated or populated at all, and should fall back to defaults if configuration is missing, following the Configuration Files Specification.
If /opt/ is supported (see below), then the /etc/opt/ ⚠️ subdirectory is the location where third-party software installed in /opt/ may store its configuration. The same naming convention as directories under /opt/ is used for directories under /etc/opt/.
/home/ # The location for normal user\u0026rsquo;s home directories. Possibly shared with other systems, and never read-only. This directory should only be used for normal users, never for system users. This directory and possibly the directories contained within it might only become available or writable in late boot or even only after user authentication. This directory might be placed on limited-functionality network file systems, hence applications should not assume the full set of file API is available on this directory. Applications should generally not reference this directory directly, but via the per-user \$HOME environment variable, or via the home directory field of the user database.
/opt/ ⚠️ # A secondary location for third-party vendor directories. This directory is optional, as not all systems allow installing third-party software.
Each third-party vendor (i.e.: unrelated to the OS provider) may use a subdirectory, typically named after the vendor or the software, under this location. It is usually read-only, but this is not required. This directory should not be modified by the administrator, except when installing or removing third-party-supplied software.
Using /opt/ is not recommended. It is not integrated with the rest of the distribution: a package which uses /opt/ may need to install binaries or links in /usr/bin/ and other supplementary files, e.g. desktops files or manual pages, into their appropriate locations under /usr. Instead of using a subdirectory under /opt/, a third party vendor should put their directory under /usr/lib/.
/root/ # The home directory of the root user. The root user\u0026rsquo;s home directory is located outside of /home/ in order to make sure the root user may log in even without /home/ being available and mounted.
/srv/ # The place to store general server payload, managed by the administrator. No restrictions are made how this directory is organized internally. Generally writable, and possibly shared among systems. This directory might become available or writable only very late during boot.
/tmp/ # The place for small temporary files. This directory is usually mounted as a tmpfs instance, and should hence not be used for larger files. (Use /var/tmp/ for larger files.) This directory is usually flushed at boot-up. Also, files that are not accessed within a certain time may be automatically deleted.
If applications find the environment variable \$TMPDIR set, they should use the directory specified in it instead of /tmp/ (see environ(7) and IEEE Std 1003.1 for details).
Since /tmp/ is accessible to other users of the system, it is essential that files and subdirectories under this directory are only created with mkstemp(3), mkdtemp(3), and similar calls. For more details, see Using /tmp/ and /var/tmp/ Safely.
Runtime Data # /run/ # A tmpfs file system for system packages to place runtime data, socket files, and similar. This directory is flushed on boot, and generally writable for privileged programs only. Always writable.
/run/log/ # Runtime system logs. System components may place private logs in this directory. Always writable, even when /var/log/ might not be accessible yet.
/run/user/ # Contains per-user runtime directories, each usually individually mounted tmpfs instances. Always writable, flushed at each reboot and when the user logs out. User code should not reference this directory directly, but via the \$XDG_RUNTIME_DIR environment variable, as documented in the XDG Base Directory Specification.
Vendor-supplied Operating System Resources # /usr/ # Vendor-supplied operating system resources. Usually read-only, but this is not required. Possibly shared between multiple hosts. This directory should not be modified by the administrator, except when installing or removing vendor-supplied packages.
/usr/bin/ # Binaries and executables for user commands that shall appear in the \$PATH search path. It is recommended not to place binaries in this directory that are not useful for invocation from a shell (such as daemon binaries); these should be placed in a subdirectory of /usr/lib/ instead.
/usr/include/ # Programmatic APIs header files, typically used when compiling C/C++ programs. Packages may place such files either directly in /usr/include/, or in a subdirectory. Using a subdirectory is recommended if the package installs multiple files. It is also necessary if multiple versions of the same headers shall be coinstallable. The subdirectory may be named after the package or project providing it. Packages may place architecture-dependent header files and directories in a /usr/include/\u0026lt;arch-id\u0026gt;/ subdirectory, following the identifiers defined on the Multiarch Architecture Specifiers (Tuples) list.
Note that to use the headers, flags for the compiler may be required to bring the appropriate subdirectory into the search path. See man pages pc(7), pkgconf(1), gcc\u0026rsquo;s Search Path, and other compiler-specific documentation.
The corresponding library or libraries shall be placed in \$libdir, see below.
Libraries, system programs, and program assets # This section describes the directories used to store shared libraries, internal binaries or other programs that are not regularly invoked from a shell (and thus should not be placed in the directories in \$PATH), and other static files that are part of program installations.
There are two main schemes for shared libraries. On \u0026ldquo;multiarch\u0026rdquo; systems, multiple different architecture and ABI variants can be installed in parallel. Each variant uses a hierarchy of files under a directory named using the Multiarch Architecture Specifiers (Tuples) list. On \u0026ldquo;multilib\u0026rdquo; systems, a simpler scheme is used that only supports 32-bit and 64-bit variants of the same architecture.
Both schemes are widely used, and distributions typically choose one or the other. Multiarch is the recommended approach, especially for new systems.
Note that many locations described in this section are under shared ownership, with multiple different packages installing and consuming resources on equal footing without any obvious primary owner, and are subject to specifications that ensure interoperability.
/usr/lib/ # Static, private vendor data that is compatible with all architectures (though not necessarily architecture-independent). Note that this includes internal binaries or other programs that are not regularly invoked from a shell. Such binaries may be for any architecture supported by the system.
In the multilib scheme, 32-bit libraries are placed directly in this directory. In the multiarch scheme, libraries should not be placed directly in this directory, but in \$libdir (see below), instead.
/usr/lib/\u0026lt;arch-id\u0026gt;/ # Location for dynamic libraries, also called \$libdir. The architecture identifier to use is defined on the Multiarch Architecture Specifiers (Tuples) list. Those directories are used on multiarch systems.
On multilib systems, /usr/lib/ and /usr/lib64/ are used instead, and one of them is \$libdir.
This directory can be used for architecture-dependent package-specific data too.
The primary architecture of the system (\$libdir) may be queried with:
systemd-path system-library-arch /usr/libexec/ ⚠️ # A secondary location for vendor binaries or other programs that are not regularly invoked from a shell that is used by some distributions. Packages may either place such programs in a subdirectory of /usr/lib/, directly in /usr/libexec/, or in a subdirectory of /usr/libexec/ named after the package. The first option is the recommended approach. /usr/libexec/ is used by some distributions, so it is mentioned here too, but its use is not encouraged.
Binaries in /usr/libexec/ may be for any architecture supported by the system.
/usr/share/ # Architecture-independent resources of packages, such as documentation, man pages, time zone information, and fonts.
Those files are often shared between multiple packages, so the precise location and format of files stored below this directory are subject to specifications that ensure interoperability.
/usr/share/doc/ # Documentation for the operating system or system packages.
/usr/share/factory/etc/ # Repository for vendor-supplied default configuration files. This directory should be populated with pristine vendor versions of all configuration files that may be placed in /etc/. This is useful to compare the local configuration of a system with vendor defaults and to populate the local configuration with defaults.
Software should not read configuration settings directly from /usr/share/factory/. Those files will be copied to other locations if appropriate, and should only be read from there.
/usr/share/factory/var/ # Similar to /usr/share/factory/etc/, but for vendor versions of files in the variable, persistent data directory /var/. The same recommendations as for /usr/share/factory/etc/ apply here.
Persistent Variable System Data # /var/ # Persistent, variable system data. Writable during normal system operation. This directory might be pre-populated with vendor-supplied data, but applications should be able to reconstruct necessary files and directories in this subhierarchy should they be missing, as the system might start up without this directory being populated. Persistency is recommended, but optional, to support ephemeral systems. This directory might become available or writable only very late during boot. Components that are required to operate during early boot hence shall not unconditionally rely on this directory.
/var/cache/ # Persistent system cache data. System components may place non-essential data in this directory. Flushing this directory should have no effect on operation of programs, except for increased runtimes necessary to rebuild these caches.
/var/lib/ # Persistent system data. System components may place private data in this directory.
/var/log/ # Persistent system logs. System components may place private logs in this directory, though it is recommended to do most logging via the syslog(3) and sd_journal_print(3) calls.
/var/opt/ ⚠️ # If /opt/ is supported (see above), then the /var/opt/ subdirectory is the location where third-party software installed in /opt/ stores its persistent, variable data. The same naming convention as directories under /opt/ is used for directories under /var/opt/.
/var/tmp/ # The place for larger and persistent temporary files. In contrast to /tmp/, this directory is usually mounted from a persistent physical file system and can thus accept larger files. (Use /tmp/ for small ephemeral files.) This directory is generally not flushed at boot-up, but time-based cleanup of files that have not been accessed for a certain time is applied.
If applications find the environment variable \$TMPDIR set, they should use the directory specified in it instead of /var/tmp/ (see environ(7) for details).
The same security restrictions as with /tmp/ apply: mkstemp(3), mkdtemp(3), and similar calls should be used. For further details about this directory, see Using /tmp/ and /var/tmp/ Safely.
Virtual Kernel and API File Systems # /dev/ # The root directory for device nodes. Usually, this directory is mounted as a devtmpfs instance, but might be of a different type in sandboxed/containerized setups. This directory is managed jointly by the kernel and a userspace component such as systemd-udevd(8), and should not be written to by other components. A number of special purpose virtual file systems might be mounted below this directory.
/dev/shm/ # Place for POSIX shared memory segments, as created via shm_open(3). This directory is flushed on boot, and is a tmpfs file system. Since all users have write access to this directory, special care should be taken to avoid name clashes and vulnerabilities. For normal users, shared memory segments in this directory are usually deleted when the user logs out. Usually, it is a better idea to use memory mapped files in /run/ (for system programs) or \$XDG_RUNTIME_DIR (for user programs) instead of POSIX shared memory segments, since these directories are not world-writable and hence not vulnerable to security-sensitive name clashes.
/proc/ # A virtual kernel file system exposing the process list and other functionality. This file system is mostly an API to interface with the kernel and not a place where normal files may be stored. For details, see proc(5). A number of special purpose virtual file systems might be mounted below this directory.
/proc/sys/ # A hierarchy below /proc/ that exposes a number of kernel tunables. The primary way to configure the settings in this API file tree is via sysctl.d(5) files. In sandboxed/containerized setups, this directory is generally mounted read-only.
/sys/ # A virtual kernel file system exposing discovered devices and other functionality. This file system is mostly an API to interface with the kernel and not a place where normal files may be stored. In sandboxed/containerized setups, this directory is generally mounted read-only. A number of special purpose virtual file systems might be mounted below this directory.
/sys/fs/cgroup/ # A virtual kernel file system exposing process control groups (cgroups). This file system is an API to interface with the kernel and not a place where normal files may be stored. On current systems running in the default \u0026ldquo;unified\u0026rdquo; mode, this directory serves as the mount point for the cgroup2 filesystem, which provides a unified cgroup hierarchy for all resource controllers. On systems with non-default configurations, this directory may instead be a tmpfs filesystem containing mount points for various cgroup (v1) resource controllers; in such configurations, if cgroup2 is mounted it will be mounted on /sys/fs/cgroup/unified/, but cgroup2 will not have resource controllers attached. In sandboxed/containerized setups, this directory may either not exist or may include a subset of functionality.
Compatibility Symlinks # /bin/; /sbin/; /usr/sbin/ # These compatibility symlinks point to /usr/bin/, ensuring that scripts and binaries referencing these legacy paths correctly find their binaries.
/lib/ # This compatibility symlink points to /usr/lib/, ensuring that programs referencing this legacy path correctly find their resources.
/lib64/ # On some architecture ABIs, this compatibility symlink points to \$libdir, ensuring that binaries referencing this legacy path correctly find their dynamic loader. This symlink only exists on architectures whose ABI places the dynamic loader in this path.
/var/run/ # This compatibility symlink points to /run/, ensuring that programs referencing this legacy path correctly find their runtime data.
Home Directory # User applications may want to place files and directories in the user\u0026rsquo;s home directory. They should follow the following basic structure. Note that some of these directories are also standardized (though more weakly) by the XDG Base Directory Specification. Additional locations for high-level user resources are defined by xdg-user-dirs.
~/.cache/ # Persistent user cache data. User programs may place non-essential data in this directory. Flushing this directory should have no effect on operation of programs, except for increased runtimes necessary to rebuild these caches. If an application finds \$XDG_CACHE_HOME set, it should use the directory specified in it instead of this directory.
~/.config/ # Application configuration. When a new user is created, this directory will be empty or not exist at all. Applications should fall back to defaults should their configuration in this directory be missing. If an application finds \$XDG_CONFIG_HOME set, it should use the directory specified in it instead of this directory.
~/.local/bin/ # Executables that shall appear in the user\u0026rsquo;s \$PATH search path. It is recommended not to place executables in this directory that are not useful for invocation from a shell; these should be placed in a subdirectory of ~/.local/lib/ instead. Care should be taken when placing architecture-dependent binaries in this place, which might be problematic if the home directory is shared between multiple hosts with different architectures.
~/.local/lib/ # Static, private vendor data that is compatible with all architectures.
~/.local/lib/\u0026lt;arch-id\u0026gt;/ # Location for placing public dynamic libraries. The architecture identifier to use is defined on Multiarch Architecture Specifiers (Tuples) list.
~/.local/share/ # Resources shared between multiple packages, such as fonts or artwork. Usually, the precise location and format of files stored below this directory is subject to specifications that ensure interoperability. If an application finds \$XDG_DATA_HOME set, it should use the directory specified in it instead of this directory.
~/.local/state/ # Application state. When a new user is created, this directory will be empty or not exist at all. Applications should fall back to defaults should their state in this directory be missing. If an application finds \$XDG_STATE_HOME set, it should use the directory specified in it instead of this directory.
Write Access # Unprivileged Write Access # Unprivileged processes generally lack write access to most of the hierarchy.
The exceptions for normal users are /tmp/, /var/tmp/, /dev/shm/, as well as the home directory \$HOME (usually found below /home/) and the runtime directory \$XDG_RUNTIME_DIR (found below /run/user/) of the user, which are all writable.
For unprivileged system processes, only /tmp/, /var/tmp/, and /dev/shm/ are writable. If an unprivileged system process needs a private writable directory in /var/ or /run/, it is recommended to to create it via the StateDirectory= and RuntimeDirectory= directives of service units (see systemd.unit(5) for details), or via tmpfiles.d(5) fragments during boot. A daemon may also create it before dropping privileges, but it is not recommended to start the daemon with privileges just for this.
/tmp/, /var/tmp/, and /dev/shm/ should be mounted nosuid and nodev, which means that set-user-id mode and character or block special devices are not interpreted on those file systems. In general it is not possible to mount them noexec, because various programs use those directories for dynamically generated or optimized code, and with that flag those use cases would break. Using this flag is OK on special-purpose installations or systems where all software that may be installed is known and does not require such functionality. See the discussion of nosuid/nodev/noexec in mount(8) and PROT_EXEC in mmap(2).
Lack of Write Access on Read-Only Systems and during System Recovery # As noted above, some systems operate with the /usr and /etc hierarchies mounted read-only, possibly only allowing write access during package upgrades. Other part of the hierarchy are generally mounted read-write (in particular /var and /var/tmp), but may be read-only when the kernel remounts the file system read-only in response to errors, or when the system is booted read-only for recovery purposes. To the extent reasonable, applications should be prepared to execute without write access, so that for example, failure to save non-essential data to /var/cache/ or failure to create a custom log file under /var/log does not prevent the application from running.
The /run/ directory is available since the earliest boot and is always writable. It should be used for any runtime data and sockets, so that write access to e.g. /etc or /var is not needed.
Node Types # Unix file systems support different types of file nodes, including regular files, directories, symlinks, character and block device nodes, sockets and FIFOs.
It is strongly recommended that /dev/ is the only location below which device nodes shall be placed. Similarly, /run/ shall be the only location to place sockets and FIFOs. Regular files, directories and symlinks may be used in all directories.
Applications should expect that a security policy might be enforced on a system that enforces these rules.
System Packages # Developers of system packages should follow strict rules when placing their files in the file system. The following table lists recommended locations for specific types of files supplied by the vendor.
System package vendor files locations # Directory Purpose /usr/bin/ Package executables that shall appear in the \$PATH executable search path, compiled for any of the supported architectures compatible with the operating system. It is not recommended to place internal binaries or binaries that are not commonly invoked from the shell in this directory, such as daemon binaries. As this directory is shared with most other packages of the system, special care should be taken to pick unique names for files placed here, that are unlikely to clash with other package\u0026rsquo;s files. /usr/lib/\u0026lt;arch-id\u0026gt;/ Public shared libraries of the package. As above, be careful with using too generic names, and pick unique names for your libraries to place here to avoid name clashes. /usr/lib/package/ Private static vendor resources of the package, including private binaries and libraries, or any other kind of read-only vendor data. /usr/lib/\u0026lt;arch-id\u0026gt;/package/ Private other vendor resources of the package that are architecture-specific and cannot be shared between architectures. Note that this generally does not include private executables since binaries of a specific architecture may be freely invoked from any other supported system architecture. Additional static vendor files with shared ownership may be installed in the /usr/share/ hierarchy to the locations defined by the various relevant specifications.
System package variable files locations # The following directories shall be used by the package for local configuration and files created during runtime:
Directory Purpose /etc/package/ System-specific configuration for the package. It is recommended to default to safe fallbacks if this configuration is missing, if this is possible. Alternatively, a tmpfiles.d(5) fragment may be used to copy or symlink the necessary files and directories from /usr/share/factory/ during boot, via the L or C directives. /run/package/ Runtime data for the package. Packages must be able to create the necessary subdirectories in this tree on their own, since the directory is flushed automatically on boot. Alternatively, a tmpfiles.d(5) fragment may be used to create the necessary directories during boot, or the RuntimeDirectory= directive of service units may be used to create them at service startup (see systemd.unit(5) for details). /run/log/package/ Runtime log data for the package. As above, the package needs to make sure to create this directory if necessary, as it will be flushed on every boot. /var/cache/package/ Persistent cache data of the package. If this directory is flushed, the application should work correctly on next invocation, though possibly slowed down due to the need to rebuild any local cache files. The application must be capable of recreating this directory should it be missing and necessary. To create an empty directory, a tmpfiles.d(5) fragment or the CacheDirectory= directive of service units (see systemd.unit(5)) may be used. /var/lib/package/ Persistent private data of the package. This is the primary place to put persistent data that does not fall into the other categories listed. Packages should be able to create the necessary subdirectories in this tree on their own, since the directory might be missing on boot. To create an empty directory, a tmpfiles.d(5) fragment or the StateDirectory= directive of service units (see systemd.unit(5)) may be used. /var/log/package/ Persistent log data of the package. As above, the package should make sure to create this directory if necessary, possibly using tmpfiles.d(5) or LogsDirectory= (see systemd.exec(5)), as it might be missing. User Packages # Programs running in user context should follow strict rules when placing their own files in the user\u0026rsquo;s home directory. The following table lists recommended locations in the home directory for specific types of files supplied by the vendor if the application is installed in the home directory. (User applications installed system-wide are covered by the rules outlined above for vendor files.)
Vendor package file locations under the home directory of the user # Directory Purpose ~/.local/bin/ Package executables that shall appear in the \$PATH executable search path. It is not recommended to place internal executables or executables that are not commonly invoked from the shell in this directory, such as daemon executables. As this directory is shared with most other packages of the user, special care should be taken to pick unique names for files placed here, that are unlikely to clash with other package\u0026rsquo;s files. ~/.local/lib/\u0026lt;arch-id\u0026gt;/ Public shared libraries of the package. As above, be careful with using overly generic names, and pick unique names for your libraries to place here to avoid name clashes. ~/.local/lib/package/ Private, static vendor resources of the package, compatible with any architecture, or any other kind of read-only vendor data. ~/.local/lib/\u0026lt;arch-id\u0026gt;/package/ Private other vendor resources of the package that are architecture-specific and cannot be shared between architectures. Additional static vendor files with shared ownership may be installed in the ~/.local/share/ hierarchy, mirroring the subdirectories specified in the section \u0026ldquo;Vendor-supplied operating system resources\u0026rdquo; above.
User package variable file locations # The following directories shall be used by the package for per-user local configuration and files created during runtime:
Directory Purpose ~/.config/package/ User-specific configuration for the package. It is required to default to safe fallbacks if this configuration is missing. \$XDG_RUNTIME_DIR/package/ User runtime data for the package. ~/.cache/package/ Persistent cache data of the package. If this directory is flushed, the application should work correctly on next invocation, though possibly slowed down due to the need to rebuild any local cache files. The application must be capable of recreating this directory should it be missing and necessary. ~/.local/state/package/ Persistent state data of the package. See Also # The systemd(1) system and service manager implements and expects the layout described in this specification.
`}),e.add({id:9,href:"/specifications/specs/linux_tpm_pcr_registry/",title:"Linux TPM PCR Registry",section:"Specs",content:` 🔏 Linux TPM PCR Registry 🗒️ # Version Changes 1.0 Initial Release TPM PCRs are a scarce resource, there are only 24 of them in typical standards compliant TPMs. According to the TCG PC Client Specific Platform Firmware Profile Specification | Trusted Computing Group the OS can make use of PCRs 8…15. This document lists which component is using which PCR on a Linux platform in order to minimize conflicts.
PCRs owned by the firmware, i.e. PCRs 0–7 are described here just for convenience. The authoriative description is in the TCG document.
How other operating systems — in particular Windows — use PCRs, is out of scope of this document.
This document is informational in nature: it just describes what is, it is not intended to formally declare “ownership” of a specific PCR, but simply is supposed to reflect which PCR assignments are common in the Linux ecosystems. That said, co-opting PCR usage will likely create problems down the line, in particular if measurement logs are maintained separately. (To be more explicit: on systemd systems the warranty is voided if you write to the PCRs it also uses, as per the list below.)
PCR measurements most commonly serve two distinct purposes:
To implement access policy on TPM sealed objects: policy can dictate that unsealing of such objects shall only be allowed if some PCRs are in a specific literal state, or in any state for which a signature by a specific key pair can be provided. For this it is essential that PCRs only contain measurements for a clearly defined set of objects, that typically is known in advance so that the PCR value can be pre-calculated (hence this is in a way a forward-looking use) To permit reasoning about the boot process and runtime so far, for example for the purpose of remote attestation. In this case it is not that important what objects are measured as long as a record is kept in a measurement log about what it was. The PCRs are in this case used to validate that log (hence this is in a way a backward-looking use) In both cases it is important that data measured into the PCRs is carefully chosen. PCRs that shall be useful for policy binding should only cover data objects known in advance, and thus not contain runtime data that cannot be pre-calculated in advance. PCRs that shall be useful for backward-looking validation should only cover objects that are also written to the appropriate log for the PCR.
PCR#
Used by From Location Measured Objects Log Use Reported By 0
Firmware 💻 UEFI Boot Component Core system firmware executable code UEFI TPM event log n/a 1
Firmware 💻 UEFI Boot Component Core system firmware data/host platform configuration; typically contains serial and model numbers UEFI TPM event log n/a 2
Firmware 💻 UEFI Boot Component Extended or pluggable executable code; includes option ROMs on pluggable hardware UEFI TPM event log n/a 3
Firmware 💻 UEFI Boot Component Extended or pluggable firmware data; includes information about pluggable hardware UEFI TPM event log n/a 4
Firmware 💻 UEFI Boot Component Boot loader and additional drivers; binaries and extensions loaded by the boot loader UEFI TPM event log n/a 5
Firmware 💻 UEFI Boot Component GPT/Partition table UEFI TPM event log n/a systemd-boot 🚀 UEFI Boot Component Used loader.conf UEFI TPM event log n/a 7
Firmware 💻 UEFI Boot Component SecureBoot state UEFI TPM event log n/a 8
grub 🍲 UEFI Boot Component Commands and kernel command line UEFI TPM event log n/a 9
grub 🍲 UEFI Boot Component All files read (including kernel image) UEFI TPM event log n/a Linux kernel 🌰 Kernel All passed initrds (when the new LOAD_FILE2 initrd protocol is used) UEFI TPM event log n/a systemd-tpm2-setup.service 🚀 Userspace State of each NvPCR after anchor measurement /run/log/systemd/tpm2-measure.log n/a systemd-pcrnvdone.service 🚀 Userspace NvPCR anchor measurement separator /run/log/systemd/tpm2-measure.log n/a 10
IMA 📐 Kernel Protection of the IMA measurement log IMA event log n/a 11
systemd-stub 🚀 UEFI Stub All components of unified kernel images (UKIs) UEFI TPM event log in EFI variable StubPcrKernelImage systemd-pcrphase 🚀 Userspace Boot phase strings, indicating various milestones of the boot process /run/log/systemd/tpm2-measure.log n/a 12
systemd-stub 🚀 UEFI Stub Kernel command line, system credentials, system configuration images, initrd addons, µcode addons, devicetree addons UEFI TPM event log in EFI variable StubPcrKernelParameters 13
systemd-stub 🚀 UEFI Stub All system extension images for the initrd UEFI TPM event log in EFI variable StubPcrInitRDSysExts 14
shim 🔑 UEFI Boot Component “MOK” certificates and hashes UEFI TPM event log n/a 15
systemd-cryptsetup@.service 🚀 Userspace Root file system volume encryption key /run/log/systemd/tpm2-measure.log n/a systemd-pcrmachine.service 🚀 Userspace Machine ID (/etc/machine-id) /run/log/systemd/tpm2-measure.log n/a systemd-pcrfs@.service 🚀 Userspace File system mount point, UUID, label, partition UUID label of root file system and /var/ /run/log/systemd/tpm2-measure.log n/a PCR 0 changes on firmware updates; PCR 1 changes on basic hardware/CPU/RAM replacements.
PCR 4 changes on boot loader updates. The shim project will measure the PE binary it chain loads into this PCR. If the Linux kernel is invoked as UEFI PE binary, it is measured here, too. systemd-stub measures system extension images read from the ESP here too (see systemd-sysext and Extension Images).
PCR 5 changes when partitions are added, modified, or removed.
PCR 7 changes when UEFI SecureBoot mode is enabled/disabled, or firmware certificates (PK, KEK, db, dbx, …) are updated. The shim project will measure most of its (non-MOK) certificates and SBAT data into this PCR.
PCR 11 and 15 as shown in the list above are used by multiple components of systemd. These are not conflicting uses; the involved components are properly ordered to cooperatively guarantee predictable behaviour.
systemd-stub measures the ELF kernel image, embedded initrd and other payload of the PE image into PCR 11. Unlike PCR 4 (where the same data should be measured too), those values should be easy to pre-calculate, as they only reflect the static parts of the PE binary. systemd-pcrphase.service measures boot phase strings into this PCR at various milestones of the boot process. Use PCR 11 to bind TPM policies to a specific kernel image, possibly with an embedded initrd, and to a specific boot phase.
systemd-boot measures the kernel command line into PCR 12. systemd-stub measures any manually specified kernel command line (i.e. a kernel command line that overrides the one embedded in the UKI) and loaded credentials into this PCR. This means that if systemd-boot and systemd-stub are used together, the command line might be measured twice.
systemd-stub measures any Extension Images it passes to the booted kernel into PCR 13.
systemd-cryptsetup optionally measures the volume key of activated LUKS volumes into this PCR. systemd-pcrmachine.service measures the machine-id into this PCR. systemd-pcrfs@.service measures mount points, file system UUIDs, labels, partion UUIDs of the root and /var/ filesystems into this PCR.
Sources # systemd-cryptenroll(1) TCG PC Client Specific Platform Firmware Profile Specification shim\u0026rsquo;s README.tpm Measured Boot - GNU GRUB Manual 2.06 Integrity Measurement Architecture (IMA) edk2-TrustedBootChain/4_Other_Trusted_Boot_Chains.md Trusted Platform Module - ArchWiki `}),e.add({id:10,href:"/specifications/specs/package_metadata_for_executable_files/",title:"Package Metadata for Executable Files",section:"Specs",content:` Package Metadata for Executable Files # Version Changes 1.0 Initial Release Target Audience # The target audience for this specification is:
Developers working on userspace subsystems that create or manipulate ELF or PE/COFF binaries Developers working on userspace subsystems that parse core files Motivation # ELF binaries get stamped with a unique, build-time generated hex string identifier called build-id, which gets embedded as an ELF note called .note.gnu.build-id. In most cases, this allows a stripped binary to be associated with its debugging information. It is used, for example, to dynamically fetch DWARF symbols from a debuginfo server, or to query the local package manager and find out the package metadata or, again, the DWARF symbols or program sources.
However, this usage of the build-id requires either local metadata, usually set up by the package manager, or access to a remote server over the network. Both of those might be unavailable or forbidden.
Thus it becomes desirable to add additional metadata to a binary at build time, so that systemd-coredump and other services analyzing core files are able to extract said metadata simply from the core file itself, without external dependencies.
This metadata is stored as a section in the executable file, so that it will be loaded into memory along with the text and data of the binary, and will be preserved in a core dump. This metadata can also be easily read from the file on disk, so it can be used to identify provenience of files, independently of any package management system, even if the file is renamed or copied.
Implementation # This document will attempt to define a common metadata format specification, so that multiple implementers might use it when building packages, or core file analyzers, and so on.
Implementers working on parsing the metadata should not assume a specific list of names, but parse anything that is included in the JSON object.
Implementers working on build tools should strive to use the same names, for consistency. The most common will be listed here. When corresponding to the content of os-release, the values should match, again for consistency.
If available, the metadata should also include the debuginfod server URL that can provide the original executable, debuginfo and sources, to further facilitate debugging.
ELF header section # The metadata will be embedded in a single, 4 byte-aligned, allocated, NUL-padded, read-only ELF header section, in a name-value JSON object format. The JSON string is terminated with a NUL and subsequently padded with NULs to a multiple of four bytes.
The note type must be set during creation and checked when reading.
Section: .note.package note type: 0xcafe1a7e Owner: FDO (FreeDesktop.org) Value: a single JSON object encoded as a NUL-terminated UTF-8 string
PE/COFF section # The metadata will be embedded in a single, allocated, NUL-padded, read-only COFF data section, in a name-value JSON object format. The JSON string is terminated with a NUL and subsequently padded with NULs if appropriate. The IMAGE_SCN_CNT_INITIALIZED_DATA section flag shall be set. The alignment and padding shall be chosen as appropriate for the use of the PE/COFF file.
Section: .pkgnote Value: a single JSON object encoded as a NUL-terminated UTF-8 string
JSON payload # { \u0026#34;type\u0026#34;:\u0026#34;rpm\u0026#34;, # this provides a namespace for the package+package-version fields \u0026#34;os\u0026#34;:\u0026#34;fedora\u0026#34;, \u0026#34;osVersion\u0026#34;:\u0026#34;33\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;coreutils\u0026#34;, \u0026#34;version\u0026#34;:\u0026#34;4711.0815.fc13\u0026#34;, \u0026#34;architecture\u0026#34;:\u0026#34;arm32\u0026#34;, \u0026#34;osCpe\u0026#34;: \u0026#34;cpe:2.3:o:fedoraproject:fedora:33\u0026#34;, # A CPE name for the operating system, \`CPE_NAME\` from os-release is a good default \u0026#34;appCpe\u0026#34;: \u0026#34;cpe:2.3:a:gnu:coreutils:5.0\u0026#34;, # A CPE name for the upstream application, use NVD CPE search \u0026#34;debugInfoUrl\u0026#34;: \u0026#34;https://debuginfod.fedoraproject.org/\u0026#34; } The format is a single JSON object, encoded as a NUL-terminated UTF-8 string. Each name in the object shall be unique as per recommendations of RFC8259. Strings shall not contain any control characters or use \\uXXX escaping.
When it comes to JSON numbers, this specification assumes that JSON parsers processing this information are capable of reproducing the full signed 53bit integer range (i.e. -2⁵³+1…+2⁵³-1) as well as the full 64-bit IEEE floating point number range losslessly (with the exception of NaN/-inf/+inf, since JSON cannot encode that), as per recommendations of RFC8259. Fields in these JSON objects are thus permitted to encode numeric values from these ranges as JSON numbers, and should not use numeric values not covered by these types and ranges.
If available, the metadata should also include the debuginfod server URL that can provide the original executable, debuginfo and sources, to further facilitate debugging.
Reference implementations of packaging tools for .deb and .rpm are available, and provide macros/helpers to include the note in binaries built by the package build system. They make use of the new --package-metadata= flag that is available in the bfd, gold, mold, and lld linkers (versions 2.39, 2.39, 1.3.0, and 15.0 respectively). This linker flag takes the JSON payload as parameter.
Well-known keys # The metadata format is intentionally left open, so that vendors can add their own information. A set of well-known keys is defined here, and hopefully shared among all vendors.
Key name Key description Example value type The packaging type rpm os The OS name, typically corresponding to ID in os-release fedora osVersion The OS version, typically corresponding to VERSION_ID in os-release 33 name The source package name coreutils version The source package version 4711.0815.fc13 architecture The binary package architecture arm32 osCpe A CPE name for the OS, typically corresponding to CPE_NAME in os-release cpe:2.3:o:fedoraproject:fedora:33 appCpe A CPE name for the upstream Application, as found in NVD CPE search cpe:2.3:a:gnu:coreutils:5.0 debugInfoUrl The debuginfod server url, if available https://debuginfod.fedoraproject.org/ Displaying package notes # The raw ELF section can be extracted using objdump:
\$ objdump -j .note.package -s /usr/bin/ls /usr/bin/ls: file format elf64-x86-64 Contents of section .note.package: 03cc 04000000 7c000000 7e1afeca 46444f00 ....|...~...FDO. 03dc 7b227479 7065223a 2272706d 222c226e {\u0026#34;type\u0026#34;:\u0026#34;rpm\u0026#34;,\u0026#34;n 03ec 616d6522 3a22636f 72657574 696c7322 ame\u0026#34;:\u0026#34;coreutils\u0026#34; 03fc 2c227665 7273696f 6e223a22 392e342d ,\u0026#34;version\u0026#34;:\u0026#34;9.4- 040c 372e6663 3430222c 22617263 68697465 7.fc40\u0026#34;,\u0026#34;archite 041c 63747572 65223a22 7838365f 3634222c cture\u0026#34;:\u0026#34;x86_64\u0026#34;, 042c 226f7343 7065223a 22637065 3a2f6f3a \u0026#34;osCpe\u0026#34;:\u0026#34;cpe:/o: 043c 6665646f 72617072 6f6a6563 743a6665 fedoraproject:fe 044c 646f7261 3a343022 7d000000 dora:40\u0026#34;}... It is more convenient to use a higher level tool:
\$ readelf --notes /usr/bin/ls ... Displaying notes found in: .note.gnu.build-id Owner Data size Description GNU 0x00000014	NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 40e5a1570a9d97fc48f5c61cfb7690fec0f872b2 Displaying notes found in: .note.ABI-tag Owner Data size Description GNU 0x00000010	NT_GNU_ABI_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found in: .note.package Owner Data size Description FDO 0x0000007c	FDO_PACKAGING_METADATA Packaging Metadata: {\u0026#34;type\u0026#34;:\u0026#34;rpm\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;coreutils\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;9.4-7.fc40\u0026#34;,\u0026#34;architecture\u0026#34;:\u0026#34;x86_64\u0026#34;,\u0026#34;osCpe\u0026#34;:\u0026#34;cpe:/o:fedoraproject:fedora:40\u0026#34;} ... \$ systemd-analyze inspect-elf /usr/bin/ls path: /usr/bin/ls elfType: executable elfArchitecture: AMD x86-64 type: rpm name: coreutils version: 9.4-7.fc40 architecture: x86_64 osCpe: cpe:/o:fedoraproject:fedora:40 buildId: 40e5a1570a9d97fc48f5c61cfb7690fec0f872b2 If the binary crashes, systemd-coredump will display the combined information from the crashing binary and any shared libraries it links to:
\$ coredumpctl info PID: 3987823 (ls) Signal: 11 (SEGV) Command Line: ls --color=tty -lR / Executable: /usr/bin/ls ... Storage: /var/lib/systemd/coredump/core.ls.1000.88dea1b9831c420dbb398f9d2ad9b41e.3987823.1726230641000000.zst (present) Size on Disk: 194.4K Package: coreutils/9.4-7.fc40 build-id: 40e5a1570a9d97fc48f5c61cfb7690fec0f872b2 Message: Process 3987823 (ls) of user 1000 dumped core. Module /usr/bin/ls from rpm coreutils-9.4-7.fc40.x86_64 Module libz.so.1 from rpm zlib-ng-2.1.7-1.fc40.x86_64 Module libcrypto.so.3 from rpm openssl-3.2.2-3.fc40.x86_64 Module libmount.so.1 from rpm util-linux-2.40.1-1.fc40.x86_64 Module libcrypt.so.2 from rpm libxcrypt-4.4.36-5.fc40.x86_64 Module libblkid.so.1 from rpm util-linux-2.40.1-1.fc40.x86_64 Module libnss_sss.so.2 from rpm sssd-2.9.5-1.fc40.x86_64 Module libpcre2-8.so.0 from rpm pcre2-10.44-1.fc40.x86_64 Module libcap.so.2 from rpm libcap-2.69-8.fc40.x86_64 Module libselinux.so.1 from rpm libselinux-3.6-4.fc40.x86_64 Stack trace of thread 3987823: #0 0x00007f19331c3f7e lgetxattr (libc.so.6 + 0x116f7e) #1 0x00007f19332be4c0 lgetfilecon_raw (libselinux.so.1 + 0x134c0) #2 0x00007f19332c3bd9 lgetfilecon (libselinux.so.1 + 0x18bd9) #3 0x000056038273ad55 gobble_file.constprop.0 (/usr/bin/ls + 0x17d55) #4 0x0000560382733c55 print_dir (/usr/bin/ls + 0x10c55) #5 0x0000560382727c35 main (/usr/bin/ls + 0x4c35) #6 0x00007f19330d7088 __libc_start_call_main (libc.so.6 + 0x2a088) #7 0x00007f19330d714b __libc_start_main@@GLIBC_2.34 (libc.so.6 + 0x2a14b) #8 0x0000560382728f15 _start (/usr/bin/ls + 0x5f15) ELF object binary architecture: AMD x86-64 (This is just a simulation. ls is not prone to crashing with a segmentation violation.)
`}),e.add({id:11,href:"/specifications/specs/unified_kernel_image/",title:"Unified Kernel Image",section:"Specs",content:` Unified Kernel Image (UKI) # Version Changes 1.0 Initial Release A Unified Kernel Image (UKI) is a combination of an UEFI boot stub program, a Linux kernel image, an optional initrd, and further resources in a single UEFI PE file. This file can either be directly invoked by the UEFI firmware (which is useful in particular in some cloud/Confidential Computing environments) or through a boot loader (which is generally useful to allow multiple kernel versions with interactive or automatic selection of version to boot into).
Various components of the UKI are provided as PE/COFF sections of the executable. The stub is a small program that can be executed in UEFI mode that forms the initial executable part of the combined image. The stub program loads other resources from its executable, including in particular the kernel and initrd, and transitions into the kernel.
This specification defines the format and components (mandatory and optional) of UKIs.
systemd-stub provides the reference implementation of the stub.
UKI File Format # The file format for UKIs is PE/COFF (Portable Executable / Common Object File Format). This is a well-known industry-standard file format, used for example in UEFI environments, and UKIs follow the standard, so exact details will not be repeated here.
UKIs are a PE/COFF file with various resources, listed below, stored in PE sections. In principle this file can be created with a relatively simple objcopy invocation, but the recommended way is to use a helper program ( ukify), which takes care of appropriate alignment and facilitates signing for SecureBoot.
UKIs are UEFI applications images, and hence should initialize the Subsystem field of the optional PE header to 0x0A (i.e. IMAGE_SUBSYSTEM_EFI_APPLICATION).
UKI Components # UKIs consist of the following resources:
An UEFI boot stub that forms the initial program. It contains various PE sections normally required for a program, including .text, .reloc, .data, and others. The Linux kernel in the .linux PE section. Optionally, information describing the OS this kernel is intended for, in the .osrel section. The contents of this section are derived from /etc/os-release of the target OS. They can be useful for presentation of the UKI in the boot loader menu, and ordering it against other entries using the included version information. Optionally, the kernel command line in the .cmdline section. If this is absent, the loader implementation may allow local overrides instead. Optionally, the initrd that the kernel shall unpack and invoke, in the .initrd section. Optionally, a microcode initrd in the .ucode section, to be handed to the kernel before any other initrd. Optionally, a splash image to bring to screen before transitioning into the Linux kernel, in the .splash section. Optionally, a compiled Devicetree, for systems which need it, in the .dtb section. Optionally, one or more compiled Devicetrees, for systems which need it, each in a separate .dtbauto section. The first .dtbauto section that matches the current hardware (matching is done either by the first compatible property with one from the firmware-provided Devicetree or by the SMBIOS fields using the contents of .hwids section as described below) will override the .dtb section. Optionally, a hardware identification table (also known as HWID or CHID) in the .hwids section. Optionally, information describing kernel release information (i.e. uname -r output) in the .uname section. This is also useful for presentation of the UKI in the boot loader menu, and ordering it against other entries. Optionally, a CSV file encoding the SBAT metadata for the image, in the .sbat section. The SBAT format is defined by the Shim project, and used for UEFI revocation purposes. Optionally, a JSON file encoding expected PCR 11 hash values seen from userspace once the UKI has booted up, along with signatures of these expected PCR 11 hash values, in the .pcrsig section. The signatures must also match the key pair described below. Optionally, the public part of a public-private key pair in PEM format used to sign the expected PCR 11 value of the image, in the .pcrpkey section. Note that all of the sections defined above are singletons: they may appear at most once, except for the .dtbauto section which may appear multiple times.
Only the .linux section is required for the image to be considered a Unified Kernel Image.
A UKI will generally also contain various sections required for the boot stub, but we don\u0026rsquo;t document those here.
Boot menus such as sd-boot and other consumers of UKIs may place additional requirements, for example only show kernels with the .osrel section present.
PE Addons # UKIs are PE executables that may be executed directly in UEFI mode, and contain a variety of resources built-in, as described above. Sometimes it\u0026rsquo;s useful to provide a minimal level of modularity and extend UKIs dynamically with additional resources from separate files. For this purpose UKIs can be combined with one or more \u0026ldquo;PE Addons\u0026rdquo;. This are regular PE UEFI application binaries, that can be authenticated via the usual UEFI SecureBoot logic, and may contain additional PE sections from the list above, that shall be used in combination with any PE sections of the UKI itself. At UKI invocation time, the EFI stub contained in the UKI may load additional of these PE Addons and apply them (after authenticating them via UEFI APIs), combining them with the resources of the UKI.
PE Addons may not contain .linux PE sections (this may be used to distinguish them from UKIs, which must have this section, see above).
PE Addons must contain at least one section of the following types:
.cmdline .dtb .dtbauto .ucode .initrd PE Addons should be sorted by their filename, and applied in this order. In case of .cmdline all command lines provided by addons are suffixed in this order to any command line included in the UKI. In case of .dtb and .dtbauto any such section included in the UKI shall be applied first, and those provided by add-ons should then by applied in order as a fix-up. In case of .ucode the contained cpio archives should be prefixed to the regular initrds passed to the kernel, in reverse order. In case of .initrd the contained cpio archives should be appended to the regular initrds passed to the kernel.
PE Addons may include sections of multiple types (e.g. both a .cmdline and a .dtb section), in which case all of them should be applied.
Just like UKIs PE Addons should have the Subystem field of the optional PE header set to 0x0A.
The PE header\u0026rsquo;s Machine field should be set to the local CPU type for the target machine of the Addon. When enumerating PE Addons to apply, candidates should be skipped when their header field reports a non-native CPU architecture.
PE Addons may contain executable code in a .text section. This code may be useful to write a friendly error message to the UEFI console when executed as regular programs. The code should be ignored when the addon is applied on an UKI.
UKI TPM PCR Measurements # On systems with a Trusted Platform Module (TPM) the UEFI boot stub shall measure the sections listed above, starting from the .linux section, in the order as listed (which should be considered the canonical order). The .pcrsig section is not measured.
For each section two measurements shall be made into PCR 11 with the event code EV_IPL:
The section name in ASCII (including one trailing NUL byte) The (binary) section contents The above should be repeated for every section defined above, so that the measurements are interleaved: section name followed by section data, followed by the next section name and its section data, and so on.
If multiple .dtbauto sections are present, only the one that is actually in use shall be measured.
JSON Format for .pcrsig # The format is a single JSON object, encoded as a zero-terminated UTF-8 string. Each name in the object shall be unique as per recommendations of RFC8259. Strings shall not contain any control character, nor use \\uXXX escaping.
When it comes to JSON numbers, this specification assumes that JSON parsers processing this information are capable of reproducing the full signed 53bit integer range (i.e. -2⁵³+1…+2⁵³-1) as well as the full 64bit IEEE floating point number range losslessly (with the exception of NaN/-inf/+inf, since JSON cannot encode that), as per recommendations of RFC8259. Fields in these JSON objects are thus permitted to encode numeric values from these ranges as JSON numbers, and should not use numeric values not covered by these types and ranges.
The content is a JSON object, named after the TPM SHA bank to use, containing an array of measurement objects, each containing an array of PCRs, the SHA256 fingerprint of the public key (DER) used for the signature (pkfp), the expected hash (pol) and the signature encoded in base64 (sig).
Example:
{ \u0026#34;sha1\u0026#34;: [ { \u0026#34;pcrs\u0026#34;: [ 11 ], \u0026#34;pkfp\u0026#34;: \u0026#34;2870989436ec5c24461f36f5f070613043c30a156a895903e27fc985d1b2887f\u0026#34;, \u0026#34;pol\u0026#34;: \u0026#34;4a5cfbca5123490989ac060ec8b1755cfa6f0ea37ec39206e988442a9a9023bb\u0026#34;, \u0026#34;sig\u0026#34;: \u0026#34;X9a07Peo0EaEWr0dfUgZIq3Bsf20AGTjAgMilyH3TkLtPBGJLCEFRzK2jkPohG0VXQjao35765Wp/sV1wfctGC0fx9GOsBzK8YKjsFitOw21aLxlnES31D3PbDLPRqkx+fAhwV0/Akd99hNuiyzGdUewNpbbBNo7WXkd4K62RK61dKKI4g//qtLeAyXlee0TLKVxNcT46Ud1t8eUb1GAwRnO7DxBZx8uFyP/D9wpPNK7+M01to74d9ijcsjLXf2eGKcpiDvenUnhI6ua+OvT6CnmgxkFQutLGz/Ka23spSG/YJHfxGT7VpOYveDG19nqBb/fg30HZiY7lVTolS93UA==\u0026#34; } ], \u0026#34;sha256\u0026#34;: [ { \u0026#34;pcrs\u0026#34;: [ 11 ], \u0026#34;pkfp\u0026#34;: \u0026#34;2870989436ec5c24461f36f5f070613043c30a156a895903e27fc985d1b2887f\u0026#34;, \u0026#34;pol\u0026#34;: \u0026#34;707f5d03325822b2a53bfe5d723e0ca290f397c0e6184131b70d00e35224488a\u0026#34;, \u0026#34;sig\u0026#34;: \u0026#34;moQh6GF18LiVlA8CxRkTtbXr2p0NIIBosLazDALZ9lOJQw/w1PB7tcDZ1Kumvzqtx4FO5WVjOkVTnNFrYmXn9K2PpqIDEuTtwaM/lKgP12LtcC635C+VsJMQg3k9sEFfLwBCzrhYxt5GCpxzPrsfwJtsUpueB23sNw27WJS7C+tVnqWw7br6i9vJ59jP9+HXlex+OlZHliHLzZwpuZA8iPMQT0xvm901ak5yoBqNPv4Yya19dlt2sCuO+Iw1LeZW9U83zdG0hn1mxavRIxZ7s0f7a1n/ScrOksgPQB8xfDdFDf9fssGALanOgjCHyD7hRzV31++Qpgah4uc/LJiesg==\u0026#34; } ] } The systemd-measure tool can be used to generate and sign .pcrsig.
Multi-Profile UKIs # In various contexts it is useful to support multiple different configurations (\u0026ldquo;profiles\u0026rdquo;) an UKI may be booted into. An example: a single UKI that can be booted with one of three different kernel command lines, one covering regular boot, one implementing a factory reset logic, and a third one booting into Storage Target Mode, or similar. In order to support this, Multi-Profile UKIs may be defined, as an optional extension of the regular UKI concept described above.
Multi-profile UKIs extend regular UKIs by introducing an additional PE section with the name .profile which can appear multiple times in a single PE file and both acts as a separator between multiple profiles of the same UKI, and carries meta-information about the profile it is introducing. All regular UKI PE sections listed above may appear multiple times in multi-profile UKIs, but only once before the first .profile PE section, once between each subsequent pair of .profile sections, and once after the last .profile (except for .dtbauto, which is allowed to be defined multiple times anyway, see above). Each .profile section introduces and defines a profile, which are numbered from zero, and typically denoted with an @ character before the profile number, i.e. @0, @1, @2, … The sections listed in the PE binary before the first .profile section make up a special profile called the base profile.
When a multi-profile UKI is invoked, the EFI stub code will make sure to load the PE sections matching the selected profile. A profile is (optionally) selected by prefixing the EFI stub\u0026rsquo;s invocation parameters (\u0026ldquo;command line\u0026rdquo;) with @0 , @1 , @2 , (i.e. an @ character, the numeric profile index, and a space character) in order to select the desired profile. The stub combines the PE sections of the selected profile with any PE sections from the base profile that are not specified in the selected profile. Or in other words: sections associated with specific profiles comprehensively override those of the same name in the base profile. If a multi-profile UKI is invoked without specification of a profile selector on its command line, profile @0 is automatically selected as default.
The profile selector prefix of the UKI\u0026rsquo;s invocation parameters is stripped after parsing, and is thus neither passed on to the invoked kernel on the kernel\u0026rsquo;s command line, nor is measured as part of the kernel command line.
When measuring PE sections before passing control to the contained kernel, only the sections associated with the selected profile, or the base profile are measured. All others are ignored (neither measured nor used in any other way).
A .profile section may optionally contain meta-information about the profile it introduces that a boot menu can use to automatically synthesize menu entries from the profiles a UKI defines. It contains text data, following a similar syntax as .osrel sections: environment-block like key-value pairs. Currently, two fields are defined: ID= may contain a brief textual, 7bit ASCII identifier for the profile. TITLE= may contain a brief human readable text string that may be shown in a boot menu that allows profile selection.
A brief example for the structure of a hypothetical multi-profile UKI:
Section Contents Profile .linux ELF kernel Base .osrel /etc/os-release Base .cmdline \u0026quot;quiet\u0026quot; Base .profile ID=regular TITLE=\u0026quot;Regular boot\u0026quot; @0 .profile ID=factory-reset TITLE=\u0026quot;Reset Device to Factory Defaults\u0026quot; @1 .cmdline \u0026quot;quiet systemd.unit=factory-reset.target\u0026quot; @1 .profile ID=storagetm TITLE=\u0026quot;Boot into Storage Target Mode\u0026quot; @2 .cmdline \u0026quot;quiet rd.systemd.unit=storage-target-mode.target\u0026quot; @2 (Note: in this example, the .cmdline shown as part of the base profile might as well be moved into profile @0 with identical effect. This is because every other profile overrides it anyway, and thus it only applies to profile @0 either way.)
While the primary usecase for multi-profile UKIs are allowing multiple kernel command line sections (i.e. .cmdline) choices, the concept is not limited to that: any of the UKI PE sections may appear in profiles, for example to allow alternative selection of multiple different CPU microcode or Devicetree blobs.
Note that if the PCR signature mechanism described above is used it is recommended to include a separate .pcrsig PE section in each profile matching precisely the sections that apply to that profile (i.e. the combination of the profile\u0026rsquo;s own sections and those of the base section).
Updatability # UKIs wrap all of the above data in a single file, hence all of the above components can be updated in one go through single file atomic updates, which is useful given that the primary expected storage place for these UKIs is the UEFI System Partition (ESP), which is a vFAT file system, with its limited data safety guarantees.
Security # Given UKIs are regular UEFI PE files, they can thus be signed as one for Secure Boot, protecting all of the individual resources listed above at once, and their combination. Standard Linux tools such as sbsigntool and pesign can be used to sign UKI files. The signature format and process again match the ones already used for PE files, so they will not be redefined here.
Locations for Distribution-built UKIs Installed by Package Managers # UKIs that are built centrally by distributions and installed via the package manager should be installed in /usr/lib/modules/\$UNAME/, where \$UNAME is the output of uname -r of the kernel included in the UKI, so that tools staging or consuming UKIs have a common place to store and look for them.
The installed UKIs should have a filename \u0026lt;version format specification\u0026gt;.efi, i.e. the filename is left to implementers but must be valid for comparisons according to the Version Format Specification.
Locations and Naming for UKI Auxiliary Resources # Auxiliary UKI resources (such as PE addons for kernel command line extensions and similar, as well as systemd-sysext and systemd-confext DDIs) built centrally by distributions and installed via package manager should be installed into locations depending on whether they should be applied to all UKIs installed in the ESP, or only to a single specific UKI.
UKI auxiliary resources that apply to all installed UKIs should be installed into /usr/lib/modules/uki.extra.d/. UKI auxiliary resources that apply to one specific installed UKI should be instead installed into /usr/lib/modules/\$UNAME/\$UKI.efi.extra.d/, where \$UNAME is the output of uname -r of the kernel included in the UKI and \$UKI is the name of the corresponding centrally built UKI with the .efi extension stripped.
The installed UKI auxiliary resources must have a specific file extension, which depends on the resource type:
.addon.efi for PE addons, .sysext.raw for sysext DDIs, .confext.raw for confext DDIs Example # Given a UKI bar_123.efi that includes a kernel 6.9.1-1.foo, consider
a PE addon machine-id that should apply to all installed UKIs, a PE addon proprietary-driver_2000 that is specific to the bar_123 UKI, and a sysext mysysext_1.23.47^3 that should apply to all installed UKIs. The resulting paths would be
/usr/lib/modules/uki.extra.d/machine-id.addon.efi, /usr/lib/modules/6.9.1-1.foo/bar_123.efi.extra.d/proprietary-driver_2000.addon.efi, and /usr/lib/modules/uki.extra.d/mysysext_1.23.47^3.sysext.raw. `}),e.add({id:12,href:"/specifications/specs/version_format_specification/",title:"Version Format Specification",section:"Specs",content:` Version Format Specification # Version Changes 1.0 Initial Release This specification defines the format of version strings and their ordering. Various documents that are part of the uapi-group specification suite, as well as other projects like systemd, rely on this specification to have a sort order for strings that include version components, and use it for various purposes, such as choosing the default boot entry in the Boot Loader Specification.
Version Format # The version string is a sequence of zero or more characters.
The following characters have special meaning:
ASCII digits (0-9) form numerical components. ASCII letters (a-z, A-Z) form alphabetical components. Dot (.) separates parts of a component. Minus (-) separates major parts of the version string. Tilde (~) starts a suffix that always sorts lower. Caret (^) starts a suffix that always sorts higher. Other characters are treated as separators. This includes plus (+) and underscore (_) and other printable or non-printable characters. The underscore MAY be used. The plus SHOULD NOT be used, to avoid confusion with SEMVER which attaches a special meaning to it. Other characters MUST NOT be used in a version string.
Note that in some contexts (for example the DDI specification and DEB package file names), the underscore is used as a separator and cannot be used freely in the version string.
Version Comparison # The following method should be used to compare version strings. The algorithm is based on rpm\u0026rsquo;s rpmvercmp(), but not identical.
Both strings are compared from the beginning until the end, or until the strings are found to compare as different. In a loop:
Any characters which are outside of the set of listed above (a-z, A-Z, 0-9, -, ., ~, ^) are skipped in both strings. In particular, this means that non-ASCII characters that are Unicode digits or letters are skipped too. If the remaining part of one of strings starts with ~: if other remaining part does not start with ~, the string with ~ compares lower. Otherwise, both tilde characters are skipped. If one of the strings has ended: if the other string hasn\u0026rsquo;t, the string that has remaining characters compares higher. Otherwise, the strings compare equal. If the remaining part of one of strings starts with -: if the other remaining part does not start with -, the string with - compares lower. Otherwise, both minus characters are skipped. If the remaining part of one of strings starts with ^: if the other remaining part does not start with ^, the string with ^ compares lower. Otherwise, both caret characters are skipped. If the remaining part of one of strings starts with .: if the other remaining part does not start with ., the string with . compares lower. Otherwise, both dot characters are skipped. If either of the remaining parts starts with a digit: numerical prefixes are compared numerically. Any leading zeroes are skipped. The numerical prefixes (until the first non-digit character) are evaluated as numbers. If one of the prefixes is empty, it evaluates as 0. If the numbers are different, the string with the bigger number compares higher. Otherwise, the comparison continues at the following characters at point 1. Leading alphabetical prefixes are compared alphabetically. The substrings are compared letter-by-letter. If both letters are the same, the comparison continues with the next letter. All capital letters compare lower than lower-case letters (B \u0026lt; a). When the end of one substring has been reached (a non-letter character or the end of the whole string), if the other substring has remaining letters, it compares higher. Otherwise, the comparison continues at the following characters at point 1. Comparison with Other Specifications # Other specifications exist to mandate version formats:
RPM Packaging Guidelines Debian Policy Semantic Versioning All of these, including the present document, share some commonalities but are also incompatible in some ways, as they all evolved in different environments. The main differences are as follows.
to separate components DEB uses _, RPM uses - with positional logic (it assumes different meaning in different positions), and SemVer does not specify anything as it is concerned only with the version part of the string to identify a pre-release suffix RPM and DEB use ~ and SemVer uses - to identify a rebuild suffix DEB uses +, SemVer uses ., and RPM increases the release part of the version to identify an epoch prefix DEB and RPM use :, and SemVer does not specify anything Examples # Examples (with \u0026rsquo;\u0026rsquo; meaning the empty string):
11 == 11 systemd-123 == systemd-123 bar-123 \u0026lt; foo-123 123a \u0026gt; 123 123.a \u0026gt; 123 123.a \u0026lt; 123.b 123a \u0026gt; 123.a 11α == 11β B \u0026lt; a \u0026rsquo;\u0026rsquo; \u0026lt; 0 0. \u0026gt; 0 0.0 \u0026gt; 0 0 \u0026gt; ~ \u0026rsquo;\u0026rsquo; \u0026gt; ~ 1_ == 1 _1 == 1 1_ \u0026lt; 1.2 1_2_3 \u0026gt; 1.3.3 1+ == 1 +1 == 1 1+ \u0026lt; 1.2 1+2+3 \u0026gt; 1.3.3 Note how in the 1_2_3 \u0026gt; 1.3.3 and 1+2+3 \u0026gt; 1.3.3 cases, the underscore and plus characters act as separators between components, so we first compare 1 with 1.3.3 as numerical version strings, and 1 \u0026lt; 1.3.3. The remainder of the first string is not used in the comparison.
122.1 \u0026lt; 123~rc1-1 \u0026lt; 123 \u0026lt; 123-a \u0026lt; 123-a.1 \u0026lt; 123-1 \u0026lt; 123-1.1 \u0026lt; 123^post1 \u0026lt; 123.a-1 \u0026lt; 123.1-1 \u0026lt; 123a-1 \u0026lt; 124-1 In the above example each entry compares smaller than every entry to its right and equal only to itself, conversely each entry compares larger to every entry to its left and compares unequal to all except itself.
Notes # systemd-analyze implements this version comparison algorithm as
systemd-analyze compare-versions \u0026lt;version-a\u0026gt; \u0026lt;version-b\u0026gt; `})})()