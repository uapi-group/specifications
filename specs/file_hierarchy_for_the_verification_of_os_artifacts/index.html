<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.104.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="File Hierarchy for the Verification of OS Artifacts (VOA) # Motivation # Cryptographic validation of artifacts with the help of digital signatures is a use-case of most Linux distributions. Different cryptographic technologies exist and can be used for this purpose. Currently, OpenPGP and X.509 are widely adopted.
As of this writing, no technology-agnostic, standardized location for the distribution of cryptograpic material that serves as verifier for digital signatures exists. This leaves consumers to either do guesswork, or rely on proprietary, stateful or technology-specific keystore formats and per-application locations."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="File Hierarchy for the Verification of OS Artifacts (VOA)"><meta property="og:description" content="File Hierarchy for the Verification of OS Artifacts (VOA) # Motivation # Cryptographic validation of artifacts with the help of digital signatures is a use-case of most Linux distributions. Different cryptographic technologies exist and can be used for this purpose. Currently, OpenPGP and X.509 are widely adopted.
As of this writing, no technology-agnostic, standardized location for the distribution of cryptograpic material that serves as verifier for digital signatures exists. This leaves consumers to either do guesswork, or rely on proprietary, stateful or technology-specific keystore formats and per-application locations."><meta property="og:type" content="article"><meta property="og:url" content="https://uapi-group.org/specifications/specs/file_hierarchy_for_the_verification_of_os_artifacts/"><meta property="article:section" content="specs"><title>File Hierarchy for the Verification of OS Artifacts (VOA) | UAPI Group Specifications</title><link rel=manifest href=/specifications/manifest.json><link rel=icon href=/specifications/favicon.png type=image/x-icon><link rel=stylesheet href=/specifications/book.min.f716a89e40b01f033146ee402497165ac5bcf8935948094dceafbcb19f6f3c8d.css integrity="sha256-9xaonkCwHwMxRu5AJJcWWsW8+JNZSAlNzq+8sZ9vPI0="><script defer src=/specifications/en.search.min.1b8f75f880ec8c5aee477f52cfd759853628d4bd1ccbfe28a3e60feed3d74d6b.js integrity="sha256-G491+IDsjFruR39Sz9dZhTYo1L0cy/4oo+YP7tPXTWs="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/specifications><span>UAPI Group Specifications</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://uapi-group.org/>⬅️ Back to top</a></li><li>⸻</li></ul><ul><li><span>Specs</span><ul><li><a href=https://uapi-group.org/specifications/specs/sysext/>Sysext</a></li><li><a href=https://uapi-group.org/specifications/specs/boot_loader_specification/>Boot Loader Specification</a></li><li><a href=https://uapi-group.org/specifications/specs/configuration_files_specification/>Configuration Files Specification</a></li><li><a href=https://uapi-group.org/specifications/specs/discoverable_disk_image/>Discoverable Disk Image</a></li><li><a href=https://uapi-group.org/specifications/specs/discoverable_partitions_specification/>Discoverable Partitions Specification</a></li><li><a href=https://uapi-group.org/specifications/specs/extension_image/>Extension Images</a></li><li><a href=https://uapi-group.org/specifications/specs/file_hierarchy_for_the_verification_of_os_artifacts/ class=active>File Hierarchy for the Verification of OS Artifacts (VOA)</a></li><li><a href=https://uapi-group.org/specifications/specs/linux_file_system_hierarchy/>Linux File System Hierarchy</a></li><li><a href=https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/>Linux TPM PCR Registry</a></li><li><a href=https://uapi-group.org/specifications/specs/unified_kernel_image/>Unified Kernel Image</a></li><li><a href=https://uapi-group.org/specifications/specs/version_format_specification/>Version Format Specification</a></li></ul></li></ul><ul><li>⸻</li><li><a href=https://github.com/uapi-group/specifications target=_blank rel=noopener>Collaborate on Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/specifications/svg/menu.svg class=book-icon alt=Menu></label>
<strong>File Hierarchy for the Verification of OS Artifacts (VOA)</strong>
<label for=toc-control><img src=/specifications/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#terminology>Terminology</a><ul><li><a href=#revocation-of-verifiers>Revocation of verifiers</a></li><li><a href=#classification-of-signature-verification-models>Classification of signature verification models</a></li><li><a href=#application-of-signature-verification-models>Application of signature verification models</a></li><li><a href=#typical-distribution-format-of-verifers--short-vs-long-lived-keys>Typical distribution format of verifers / short vs. long-lived keys</a></li></ul></li><li><a href=#file-hierarchy>File Hierarchy</a><ul><li><a href=#load-paths>Load paths</a></li><li><a href=#symlinking>Symlinking</a></li><li><a href=#masking>Masking</a></li><li><a href=#load-logic>Load logic</a></li><li><a href=#future-compatibility>Future compatibility</a></li></ul></li><li><a href=#identifiers>Identifiers</a><ul><li><a href=#os>OS</a></li><li><a href=#purpose>Purpose</a></li><li><a href=#context>Context</a></li><li><a href=#technology>Technology</a></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#package-manager-verifies-package-signatures-with-trust-anchor>Package manager verifies package signatures, with trust anchor</a></li><li><a href=#download-tool-verifies-installation-medium-without-trust-anchor>Download tool verifies installation medium, without trust anchor</a></li></ul></li><li><a href=#considerations-for-implementers-and-users>Considerations for implementers and users</a><ul><li><a href=#avoiding-duplication-of-data-in-the-directory-structure>Avoiding duplication of data in the directory structure</a></li><li><a href=#access-library-api-considerations>Access library API considerations</a></li><li><a href=#constraining-verifiers>Constraining verifiers</a></li><li><a href=#verifier-optimization>Verifier optimization</a></li><li><a href=#masking-verifiers>Masking verifiers</a></li><li><a href=#threshold-signing>Threshold signing</a></li><li><a href=#retrieval-of-signature-verifiers>Retrieval of signature verifiers</a></li><li><a href=#validity-of-signatures>Validity of signatures</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=file-hierarchy-for-the-verification-of-os-artifacts-voa>File Hierarchy for the Verification of OS Artifacts (VOA)
<a class=anchor href=#file-hierarchy-for-the-verification-of-os-artifacts-voa>#</a></h1><h2 id=motivation>Motivation
<a class=anchor href=#motivation>#</a></h2><p>Cryptographic validation of artifacts with the help of digital signatures is a use-case of most Linux distributions.
Different cryptographic technologies exist and can be used for this purpose.
Currently, OpenPGP and X.509 are widely adopted.</p><p>As of this writing, no technology-agnostic, standardized location for the distribution of cryptograpic material that serves as verifier for digital signatures exists.
This leaves consumers to either do guesswork, or rely on proprietary, stateful or technology-specific keystore formats and per-application locations.</p><p>The <em>File Hierarchy for the Verification of OS Artifacts (VOA)</em> defines a generic approach for storage and retrieval of <em>signature verifiers</em>, supporting a wide range of cryptographic technologies.</p><p>VOA aims to cover all verification needs around OS artifacts.</p><p>Unlike e.g. Mozilla&rsquo;s Network Security Services (
<a href=https://firefox-source-docs.mozilla.org/security/nss/index.html>NSS</a>), which concerns itself with secure network communication, including a curated set of X.509 CA certificates (e.g. often provided on Linux distributions via <code>/etc/pki/</code> or <code>/etc/ca-certificates/</code>), VOA focusses on the verification of artifacts with support for a diverse set of cryptographic technologies.</p><h2 id=terminology>Terminology
<a class=anchor href=#terminology>#</a></h2><p>This text uses the generic term <em>&ldquo;signature verifier&rdquo;</em> for cryptographic objects that are used to verify signatures.
In practice, those may be for example X.509 or OpenPGP certificates (the latter are also referred to as public keys).</p><p>All technologies for validation of signatures rely on <em>public key material</em>.
However, some systems use bare <em>public key material</em>, while others combine key material with additional metadata, forming composite objects that may e.g. also make identity assertions.</p><p>This text uses the term <em>signature verifier</em> to refer to two types of verifiers:</p><ul><li><em>artifact verifiers</em>, which are used for the validation of signatures on artifacts,</li><li><em><a href=https://en.wikipedia.org/wiki/Trust_anchor>trust anchor</a>s</em>, which are used to ascertain the authenticity of <em>artifact verifiers</em>.</li></ul><h3 id=revocation-of-verifiers>Revocation of verifiers
<a class=anchor href=#revocation-of-verifiers>#</a></h3><p>Some technologies have a concept of invalidation of verifiers, using a mechanism that signals to users that a verifier should not be relied on anymore (e.g. because the private key material has been compromised).</p><h3 id=classification-of-signature-verification-models>Classification of signature verification models
<a class=anchor href=#classification-of-signature-verification-models>#</a></h3><p>For the use in the VOA structure, digital signature technologies may be regarded outside of their usual context.
To simplify and allow a unified view on these technologies, VOA classifies these three distinct families:</p><h4 id=point-to-point>Point to Point
<a class=anchor href=#point-to-point>#</a></h4><p>(e.g. SSH, minisign, signify)</p><p>Keys are &ldquo;atomic&rdquo; and don&rsquo;t have formal relationships with each other: A key issues a number of signatures, which can be verified.</p><p>These systems use &ldquo;set-style trust&rdquo;: Users choose to rely on some <em>set</em> of keys/verifiers, and are willing to accept signatures made with those.</p><p>This model doesn&rsquo;t require or support the use of <em>trust anchors</em> in VOA.
In this model, the set of <em>artifact verifiers</em> is considered implicitly trusted and used directly for the verification of artifacts.</p><h4 id=decentralized-delegation>Decentralized delegation
<a class=anchor href=#decentralized-delegation>#</a></h4><p>(e.g. OpenPGP)</p><p>In these systems, key material and certifications (as used in the OpenPGP &ldquo;Web of Trust&rdquo;) are decentralized, forming a non-hierarchical network.
Users need to specify the <em>trust anchors</em> they want to rely on, within their context.</p><p>Two approaches are possible for applications using VOA:</p><ul><li>Directly rely on <em>artifact verifiers</em> for a
<a href=/specifications/#purpose>purpose</a>.</li><li>Rely on <em>trust anchors</em> which delegate to one or more <em>artifact verifiers</em>.
Anchors must be explicitly defined in the relevant &ldquo;trust-anchor&rdquo; VOA directory (see
<a href=/specifications/#purpose>purpose</a>).</li></ul><h4 id=hierarchical-delegation>Hierarchical delegation
<a class=anchor href=#hierarchical-delegation>#</a></h4><p>(e.g. X.509, SSH+CA)</p><p>Other systems have an inherent assumption of hierarchical delegation, formalized by cryptographic certifications.
In such systems, globally or locally accepted <em>trust anchors</em> are used as starting points in signature validation.
Certificates and the delegation relations between them in practice often form a tree structure.
Such hierarchical key structures are often referred to as
<a href=https://en.wikipedia.org/wiki/Public_key_infrastructure>public key infrastructure</a> (PKI).
In many X.509 ecosystems a shared set of <em>trust anchors</em> exist, that all actors agree upon (e.g. <em>Web PKI</em>).</p><p>This model requires explicitly defined <em>trust anchors</em> in VOA, that delegate to <em>artifact verifiers</em>.</p><h3 id=application-of-signature-verification-models>Application of signature verification models
<a class=anchor href=#application-of-signature-verification-models>#</a></h3><p>Although the
<a href=/specifications/#classification-of-signature-verification-models>classification of signature verification models</a> categorizes various technologies for the verification of digital signatures, the reality is more diverse.
In practice VOA only distinguishes between direct verifications and those relying on some form of delegation.
The details of delegation are technology specific and described in their respective
<a href=/specifications/#technology>technology</a> sections.</p><h3 id=typical-distribution-format-of-verifers--short-vs-long-lived-keys>Typical distribution format of verifers / short vs. long-lived keys
<a class=anchor href=#typical-distribution-format-of-verifers--short-vs-long-lived-keys>#</a></h3><p>VOA&rsquo;s goal is to provide a uniform representation of verifiers, to the degree that this is possible with differing technologies.
To achieve this, verifiers are stored in a central file hierarchy that can be used with different technologies.</p><p>Some concerns may be handled differently in supported technologies:</p><ul><li>The separation between <em>trust anchors</em> and <em>artifact verifiers</em> may not be reasonable to model in separated directories, because the native representation of a given technology is to store both in a shared file, as a type of &ldquo;certificate chain&rdquo;.</li><li>By default, VOA suggests that each verifier is stored in an individual file (that ideally reflects a unique identifier of that verifier in its filename).
However, in some technologies, separating verifiers into individual files may be uncommon or unreasonable.
In these technologies, bundles of verifiers may be stored in a shared file (this can apply equally to <em>artifact verifiers</em> and <em>trust anchors</em>).</li><li>As an edge case, in some technologies, <em>artifact verifiers</em> may be extremely short lived, so it may not be reasonable to store them in VOA.
In these cases, only a set of <em>trust anchors</em> may be stored in VOA, while the <em>artifact verifiers</em> are distributed with the signed artifacts.</li></ul><h2 id=file-hierarchy>File Hierarchy
<a class=anchor href=#file-hierarchy>#</a></h2><p>The <em>File Hierarchy for the Verification of OS Artifacts (VOA)</em> is maintained as a directory structure on a system.
It contains cryptographic public-key material for one or more technologies.</p><p>The VOA hierarchy organizes <em>signature verifiers</em> by
<a href=/specifications/#os>os</a>,
<a href=/specifications/#purpose>purpose</a>,
<a href=/specifications/#context>context</a> and
<a href=/specifications/#technology>technology</a>, and stores them in a directory structure of the form <code>$os/$purpose/$context/$technology/</code>.</p><p>Vendors provide a set of <em>signature verifier</em> files for their OS, in the VOA hierarchy format.</p><p>Users of a VOA hierarchy (such as package installation software) can pick the relevant set of <em>signature verifiers</em> for the verification of a specific artifact based on their location in the hierarchy.</p><p>VOA does not concern itself with the retrieval of additional <em>signature verifiers</em> or the update of existing ones in the file hierarchy.</p><h3 id=load-paths>Load paths
<a class=anchor href=#load-paths>#</a></h3><p>VOA defines a list of <em>load paths</em> with descending priority for system mode and user mode.</p><p><em>Signature verifiers</em> are retrieved from hierarchies in these directories to validate artifacts based on specific
<a href=/specifications/#load-logic>load logic</a>.
This is referred to as <em>verifier lookup</em>.</p><p>The existence of multiple load paths allows system administrators and users to define custom sets of <em>signature verifiers</em> for their system and applications.</p><h4 id=system-mode>System mode
<a class=anchor href=#system-mode>#</a></h4><p>The priority of load paths in system mode follows the definition of
<a href=https://uapi-group.org/specifications/specs/configuration_files_specification/#storage-directories-and-overrides>&ldquo;Storage Directories and Overrides&rdquo; in the Configuration Files Sepcification</a>, which is also reflected in the following list of paths:</p><ul><li><code>/etc/voa/</code></li><li><code>/run/voa/</code></li><li><code>/usr/local/share/voa/</code></li><li><code>/usr/share/voa/</code></li></ul><h4 id=user-mode>User mode
<a class=anchor href=#user-mode>#</a></h4><p>The priority of load paths in user mode mirrors that of the system mode.
Refer to the
<a href=https://specifications.freedesktop.org/basedir-spec/latest/>XDG Base Directory Specification</a> for details on default values.</p><ul><li><code>$XDG_CONFIG_HOME/voa/</code></li><li>the <code>./voa/</code> directory in each directory defined in <code>$XDG_CONFIG_DIRS</code></li><li><code>$XDG_RUNTIME_DIR/voa/</code></li><li><code>$XDG_DATA_HOME/voa/</code></li><li>the <code>./voa/</code> directory in each directory defined in <code>$XDG_DATA_DIRS</code></li></ul><h3 id=symlinking>Symlinking
<a class=anchor href=#symlinking>#</a></h3><p>Load paths are constrained to self-contained locations on a host as they provide vital data for the integrity and verification of all components on a system.
However, relative symlinks can be used in the VOA hierarchy to point to files or directories below the same
<a href=/specifications/#load-paths>load path</a> or one of the <em>load paths</em> in descending priority.</p><p>As an example, symlinks to files below the same load path or to another load path with lower priority may be used to deduplicate the use of a single <em>signature verifier</em> for multiple use-cases.
As another example, using symlinks allows to automatically keep <em>signature verifiers</em> in sync with canonical upstream data.</p><p>VOA implementations must not consider symlinks under the following conditions and raise a warning for them instead:</p><ul><li>the symlink is for a file or directory in an ephemeral load path (i.e. <code>/run/voa/</code> and <code>$XDG_RUNTIME_DIR/voa/</code>),</li><li>the symlink is for a file or directory outside of the specified <em>load paths</em>,</li><li>the symlink is broken (aka. &ldquo;dangling&rdquo;),</li><li>the file name of the symlink (also those of intermediate symlinks in the case of a symlink chain) does not match that of the target,</li><li>or the file type of the source and target of the fully resolved symlink do not match (e.g. a verifier file points to a directory, or a directory to a verifier file).</li></ul><h3 id=masking>Masking
<a class=anchor href=#masking>#</a></h3><p>Individual <em>signature verifiers</em> may be masked using a symlink to <code>/dev/null</code>, independent of
<a href=/specifications/#technology>technology</a>.
This constitutes the only allowed exception to the rule of not symlinking to files or directories external to the load paths.
These symlinks are only expected to be used in writable load paths (that is, only below <code>/etc/voa/</code> or <code>/run/voa/</code> when in system mode, or below <code>$XDG_CONFIG_HOME/voa/</code> or <code>$XDG_RUNTIME_DIR/voa/</code> when in user mode).
A <em>signature verifier</em> that is masked is considered invalid in all
<a href=/specifications/#load-paths>load paths</a> independent of technology and
<a href=/specifications/#load-logic>load logic</a>.</p><p>Masking <em>signature verifiers</em> may be desirable in situations where a verifier is considered compromised, but a revocation for it can not be provided to users in time.
VOA offers this mechanism as an alternative to revocation.</p><p>Masking is explicitly designed to be used on individual <em>signature verifiers</em>.
The masking (of parts) of the directory structures that contain them on the other hand does not yield meaningful or intelligible results for end-users and would be very complex to reason about.
VOA implementations must not consider masking symlinks for directories and should raise a warning if such symlinks are encountered.</p><h3 id=load-logic>Load logic
<a class=anchor href=#load-logic>#</a></h3><p>Load logic depends on the
<a href=/specifications/#technology>technology</a> in use.
It is the mechanism by which relevant verifier information from all load paths is retrieved, while considering the
<a href=/specifications/#os>os</a>,
<a href=/specifications/#purpose>purpose</a>,
<a href=/specifications/#context>context</a> and
<a href=/specifications/#technology>technology</a> request of a calling application.</p><p>For some technologies, the first suitable <em>signature verifier</em> found in the list of
<a href=/specifications/#load-paths>load paths</a> is used, effectively
<a href=/specifications/#overriding>overriding</a> files with the same name in directories lower in the list.</p><p>However, in other technologies, more complex
<a href=/specifications/#merging>merging</a> logic may apply, that effectively combines information from different representations of one verifier.</p><p>Additionally, the concept of
<a href=/specifications/#masking>masking</a> applies for all technologies.</p><h4 id=overriding>Overriding
<a class=anchor href=#overriding>#</a></h4><p>In technologies that use overriding, verifier files shadow other variants of the same verifier based on filename equality.</p><p>For example, <code>/etc/voa/fedora/packages/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub</code> overrides <code>/usr/share/voa/fedora/package/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub</code>.</p><p>Overriding depends on file name equality and directory structure.</p><p>For example, <code>/etc/voa/fedora/packages/default/ssh/7d865e959b2466918c9863afca942d0fb89d7c9ac0c99bafc3749504ded97730.pub</code> does not override <code>/usr/share/voa/fedora/package/default/ssh/b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.pub</code>, but instead adds an additional <em>signature verifier</em>.</p><p>Great care has to be taken to ensure the naming scheme has the desired overriding behavior (e.g. to make sure that a revoked version of an SSH public key overrides a non-revoked version of the same SSH public key found in a different load path).</p><h4 id=merging>Merging
<a class=anchor href=#merging>#</a></h4><p>Some technologies use a business logic that &ldquo;merges&rdquo; different versions of the same <em>signature verifier</em> (instead of applying overriding semantics).
The purpose is to use the latest available information about each verifier, combining the information from all sources.</p><p>When merging, information about a verifier found anywhere in the current <em>verifier lookup</em> must be applied for all uses of a verifier (e.g. for revocation status).</p><p>Wherever it is applicable and feasible, VOA technology backend implementations should implement &ldquo;merging&rdquo; to obtain a unified view of the latest information for each verifier.</p><p>For example, if a verifier has been revoked, but only one of two copies of that verifier in VOA reflects this revocation, &ldquo;merging&rdquo; the two leads to stable visibility of the revocation status.
Summarized, in technologies that implement merging,
<a href=/specifications/#load-paths>load path</a> priority is not relevant (e.g. a non-revoked version in <code>/etc/voa/</code> of the same verifier never overrides the revoked version in <code>/usr/share/voa/</code>).
The &ldquo;latest normalized view&rdquo; of a verifier is not impacted by load path priority.</p><h3 id=future-compatibility>Future compatibility
<a class=anchor href=#future-compatibility>#</a></h3><p>No changes to the overall VOA structure are anticipated, which is why versioning is not encoded in the directory structure.
However, if it turns out that a breaking change to the VOA specification is necessary a separate directory structure (e.g. <code>/usr/share/voa2/</code>) can be specified.</p><p>Independently, breaking changes of the VOA format <em>within</em> individual technologies may occur.
In this case, versioned variants of the technology in question are added (e.g. <code>openpgp:2</code>).
The <code>:</code> delimiter is chosen to signify VOA-specific versioning.
This differentiates clearly between versions of the technology itself, as specified upstream (e.g.
<a href=https://datatracker.ietf.org/doc/html/rfc4880>OpenPGPv4</a>,
<a href=https://datatracker.ietf.org/doc/html/rfc9580>OpenPGPv6</a>) and how these technologies are used in the context of VOA.</p><h2 id=identifiers>Identifiers
<a class=anchor href=#identifiers>#</a></h2><p><em>Signature verifiers</em> are located in directory structures described by the
<a href=/specifications/#file-hierarchy>file hierarchy</a>.
Each of the following identifiers represents a subdirectory layer in that hierarchy.</p><h3 id=os>OS
<a class=anchor href=#os>#</a></h3><p>The <em>os</em> identifier is used to uniquely identify an Operating System (OS).</p><p>The identifier relies on data provided by the ubiquitous
<a href=https://man.archlinux.org/man/os-release.5.en>os-release</a>.
The following keywords are understood and their value format follows that established by
<a href=https://man.archlinux.org/man/os-release.5.en>os-release</a> (i.e. no spaces and no characters outside of <code>0–9</code>, <code>a–z</code>, <code>"."</code>, <code>"_"</code> and <code>"-"</code> are allowed):</p><ul><li><code>ID</code>: name of OS (e.g. <code>arch</code> or <code>debian</code>)</li><li><code>VERSION_ID</code>: the version of the OS (e.g. <code>1.0.0</code> or <code>24.12</code>)</li><li><code>VARIANT_ID</code>: the variant of the OS (e.g. <code>server</code> or <code>workstation</code>)</li><li><code>IMAGE_ID</code>: the image of an OS (e.g. <code>cashier-system</code>)</li><li><code>IMAGE_VERSION</code>: version of the image (e.g. <code>1.0.0</code> or <code>24.12</code>)</li></ul><p>The values for these <em>parts</em> must be provided, in the above order, as a colon-separated string that defines a specific <em>os</em> identifier (e.g. <code>debian:12:server:company-x:25.01</code>).
At least the <code>ID</code> <em>part</em> must be set, an empty <em>os</em> identifier is invalid.
Trailing colons must be omitted for all <em>parts</em> that are unset (e.g. <code>arch</code> instead of <code>arch::::</code>).</p><p>The <em>os</em> identifier may be extended with further <em>parts</em> in an updated specification.
Users encountering an <em>os</em> identifier with more than 5 <em>parts</em> should ignore these directories.</p><p>Users of VOA (e.g. a Linux distribution creator) are free to store and retrieve verifiers in more or less specific <em>os</em> identifiers, at their own discretion. VOA supports both generic identifiers (e.g. <code>arch</code>), and very specific identifiers (e.g. <code>fedora:41:workstation:cashier-system:1.0.0</code>).</p><p>VOA is not flexible regarding <em>os</em> strings:
When an application looks up verifiers for e.g. <code>fedora:41:workstation</code>, then no verifiers from alternate <em>os</em> strings are implicitly considered (e.g. from the more general location <code>fedora:41</code>).</p><p>However, VOA libraries may offer an API that allows applications to use a list of <em>os</em> strings (e.g. a list of both <code>fedora:41:workstation</code> and <code>fedora:41</code>).
Such a call will use the combination of all verifiers found in both directory hierarchies.
Applications that use VOA (via a VOA library) can therefore opt to pass a list of <em>os</em> strings, if verifiers are known to be spread over different <em>os</em> directories.
VOA users can omit specific parts, e.g. <code>IMAGE_ID</code> and <code>IMAGE_VERSION</code>, if they know that these parts are not used in the
<a href=/specifications/#hierarchy>VOA hierarchy</a> for their <em>os</em>.</p><h3 id=purpose>Purpose
<a class=anchor href=#purpose>#</a></h3><p>A <em>purpose</em> combines a <em>role</em> and a usage <em>mode</em>:</p><ul><li>A <em>role</em> acts as a trust domain (e.g. the &ldquo;package&rdquo; <em>role</em> is used for signatures for package verification).</li><li>There are two <em>modes</em> in which <em>signature verifiers</em> can be stored in VOA:<ul><li>Verifiers used for direct artifact verification</li><li>Verifiers that serve as <em>trust anchors</em></li></ul></li></ul><p>A <em>role</em> and a <em>mode</em> in combination form a <em>purpose</em>.</p><p><em>Trust anchor</em> verifiers are always used to ascertain the validity of the associated <em>artifact verifiers</em> (e.g. <em>trust anchor</em> verifiers for the &ldquo;package&rdquo; <em>role</em> are used to validate the <em>artifact verifiers</em> for the &ldquo;package&rdquo; <em>role</em>).</p><p>To use <em>signature verifiers</em> in more than one <em>mode</em>
<a href=/specifications/#symlinking>symlinking</a> may be used.</p><h4 id=directory-naming>Directory naming
<a class=anchor href=#directory-naming>#</a></h4><p><em>Purpose</em> directories for direct <em>artifact verifiers</em> are named <code>$role</code> (e.g. <code>package</code>), while <em>trust anchors</em> are stored below directories named <code>trust-anchor-$role</code> (e.g. <code>trust-anchor-package</code>).</p><p>Note that <em>trust anchor</em> directory names always start with a &ldquo;trust-anchor-&rdquo; fragment.</p><p>Either two or one <em>purpose</em> directories may exist per <em>role</em>:</p><ul><li>One directory which contains <em>artifact verifiers</em> (e.g. <code>package</code>), and a second directory which contains the corresponding <em>trust anchors</em> (e.g. <code>trust-anchor-package</code>).</li><li>Just one directory which contains <em>artifact verifiers</em> (e.g. <code>package</code>).</li></ul><p>The <em>purpose</em> directory name must not contain characters outside of <code>0–9</code>, <code>a–z</code>, <code>"."</code>, <code>"_"</code> and <code>"-"</code>.
VOA implementations must not consider invalid directories and should raise a warning if such a directory is encountered.</p><h5 id=two-purpose-directories-verification-relying-on-trust-anchors>Two purpose directories: Verification relying on trust anchors
<a class=anchor href=#two-purpose-directories-verification-relying-on-trust-anchors>#</a></h5><p>For example, verifiers for the &ldquo;package&rdquo; <em>role</em> may be stored in two <em>purpose</em> directories:</p><ul><li><code>package</code> ("<em>artifact verifiers</em> of actors who are designated for package signing"), and</li><li><code>trust-anchor-package</code> ("<em>trust anchors</em> for <em>artifact verifiers</em> used for package signing")</li></ul><p>In this scenario, verification based on <em>trust anchors</em> is performed.</p><h5 id=one-purpose-directory-direct-verification>One purpose directory: Direct verification
<a class=anchor href=#one-purpose-directory-direct-verification>#</a></h5><p>In another example, verifiers for the &ldquo;image&rdquo; <em>role</em> may be stored in only one <em>purpose</em> directory:</p><ul><li><code>image</code> ("<em>artifact verifiers</em> of actors who are designated for OS image signing")</li></ul><p>In this scenario, only direct verification can be performed.</p><h4 id=roles-as-trust-domains>Roles as trust domains
<a class=anchor href=#roles-as-trust-domains>#</a></h4><p>Having distinct <em>roles</em> allows the use of separate sets of <em>signature verifiers</em> per role.
This is useful if different actors are expected to issue signatures for each <em>role</em>.
Thus, each <em>role</em> acts as a trust domain, e.g. the &ldquo;package&rdquo; <em>role</em> is used for signatures for packages, while the &ldquo;image&rdquo; <em>role</em> is used for signatures for OS images.
The work on each of the <em>roles</em> may be performed by different teams, using different verifiers.</p><h4 id=standard-roles>Standard roles
<a class=anchor href=#standard-roles>#</a></h4><p>The standard roles defined by the VOA specification are:</p><ul><li><strong>package</strong>: Verifying signatures for packages</li><li><strong>repository-metadata</strong>: Verifying signatures for repository metadata</li><li><strong>image</strong>: Verifying signatures for OS images</li></ul><p>The corresponding <em>purpose</em> directories are:</p><ul><li><code>package</code> and <code>trust-anchor-package</code></li><li><code>repository-metadata</code> and <code>trust-anchor-repository-metadata</code></li><li><code>image</code> and <code>trust-anchor-image</code></li></ul><p>The above list of standard roles can be extended by users of VOA.</p><p>For more in-depth explanation on the use of the <em>purpose</em> identifier, see the
<a href=/specifications/#examples>examples</a> section.</p><h3 id=context>Context
<a class=anchor href=#context>#</a></h3><p>The <strong>context</strong> identifier allows defining specific verifiers for a particular context within an
<a href=/specifications/#os>os</a>&rsquo;s
<a href=/specifications/#purpose>purpose</a>.</p><p>The <em>context</em> identifier allows modelling finer grained trust domains within a <em>purpose</em>.
This can be necessary if different actors are responsible for signing in subsets of a <em>purpose</em>.</p><p>Specific examples for <strong>context</strong> are</p><ul><li>the name of a specific software repository when certificates are used within the <strong>package</strong>
<a href=/specifications/#purpose>purpose</a> (e.g. <code>core</code> for a repository named &ldquo;core&rdquo;)</li><li>how an OS image is used within the <strong>image</strong>
<a href=/specifications/#purpose>purpose</a> (e.g. <code>installation-medium</code>, <code>virtual-machine</code>)</li></ul><p>If no specific context is required, the <strong>context</strong> directory <code>default</code> must be used.</p><p>Analogous to the os-release data, <strong>context</strong> strings may only contain <code>[a-z]</code>, <code>[0-9]</code>, <code>_</code>, <code>.</code> and <code>-</code>.</p><p>For more in-depth discussion on the use of the <em>context</em> identifier, see the
<a href=/specifications/#examples>examples</a> section.</p><h3 id=technology>Technology
<a class=anchor href=#technology>#</a></h3><p>The following sections outline specifics about the supported technologies.</p><p>In VOA, technology-specific backends implement the logic for each supported technology.
Different parties can implement different backends and this document outlines the approach, including the commonalities between all technology backends.</p><p>The details of verifier
<a href=/specifications/#load-logic>load logic</a> is defined per technology to leverage the individual features and strengths of each technology, while offering semantics that are closely shared between all VOA technologies.</p><p>Currently, only the OpenPGP technology is specified in detail.
Further specification work is required before implementing further technologies.</p><p>Each technology specifies file suffixes for verifiers.
Note that these suffixes may overlap.</p><p>A <em>technology</em> directory name must not contain characters outside of <code>0–9</code>, <code>a–z</code>, <code>"."</code>, <code>"_"</code> and <code>"-"</code>.
VOA implementations must not consider invalid directories and should raise a warning if such a directory is encountered.</p><h4 id=openpgp>OpenPGP
<a class=anchor href=#openpgp>#</a></h4><p><a href=https://openpgp.org>OpenPGP</a> is a widely adopted decentralized system for signature verification and user authentication.</p><p>This technology is named <code>openpgp</code> in the VOA structure.</p><p>Most Linux distributions use OpenPGP, often combined with <em>PGPKI</em> (aka.
<a href=https://openpgp.dev/book/signing_components.html#wot>Web of Trust (WoT)</a>), in which chains of trust are evaluated during signature validation.</p><p>OpenPGP has a rich model of validity, both for certificates and signatures.
Certificates can expire or be revoked by the key holder (via
<a href=https://openpgp.dev/book/certificates.html#revocations>OpenPGP certificate revocation</a>).
Similarly,
<a href=https://openpgp.dev/book/certificates.html#third-party-identity-certifications>third-party identity certifications</a> (as used in the <em>PGPKI</em>) can be revoked by their issuers (using
<a href=https://openpgp.dev/book/verification.html#revocations]>OpenPGP signature revocation</a>).</p><p>OpenPGP VOA backends are expected to handle validity.
In particular they should take expiration and revocation into account in all layers of the
<a href=/specifications/#hierarchy>VOA hierarchy</a>, by implementing
<a href=/specifications/#merging>merging</a> semantics.
For example, even if a revoked version of a certificate is overlaid by an unrevoked version, the revocation must be considered.</p><p>OpenPGP VOA backends implementations must offer appropriate facilities to calculate the validity of <em>artifact verifiers</em>.
This may include:</p><ul><li>specifying how many <em>trust anchors</em> are required to have valid paths to each <em>artifact verifier</em>,</li><li>limiting potentially accepted User IDs of <em>artifact verifiers</em> (e.g. by domain of the email address).</li></ul><p>In VOA, by convention, OpenPGP certificates must be stored in individual files and provided in ASCII armored form.</p><p>These files must be named by certificate fingerprint (in lowercase hex notation) with the file ending <code>.openpgp</code> (e.g. <code>d8afdda07a5b6edfa7d8ccdad6d055f927843f1c.openpgp</code>).</p><p>OpenPGP VOA backends must reject files where the certificate fingerprint of the file name does not match the actual fingerprint of the contained OpenPGP certificate&rsquo;s primary key and should emit a warning if such a file is encountered.</p><p>By default, in VOA, OpenPGP certificates that act as <em>trust anchors</em> are considered with a <em>trust amount</em> of 40 at a <em>trust depth</em> of 1.
More complex delegation setups are possible, but must be implemented using an application specific configuration mechanism.</p><h2 id=examples>Examples
<a class=anchor href=#examples>#</a></h2><p>The following examples provide an overview for several (hypothetical) scenarios in which VOA may be used.
For more details on valid components for
<a href=/specifications/#os>os</a> identifiers refer to the documentation of
<a href=https://man.archlinux.org/man/os-release.5.en>os-release</a>.</p><h3 id=package-manager-verifies-package-signatures-with-trust-anchor>Package manager verifies package signatures, with trust anchor
<a class=anchor href=#package-manager-verifies-package-signatures-with-trust-anchor>#</a></h3><p>In this example, we&rsquo;ll consider the use case of a package management software that uses VOA to verify the signature of a package file on a custom image-based Arch Linux OS.</p><p>The package manager issues a lookup for OpenPGP <em>signature verifiers</em> from VOA, based on two
<a href=/specifications/#os>os</a> strings: <code>arch:::cashier-system:1.0.0</code> and <code>arch</code>.</p><p>A VOA library will search in the
<a href=/specifications/#load-paths>load path</a> <code>/usr/share</code> - in our example the only location with verifier data - and consider both the <em>trust anchor</em> and the <em>artifact verifier</em> paths.
In our example, it will find the following verifier files for the <code>arch:::cashier-system:1.0.0</code> <em>os</em> string:</p><pre tabindex=0><code>/usr/share/voa/arch:::cashier-system:1.0.0/trust-anchor-package/default/openpgp/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33.openpgp
/usr/share/voa/arch:::cashier-system:1.0.0/package/default/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp
</code></pre><p>And additionally, the following verifier files for the <code>arch</code>
<a href=/specifications/#os>os</a> string:</p><pre tabindex=0><code>/usr/share/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp
</code></pre><p>The VOA library will also check for verifier files in the other layers, in our example, there is one additional verifier file in the <code>/etc</code> VOA layer:</p><pre tabindex=0><code>/etc/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp
</code></pre><p>Note that this verifier has the same filename as the one above, under <code>/usr/share/voa/</code>.
This signifies that both files contain information about the same <em>artifact verifier</em>.
If the contents of the files differ, the VOA library will calculate a merged view of both sources, consolidating all available information.
In this example, the OpenPGP certificate in <code>/usr/share/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp</code>, while the OpenPGP certificate in <code>/etc/voa/arch/package/default/openpgp/bbe960a25ea311d21d40669e93df2003ba9b90a2.openpgp</code> is not.
Due to
<a href=/specifications/#merging>merging</a> semantics, the OpenPGP certificate is considered revoked.</p><p>The VOA library has effectively found one <em>trust anchor</em> verifier file, and one valid <em>artifact verifier</em> file.
This means that package files will be verified using the one <em>artifact verifier</em> (<code>/usr/share/voa/arch:::cashier-system:1.0.0/package/default/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp</code>), which in turn is checked for validity based on the <em>trust anchor</em> verifier (<code>/usr/share/voa/arch:::cashier-system:1.0.0/trust-anchor-package/default/openpgp/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33.openpgp</code>).</p><h3 id=download-tool-verifies-installation-medium-without-trust-anchor>Download tool verifies installation medium, without trust anchor
<a class=anchor href=#download-tool-verifies-installation-medium-without-trust-anchor>#</a></h3><p>In this example, we&rsquo;ll consider the use case of a download tool that uses VOA to verify the signature of a Fedora 41 installation medium.</p><p>The download tool issues a lookup for OpenPGP verifiers from VOA, based on a single
<a href=/specifications/#os>os</a> string: <code>fedora:41</code>.
The tool is configured to perform validation with <em>artifact verifiers</em> (i.e. it specifies that it does not require the use of <em>trust anchors</em>).</p><p>A VOA library will search in the
<a href=/specifications/#load-paths>load path</a> <code>/usr/share/voa/</code> - in our example the only location with verifier data - and consider the basic verifier paths.
In our example, it will find the following verifier file for the <code>fedora:41</code> <em>os</em> string:</p><pre tabindex=0><code>/usr/share/voa/fedora:41/image/installation-medium/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp
</code></pre><p>The VOA library will also check for verifier files in the other layers, but in in this example, there are none.</p><p>The VOA library has found one <em>artifact verifier</em> file (<code>/usr/share/voa/fedora:41/image/installation-medium/openpgp/62cdb7020ff920e5aa642c3d4066950dd1f01f4d.openpgp</code>) and proceeds to use it to verify the installation medium file.</p><h2 id=considerations-for-implementers-and-users>Considerations for implementers and users
<a class=anchor href=#considerations-for-implementers-and-users>#</a></h2><h3 id=avoiding-duplication-of-data-in-the-directory-structure>Avoiding duplication of data in the directory structure
<a class=anchor href=#avoiding-duplication-of-data-in-the-directory-structure>#</a></h3><p>Symlinks are explicitly supported when forming VOA structures.
In many cases, it will be desirable to make heavy use of symlinks, to form the appropriate directory structures while avoiding duplication of data.
However, the
<a href=/specifications/#hierarchy>VOA hierarchy</a> is intended as a self-contained data structure that specifies how to authenticate signatures.
Therefore, symlinks in VOA should only point to other files or directories in any of the
<a href=/specifications/#hierarchy>VOA hierarchy</a> paths.
Symlinks may be relative or absolute.
Symlinking files external to the VOA structure is not permitted and should be ignored while raising a warning.</p><p>The use of hardlinks in the VOA structure is discouraged to prevent confusion.
However, VOA implementations are not required to check for the use of hardlinks.</p><h3 id=access-library-api-considerations>Access library API considerations
<a class=anchor href=#access-library-api-considerations>#</a></h3><p>As
<a href=/specifications/#os>os</a> strings are relatively complex, a VOA access library may offer convenient APIs for enumeration/searching of <em>os</em> directories (e.g. looking up a particular <em>os</em> in the set of available <em>os</em> strings, by searching by the <em>ID</em> part of the
<a href=https://man.archlinux.org/man/os-release.5.en>os-release</a> information).</p><h3 id=constraining-verifiers>Constraining verifiers
<a class=anchor href=#constraining-verifiers>#</a></h3><p>A VOA library may allow applications to set constraints on successful verification.</p><p>These constraints may include scenarios such as:</p><ul><li>an application may require that <em>trust anchors</em> must be present</li><li>an application may mandate the set of verifiers that must be present (either as <em>trust anchors</em>, or as <em>artifact verifiers</em>)</li></ul><h3 id=verifier-optimization>Verifier optimization
<a class=anchor href=#verifier-optimization>#</a></h3><p>When importing verifiers, a VOA library may support normalization operations on the verifier representation.
For example, OpenPGP decryption and authentication component keys may be dropped, as they are not needed in any VOA context.</p><h3 id=masking-verifiers>Masking verifiers
<a class=anchor href=#masking-verifiers>#</a></h3><p>The action of
<a href=/specifications/#masking>masking</a> <em>signature verifiers</em> should be able to distinguish between persistent and runtime directories (e.g. <code>/etc/voa/</code> and <code>/run/voa/</code>).
By default, persistent locations should be preferred over runtime ones.</p><h3 id=threshold-signing>Threshold signing
<a class=anchor href=#threshold-signing>#</a></h3><p>In some scenarios users of VOA may want to rely on verification schemes that require more than one valid digital signature for a given artifact.
These scenarios are explicitly not part of VOA, but may be implemented using dedicated configuration-based approaches per
<a href=/specifications/#technology>technology</a>.</p><h3 id=retrieval-of-signature-verifiers>Retrieval of signature verifiers
<a class=anchor href=#retrieval-of-signature-verifiers>#</a></h3><p>By default the <em>signature verifiers</em> found in VOA are usually either provided by vendor updates to the operating system (e.g. in <code>/usr/share/voa/</code>) or are created by system administrators (e.g. in <code>/etc/voa/</code>).</p><p>In certain scenarios, applications may want to retrieve additional or updated <em>signature verifiers</em> from locations outside of the VOA hierarchy.
These <em>signature verifiers</em> should be placed in ephemeral runtime directories (e.g. <code>/run/voa/</code>).</p><h3 id=validity-of-signatures>Validity of signatures
<a class=anchor href=#validity-of-signatures>#</a></h3><p>Each
<a href=/specifications/#technology>technology</a> may handle validity differently.
Generally, signature validity should be considered at the time of signature creation.
The <em>signature verifier</em> must be valid at creation time.
If the <em>signature verifier</em> has expired after signature creation, this does not impact signature validity.
Only in the case of revocations, that indicate a key material compromise, all signatures by the key in question should be considered invalid, regardless of creation time.</p><h4 id=use-of-time-stamp-authority>Use of Time Stamp Authority
<a class=anchor href=#use-of-time-stamp-authority>#</a></h4><p>VOA is mainly used for the verification of data signatures.
Often these signatures contain a claimed creation time.</p><p>Some technologies support the use of <em>Time Stamp Authorities</em> (e.g. based on the
<a href=https://en.wikipedia.org/wiki/Time_stamp_protocol>time stamp protocol</a>) to validate the creation time claims of signatures.
It is recommended to use timestamping services to validate signature creation time, where possible.
Details on how to use timestamping services are currently out of scope for this specification.</p><p>Extending the
<a href=/specifications/#purpose>purpose</a> scheme for verifiers used for timestamping purposes may be desired and is possible.
If the need arises, this specification should be extended accordingly.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/uapi-group/specifications/edit/main/specs/file_hierarchy_for_the_verification_of_os_artifacts.md target=_blank rel=noopener><img src=/specifications/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#terminology>Terminology</a><ul><li><a href=#revocation-of-verifiers>Revocation of verifiers</a></li><li><a href=#classification-of-signature-verification-models>Classification of signature verification models</a></li><li><a href=#application-of-signature-verification-models>Application of signature verification models</a></li><li><a href=#typical-distribution-format-of-verifers--short-vs-long-lived-keys>Typical distribution format of verifers / short vs. long-lived keys</a></li></ul></li><li><a href=#file-hierarchy>File Hierarchy</a><ul><li><a href=#load-paths>Load paths</a></li><li><a href=#symlinking>Symlinking</a></li><li><a href=#masking>Masking</a></li><li><a href=#load-logic>Load logic</a></li><li><a href=#future-compatibility>Future compatibility</a></li></ul></li><li><a href=#identifiers>Identifiers</a><ul><li><a href=#os>OS</a></li><li><a href=#purpose>Purpose</a></li><li><a href=#context>Context</a></li><li><a href=#technology>Technology</a></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#package-manager-verifies-package-signatures-with-trust-anchor>Package manager verifies package signatures, with trust anchor</a></li><li><a href=#download-tool-verifies-installation-medium-without-trust-anchor>Download tool verifies installation medium, without trust anchor</a></li></ul></li><li><a href=#considerations-for-implementers-and-users>Considerations for implementers and users</a><ul><li><a href=#avoiding-duplication-of-data-in-the-directory-structure>Avoiding duplication of data in the directory structure</a></li><li><a href=#access-library-api-considerations>Access library API considerations</a></li><li><a href=#constraining-verifiers>Constraining verifiers</a></li><li><a href=#verifier-optimization>Verifier optimization</a></li><li><a href=#masking-verifiers>Masking verifiers</a></li><li><a href=#threshold-signing>Threshold signing</a></li><li><a href=#retrieval-of-signature-verifiers>Retrieval of signature verifiers</a></li><li><a href=#validity-of-signatures>Validity of signatures</a></li></ul></li></ul></nav></div></aside></main></body></html>