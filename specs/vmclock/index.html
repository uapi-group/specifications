<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="UAPI.13 VMClock: Efficient Time Synchronisation for Virtual Machines# Version Changes 1.0 Initial Release The requirements for accurate synchronisation of application clocks against real wallclock time are becoming ever more demanding. Increasingly cloud providers are exposing precision clock devices to virtual machines to allow the guest operating systems to synchronise their clocks.
Time on modern systems is typically derived from a CPU-internal counter (TSC, timebase, arch counter) which runs at a nominally constant frequency of typically between 1GHz and 4GHz. In practice, the frequency of the underlying hardware counter will vary with environmental conditions, with a tolerance of the order of ±50PPM (parts per million). It is this variance which must constantly be corrected by synchronising against an external clock.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://uapi-group.org/specifications/specs/vmclock/"><meta property="og:site_name" content="UAPI Group Specifications"><meta property="og:title" content="UAPI.13 VMClock"><meta property="og:description" content="UAPI.13 VMClock: Efficient Time Synchronisation for Virtual Machines# Version Changes 1.0 Initial Release The requirements for accurate synchronisation of application clocks against real wallclock time are becoming ever more demanding. Increasingly cloud providers are exposing precision clock devices to virtual machines to allow the guest operating systems to synchronise their clocks.
Time on modern systems is typically derived from a CPU-internal counter (TSC, timebase, arch counter) which runs at a nominally constant frequency of typically between 1GHz and 4GHz. In practice, the frequency of the underlying hardware counter will vary with environmental conditions, with a tolerance of the order of ±50PPM (parts per million). It is this variance which must constantly be corrected by synchronising against an external clock."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="specs"><meta itemprop=name content="UAPI.13 VMClock"><meta itemprop=description content="UAPI.13 VMClock: Efficient Time Synchronisation for Virtual Machines# Version Changes 1.0 Initial Release The requirements for accurate synchronisation of application clocks against real wallclock time are becoming ever more demanding. Increasingly cloud providers are exposing precision clock devices to virtual machines to allow the guest operating systems to synchronise their clocks.
Time on modern systems is typically derived from a CPU-internal counter (TSC, timebase, arch counter) which runs at a nominally constant frequency of typically between 1GHz and 4GHz. In practice, the frequency of the underlying hardware counter will vary with environmental conditions, with a tolerance of the order of ±50PPM (parts per million). It is this variance which must constantly be corrected by synchronising against an external clock."><meta itemprop=wordCount content="2837"><title>UAPI.13 VMClock | UAPI Group Specifications</title><link rel=icon href=/specifications/favicon.png><link rel=manifest href=/specifications/manifest.json><link rel=canonical href=https://uapi-group.org/specifications/specs/vmclock/><link rel=stylesheet href=/specifications/book.min.6e0e4905af9f431e4a07d14b16ee4d5d1e90da19ad2b6d9d1d2aa2da9757473d.css integrity="sha256-bg5JBa+fQx5KB9FLFu5NXR6Q2hmtK22dHSqi2pdXRz0=" crossorigin=anonymous><script defer src=/specifications/fuse.min.js></script><script defer src=/specifications/en.search.min.be5215689e749d75b590d2a64f122aa0b6e9bbcae69b23f0189eac61dd217537.js integrity="sha256-vlIVaJ50nXW1kNKmTxIqoLbpu8rmmyPwGJ6sYd0hdTc=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-specs book-layout-default"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/specifications/><span>UAPI Group Specifications</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/>⬅️ Back to top</a></li></ul><ul><li><a>Specifications</a><ul><li><a href=/specifications/specs/boot_loader_specification/>UAPI.1 Boot Loader Specification</a></li><li><a href=/specifications/specs/discoverable_partitions_specification/>UAPI.2 Discoverable Partitions Specification</a></li><li><a href=/specifications/specs/discoverable_disk_image/>UAPI.3 Discoverable Disk Images</a></li><li><a href=/specifications/specs/extension_image/>UAPI.4 Extension Images</a></li><li><a href=/specifications/specs/unified_kernel_image/>UAPI.5 Unified Kernel Images</a></li><li><a href=/specifications/specs/configuration_files_specification/>UAPI.6 Configuration Files Specification</a></li><li><a href=/specifications/specs/linux_tpm_pcr_registry/>UAPI.7 Linux TPM PCR Registry</a></li><li><a href=/specifications/specs/package_metadata_for_executable_files/>UAPI.8 Package Metadata for Executable Files</a></li><li><a href=/specifications/specs/linux_file_system_hierarchy/>UAPI.9 Linux File System Hierarchy</a></li><li><a href=/specifications/specs/version_format_specification/>UAPI.10 Version Format Specification</a></li><li><a href=/specifications/specs/file_hierarchy_for_the_verification_of_os_artifacts/>UAPI.11 File Hierarchy for the Verification of OS Artifacts (VOA)</a></li><li><a href=/specifications/specs/elf_dlopen_metadata/>UAPI.12 dlopen() Metadata for ELF Files</a></li><li><a href=/specifications/specs/vmclock/ class=active>UAPI.13 VMClock</a></li><li><a href=/specifications/specs/vmgenid/>UAPI.14 VMGenID</a></li><li><a href=/specifications/specs/osc_context/>UAPI.15 OSC 3008: Hierarchical Context Signalling</a></li></ul></li></ul><ul><li><a href=https://github.com/uapi-group/specifications target=_blank rel=noopener>Collaborate on Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/specifications/icons/menu.svg class=book-icon alt=Menu></label><h3>UAPI.13 VMClock</h3><label for=toc-control><img src=/specifications/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#the-vmclock-device>The VMClock device</a></li><li><a href=#the-vmclock_abi-structure>The vmclock_abi structure</a><ul><li><a href=#structure-fields>Structure Fields</a></li><li><a href=#feature-flags-0x18>Feature Flags (0x18)</a></li><li><a href=#clock-status-0x22>Clock Status (0x22)</a></li><li><a href=#leap-second-smearing-hint-0x23>Leap Second Smearing Hint (0x23)</a></li><li><a href=#leap-indicator-0x26>Leap Indicator (0x26)</a></li><li><a href=#vm-generation-count-0x64>VM Generation Count (0x64)</a></li></ul></li><li><a href=#calculating-time>Calculating time</a></li><li><a href=#time-error-calculation>Time error calculation</a></li><li><a href=#discovery-via-acpi>Discovery via ACPI</a></li><li><a href=#discovery-via-device-tree>Discovery via Device Tree</a></li><li><a href=#hardware-implementation>Hardware implementation</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=uapi13-vmclock-efficient-time-synchronisation-for-virtual-machines>UAPI.13 VMClock: Efficient Time Synchronisation for Virtual Machines<a class=anchor href=#uapi13-vmclock-efficient-time-synchronisation-for-virtual-machines>#</a></h1><table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>1.0</td><td>Initial Release</td></tr></tbody></table><p>The requirements for accurate synchronisation of application clocks against
real wallclock time are becoming ever more demanding. Increasingly cloud
providers are exposing precision clock devices to virtual machines to allow the
guest operating systems to synchronise their clocks.</p><p>Time on modern systems is typically derived from a CPU-internal counter (<em>TSC,
timebase, arch counter</em>) which runs at a nominally constant frequency of
typically between 1GHz and 4GHz. In practice, the frequency of the underlying
hardware counter will vary with environmental conditions, with a tolerance of
the order of ±50PPM (parts per million). It is this variance which must constantly be corrected by
synchronising against an external clock.</p><p>Synchronisation against an external clock typically works by reading the CPU
counter, then reading the external clock, and finally reading the CPU counter
again — then assuming that the external clock reading was concurrent with a
point in time between the two CPU counter readings to give a pair of <code>{ CPU counter, real time }</code>
values. Successive such readings are used to calibrate the
precise rate at which the CPU counter is running, in order to use it for
precision timekeeping.</p><p>When applied at scale to virtual machines, there are a number of problems with
this approach. Firstly, where virtual CPUs are overcommitted across a smaller
number of physical CPUs in a host, guests experience &ldquo;steal time&rdquo; — time when
their vCPU is not actually running. That steal time is unpredictable and can
occur in the critical period between one read of the CPU counter and the next,
affecting the precision of the estimated reading.</p><p>A remedy for this issue is to repeat the reading a number of times, and to use
the result where the latency between first and last CPU counter reading is the
lowest. This exacerbates the second problem, that a large number of separate
guest operating systems on the same host are now repeating the same work of
calibrating the <em>same</em> underlying hardware oscillator.</p><p>The third major problem of guest-calibrated time is Live Migration, in which a
guest is transparently moved from one host to another for maintenance reasons.
When this happens, the guest can experience a step change in both the frequency
and the value of the CPU counter. The frequency because the migrated guest is
now using a different underlying counter, and the value because correctly
setting the counter value seen by the guest is dependent on the time
synchronisation of each hypervisor host. After a Live Migration, a guest&rsquo;s
clock should be considered inaccurate until it has been resynchronised from
scratch. Failure to do so can lead to data corruption, in cases where database
coherency depends on accurately timestamped transactions.</p><h2 id=the-vmclock-device>The VMClock device<a class=anchor href=#the-vmclock-device>#</a></h2><p>The VMClock device resolves the above issues by allowing the hypervisor to
synchronise the hardware clock against external time, and simply present the
results to each guest in a shared memory region in the form of a formula for
converting the CPU counter into real time. This allows guests to have precision
timestamps even immediately after a Live Migration event, and with no need to
provide further clock devices to the guest or for guests to spend their own CPU
time on calibration.</p><p>For guests which do perform their own additional refinement of the clock via
NTP or other means, a disruption signal is provided which allows them to
discard any such refinement after Live Migration, and start again with the data
from the new hypervisor host.</p><h2 id=the-vmclock_abi-structure>The vmclock_abi structure<a class=anchor href=#the-vmclock_abi-structure>#</a></h2><p>The hypervisor provides a structure in shared memory which is readable by the
guest, and advertises it via either ACPI or device-tree devices as described
below. Where possible, these fields and their values are aligned with the
definitions in the <a href=https://virtio-rtc>virtio-rtc</a> standard. As with virtio,
all fields are stored in little-endian form.</p><p>The fields up to and including <code>time_type</code> are constant and shall not change
during the lifetime of the device. The subsequent fields may be updated
dynamically, using <code>seq_count</code> as a synchronisation mechanism as follows:</p><ol><li>Increase <code>seq_count</code> to an odd value.</li><li>Update the remaining fields in the structure.</li><li>Increase <code>seq_count</code> again to an even value.</li><li>If <code>VMCLOCK_FLAG_NOTIFICATION_PRESENT</code> is set in the <code>flags</code> field, raise an interrupt or ACPI notification.</li></ol><p>If memory barriers are necessary to ensure that changes to the memory are
visible to the guest, they should be present at each stage. The total amount of
time during which <code>seq_count</code> remains at an odd value shall be short enough
that it is reasonable for a guest to <em>spin</em> while waiting for the update to
complete, as described below.</p><h3 id=structure-fields>Structure Fields<a class=anchor href=#structure-fields>#</a></h3><table><thead><tr><th>Offset</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td><code>uint32_t magic</code></td><td>Magic value <code>0x4b4c4356</code> (“VCLK”)</td></tr><tr><td>0x04</td><td><code>uint32_t size</code></td><td>Size of region containing this structure (typically a full page at
the granularity at which the hypervisor maps memory to the guest)</td></tr><tr><td>0x08</td><td><code>uint16_t version</code></td><td>This standard defines version 1. Since the <code>flags</code> field
allows for extensions to the data structure without breaking backward
compatibility, it is not anticipated that the <code>version</code> field
will ever need to change.</td></tr><tr><td>0x0a</td><td><code>uint8_t counter_id</code></td><td>The hardware counter used as the basis for clock readings. The
values of this field correspond to the
<code>VIRTIO_RTC_COUNTER_xxx</code> values:<ul><li><code>0x00</code>: <code>VMCLOCK_COUNTER_ARM_VCNT</code>: The Arm
architectural timer (virtual)</li><li><code>0x01</code>: <code>VMCLOCK_COUNTER_X86_TSC</code>: The x86
Time Stamp Counter</li><li><code>0xFF</code>: <code>VMCLOCK_COUNTER_INVALID</code>: No
precision clock is advertised</li></ul></td></tr><tr><td>0x0b</td><td><code>uint8_t time_type</code></td><td>Indicates the type of clock exposed through this interface. The
values of this field correspond to the <code>VIRTIO_RTC_CLOCK_xxx</code>
values, except that smearing of clocks is not supported as it is
antithetical to precision:<ul><li><code>0x00</code>: <code>VMCLOCK_TIME_UTC</code> <em>(Not
recommended)</em></li><li><code>0x01</code>: <code>VMCLOCK_TIME_TAI</code></li><li><code>0x02</code>: <code>VMCLOCK_MONOTONIC</code></li></ul>For UTC and TAI, the calculation results in a number of seconds
since midnight on 1970-01-01. A monotonic clock has no defined epoch.
Since UTC has leap seconds and a given numbered second may occur more
than once, its use is <strong>NOT RECOMMENDED</strong> in VMClock.
Implementations should advertise TAI, with a correct UTC offset.</td></tr><tr><td>0x0c</td><td><code>uint32_t seq_count</code></td><td>This field is used to provide a sequence-based read/write lock for
the non-constant fields which follow. To perform an update, the device
will:<ul><li>Increment this field to an odd value (with the low bit set)</li><li>Change other fields as appropriate.</li><li>Increment this field again to an even value.</li></ul></td></tr><tr><td>0x10</td><td><code>uint64_t disruption_marker</code></td><td>This field is changed each time there may be a disruption to the
hardware counter referenced by <code>counter_id</code>, for example
through live migration to a new hypervisor host.</td></tr><tr><td>0x18</td><td><code>uint64_t flags</code></td><td>Feature flags (see below)</td></tr><tr><td>0x20</td><td><code>uint16_t pad</code></td><td>Unused</td></tr><tr><td>0x22</td><td><code>uint8_t clock_status</code></td><td>Synchronisation status of the clock (see below)</td></tr><tr><td>0x23</td><td><code>uint8_t leap_second_smearing_hint</code></td><td>Smearing hint for guest OS (see below)</td></tr><tr><td>0x24</td><td><code>int16_t tai_offset_sec</code></td><td>Signed offset from TAI to UTC at the reference time specified in
<code>time_sec</code> and <code>time_frac_sec</code>, in seconds. Valid
if the corresponding bit in the flags field is set. Implementations
SHOULD populate this field; the value at time of writing is 37.</td></tr><tr><td>0x26</td><td><code>uint8_t leap_indicator</code></td><td>Indicates the presence and direction of a leap second occurring in
the near future or recent past (see below)</td></tr><tr><td>0x27</td><td><code>uint8_t counter_period_shift</code></td><td>Additional shift applied to all the
<code>counter_period*_frac_sec</code> fixed-point fields.</td></tr><tr><td>0x28</td><td><code>uint64_t counter_value</code></td><td>Value of the hardware counter at the time represented by
<code>time_sec</code> + <code>time_frac_sec</code>.</td></tr><tr><td>0x30</td><td><code>uint64_t counter_period_frac_sec</code></td><td>Period of a single counter tick, in units of 1 >> (64 +
<code>counter_period_shift</code>)</td></tr><tr><td>0x38</td><td><code>uint64_t counter_period_esterror_rate_frac_sec</code></td><td>Estimated ± error of <code>counter_period_frac_sec</code> in the
same units.</td></tr><tr><td>0x40</td><td><code>uint64_t counter_period_maxerror_rate_frac_sec</code></td><td>Maximum ± error of <code>counter_period_frac_sec</code> in the same
units.</td></tr><tr><td>0x48</td><td><code>uint64_t time_sec</code></td><td>Reference time point, seconds since epoch defined by
<code>time_type</code> field.</td></tr><tr><td>0x50</td><td><code>uint64_t time_frac_sec</code></td><td>Fractional part of reference time, in units of second / 2⁶⁴.</td></tr><tr><td>0x58</td><td><code>uint64_t time_esterror_nanosec</code></td><td>Estimated ± error of the time given in <code>time_sec</code> +
<code>time_frac_sec</code>, in nanoseconds</td></tr><tr><td>0x60</td><td><code>uint64_t time_maxerror_nanosec</code></td><td>Maximum ± error of the time given in <code>time_sec</code> +
<code>time_frac_sec</code>, in nanoseconds</td></tr><tr><td>0x64</td><td><code>uint64_t vm_generation_count</code></td><td>A change in this field indicates that the guest has been cloned or
loaded from a snapshot (see below).</td></tr><tr><td>0x68</td><td>…</td><td>The size of the memory region containing this structure is given in
the <code>size</code> field, which will typically be a full 4KiB page.
New fields may be added here, advertised by newly-defined bits in the
<code>flags</code> field, without changing the <code>version</code>
field.</td></tr></tbody></table><h3 id=feature-flags-0x18>Feature Flags (0x18)<a class=anchor href=#feature-flags-0x18>#</a></h3><table><thead><tr><th>Bit</th><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td><code>VMCLOCK_FLAG_TAI_OFFSET_VALID</code></td><td>Indicates that the <code>tai_offset</code> field below contains a correct value. All implementations SHOULD set this bit.</td></tr><tr><td>1</td><td><code>VMCLOCK_FLAG_DISRUPTION_SOON</code></td><td>Indicates that a clock disruption event (e.g. live migration) is expected to happen in the next day or so.</td></tr><tr><td>2</td><td><code>VMCLOCK_FLAG_DISRUPTION_IMMINENT</code></td><td>Indicates that a clock disruption event is expected to happen within the next hour or so.</td></tr><tr><td>3</td><td><code>VMCLOCK_FLAG_PERIOD_ESTERROR_VALID</code></td><td>Indicates that <code>counter_period_esterror_rate_frac_sec</code> contains valid data.</td></tr><tr><td>4</td><td><code>VMCLOCK_FLAG_PERIOD_MAXERROR_VALID</code></td><td>Indicates that <code>counter_period_maxerror_rate_frac_sec</code> contains valid data.</td></tr><tr><td>5</td><td><code>VMCLOCK_FLAG_TIME_ESTERROR_VALID</code></td><td>Indicates that <code>time_esterror_nanosec</code> contains valid data.</td></tr><tr><td>6</td><td><code>VMCLOCK_FLAG_TIME_MAXERROR_VALID</code></td><td>Indicates that <code>time_maxerror_nanosec</code> contains valid data.</td></tr><tr><td>7</td><td><code>VMCLOCK_FLAG_VM_GEN_COUNTER_PRESENT</code></td><td>Indicates that the <code>vm_generation_counter</code> field is present.</td></tr><tr><td>8</td><td><code>VMCLOCK_FLAG_NOTIFICATION_PRESENT</code></td><td>Indicates that the VMClock device will send an interrupt or ACPI notification every time it updates <code>seq_count</code> to a new even value.</td></tr></tbody></table><p>Unknown flags set by the device can safely be ignored. If a change in behaviour
is required by a future version of this specification, it would come with a new
value of the <code>version</code> field or a new <code>time_type</code> to avoid breaking
compatibility with existing users.</p><h3 id=clock-status-0x22>Clock Status (0x22)<a class=anchor href=#clock-status-0x22>#</a></h3><table><thead><tr><th>Value</th><th>Status</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td><code>VMCLOCK_STATUS_UNKNOWN</code></td><td>The clock is in an indeterminate state. Clock parameters in the VMClock structure are not valid and should not be relied upon.</td></tr><tr><td>0x01</td><td><code>VMCLOCK_STATUS_INITIALIZING</code></td><td>The clock is being initialized and is not yet synchronized. Clock parameters in the VMClock structure are not valid and should not be relied upon.</td></tr><tr><td>0x02</td><td><code>VMCLOCK_STATUS_SYNCHRONIZED</code></td><td>The clock is synchronized. Clock parameters in the VMClock structure are expected to be correct and may be relied upon.</td></tr><tr><td>0x03</td><td><code>VMCLOCK_STATUS_FREERUNNING</code></td><td>The clock has transitioned away from being synchronized and is in a free-running state. Clock parameters in the VMClock structure are expected to be valid and may be relied upon.</td></tr><tr><td>0x04</td><td><code>VMCLOCK_STATUS_UNRELIABLE</code></td><td>The clock is considered broken. Clock parameters in the VMClock structure should not be relied upon.</td></tr></tbody></table><h3 id=leap-second-smearing-hint-0x23>Leap Second Smearing Hint (0x23)<a class=anchor href=#leap-second-smearing-hint-0x23>#</a></h3><p>The time exposed through the VMClock device shall never be smeared. This field
corresponds to the <code>subtype</code> field in virtio-rtc, which indicates a smearing
method. In this case it merely provides a hint to the guest operating system,
such that if the guest OS wants to provide its users with an alternative clock
which does not follow UTC, it may do so in a fashion consistent with the other
systems in the nearby environment.</p><table><thead><tr><th>Value</th><th>Hint</th></tr></thead><tbody><tr><td>0x00</td><td><code>VMCLOCK_SMEARING_STRICT</code></td></tr><tr><td>0x01</td><td><code>VMCLOCK_SMEARING_NOON_LINEAR</code></td></tr><tr><td>0x02</td><td><code>VMCLOCK_SMEARING_UTC_SLS</code></td></tr></tbody></table><h3 id=leap-indicator-0x26>Leap Indicator (0x26)<a class=anchor href=#leap-indicator-0x26>#</a></h3><p>The value of this field shall be valid for the point in time referenced by the
<code>time_sec</code> and <code>time_frac_sec</code> fields.</p><table><thead><tr><th>Value</th><th>Indicator</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td><code>VMCLOCK_LEAP_NONE</code></td><td>No known nearby leap second</td></tr><tr><td>0x01</td><td><code>VMCLOCK_LEAP_PRE_POS</code></td><td>A positive leap second will occur at the end of the present month</td></tr><tr><td>0x02</td><td><code>VMCLOCK_LEAP_PRE_NEG</code></td><td>A negative leap second will occur at the end of the present month</td></tr><tr><td>0x03</td><td><code>VMCLOCK_LEAP_POS</code></td><td>A positive leap second is currently occurring (set during the 23:59:60 second)</td></tr><tr><td>0x04</td><td><code>VMCLOCK_LEAP_POST_POS</code></td><td>A positive leap second occurred at the end of the previous month</td></tr><tr><td>0x05</td><td><code>VMCLOCK_LEAP_POST_NEG</code></td><td>A negative leap second occurred at the end of the previous month</td></tr></tbody></table><h3 id=vm-generation-count-0x64>VM Generation Count (0x64)<a class=anchor href=#vm-generation-count-0x64>#</a></h3><p>This field indicates that the guest has been cloned or loaded from a snapshot. The operating system may wish to regenerate unique identifiers, reset network connections or reseed entropy, etc.</p><p>The conditions under which this counter changes are identical to those of the <a href=/specifications/specs/vmgenid/>VMGenID device</a>. The <code>vm_generation_count</code> changes whenever the VM is restored to an earlier or non-unique state:</p><ul><li>Snapshot restoration</li><li>Backup recovery</li><li>VM cloning/copying/import</li><li>Disaster recovery failover</li></ul><p>The <code>vm_generation_count</code> remains constant during normal VM operations:</p><ul><li>Pause/resume</li><li>Shutdown/restart/reboot</li><li>Host reboot or upgrade</li><li>Live migration or lossless online failover</li></ul><p>The <code>disruption_marker</code> and <code>vm_generation_count</code> fields indicate two orthogonal, but sometimes correlated, types of event. It is generally likely that the <code>disruption_marker</code> would also be changed when the <code>vm_generation_count</code> changes, but not necessarily vice versa.</p><p>It is possible that a VM could be cloned (forked) while running on the same host, such that the precision of the hardware counter is not lost, but the uniqueness is. That would be the rare case where the <code>vm_generation_count</code> would be changed but not the <code>disruption_marker</code>.</p><h2 id=calculating-time>Calculating time<a class=anchor href=#calculating-time>#</a></h2><p>The VMClock structure provides the following values:</p><ul><li>Reference time T₁ in the <code>time_sec</code> and <code>time_frac_sec</code> fields</li><li>Counter value C₁ of the hardware counter at time T₁ in the <code>counter_value</code> field.</li><li>The period P of a single counter tick is given by <code>counter_period_frac_sec</code> &#187; <code>counter_period_shift</code>.</li></ul><p>For example, a 1GHz clock would have a period of 1ns, which could naïvely be
represented as <code>0x44B82FA0A / 2⁶⁴</code> by putting that value in
<code>counter_period_frac_sec</code>. Over long periods of time, however, the loss of
precision would be noticeable. So the same 1ns period should be more precisely
represented as <code>0x89705F4136B4A597 / 2^(64+29)</code> by using that value in
<code>counter_period_frac_sec</code> and setting <code>counter_period_shift</code> to 29.</p><p>To calculate the time, the guest shall first read the <code>seq_count</code> field and
wait until it returns an even value, then read the hardware counter C_now and
calculate the time accordingly as <strong>T₁ + P(C_now - C₁)</strong>. Finally, read the
<code>seq_count</code> field again. If the value of the <code>seq_count</code> field has changed,
discard the result and repeat the procedure from the beginning.</p><p>Where UTC is involved, a correct implementation will need to cope with the case
where a leap second has occurred since the reference time T₁, and the result
needs to be adjusted accordingly. The <code>leap_indicator</code> field exists to resolve
the technical ambiguity but using TAI is simpler and less error prone. It is
strongly recommended that implementations use TAI as the time standard and
advertise a correct TAI offset, to avoid this complexity.</p><h2 id=time-error-calculation>Time error calculation<a class=anchor href=#time-error-calculation>#</a></h2><p>The VMClock structure optionally advertises maximum error bounds for the clock
data it provides, in the form of deltas to the T₁ and P values used above. The
true time is guaranteed to be within:</p><p><strong>T₁ ± T_maxerr + P ± P_maxerr(C_now - C₁)</strong></p><p>where T_maxerr and P_maxerr are the <code>time_maxerror_nanosec</code> and <code>counter_period_maxerror_rate_frac_sec</code> fields, respectively.</p><p>The device may update the time calibration fields at any time, by incrementing
the <code>seq_count</code> to an odd value, adjusting the parameters, then incrementing
<code>seq_count</code> again to an even value. For any given historical counter reading
and the error bounds calculated according to VMClock at that moment, it is
guaranteed that any <em>subsequent</em> update to the VMClock fields shall also result
in a calculation for that same counter value which falls between the earliest
and latest times that were previously indicated.</p><h2 id=discovery-via-acpi>Discovery via ACPI<a class=anchor href=#discovery-via-acpi>#</a></h2><p>To expose VMClock to the operating system via ACPI, the firmware or hypervisor must:</p><ol><li><p>Place the shared <code>vmclock_abi</code> structure somewhere in RAM, ROM or device memory space, which is guaranteed not to be used by the operating system. It must not be in ranges reported as <code>AddressRangeMemory</code> or <code>AddressRangeACPI</code>, and must not be in the same page as any memory which is expected to be mapped by a page table entry with caching disabled.</p></li><li><p>Expose a device somewhere in the ACPI namespace with:</p><ul><li>a hardware ID (<code>_HID</code>) of &ldquo;AMZNC10C&rdquo;</li><li>a DOS Device Name ID (<code>_DDN</code>) of &ldquo;VMCLOCK&rdquo;</li><li>a compatible ID (<code>_CID</code>) of &ldquo;VMCLOCK&rdquo;</li></ul></li><li><p>Attach to the device a &ldquo;<code>_CRS</code>&rdquo; method which when evaluated describes the shared memory page where the hypervisor has stored the <code>vmclock_abi</code> structure.</p></li><li><p>Optionally, the device can raise an ACPI Notify operation using notification code 0x80, every time the <code>seq_count</code> field changes to a new even number. If implemented, the hypervisor must advertise the notification feature to the driver by setting the <code>VMCLOCK_FLAG_NOTIFICATION_PRESENT</code> bit in the <code>flags</code> field.</p></li></ol><h2 id=discovery-via-device-tree>Discovery via Device Tree<a class=anchor href=#discovery-via-device-tree>#</a></h2><p>Similar to the ACPI binding above, the firmware or hypervisor must place the
<code>vmclock_abi</code> structure in an otherwise unused region of physical memory and
advertise its presence to the operating system. The Device Tree binding for the
<code>amazon,vmclock</code> node is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>%YAML 1.2</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>$id</span>: <span style=color:#ae81ff>http://devicetree.org/schemas/clock/amazon,vmclock.yaml#</span>
</span></span><span style=display:flex><span><span style=color:#f92672>$schema</span>: <span style=color:#ae81ff>http://devicetree.org/meta-schemas/core.yaml#</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>title</span>: <span style=color:#ae81ff>Virtual Machine Clock</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>maintainers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>description</span>:
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>The vmclock device provides a precise clock source and allows for</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>accurate timekeeping across live migration and snapshot/restore</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>operations. The full specification of the shared data structure</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>is available at https://david.woodhou.se/VMClock.pdf</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>properties</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>compatible</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>const</span>: <span style=color:#ae81ff>amazon,vmclock</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>reg</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>description</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>Specifies the shared memory region containing the vmclock_abi structure.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>maxItems</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>interrupts</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>description</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>Interrupt used to notify when the contents of the vmclock_abi structure</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>have been updated.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>maxItems</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>required</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>compatible</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>reg</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>additionalProperties</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>examples</span>:
</span></span><span style=display:flex><span>  - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    #include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    ptp@80000000 {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      compatible = &#34;amazon,vmclock&#34;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      reg = &lt;0x80000000 0x1000&gt;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      interrupts = &lt;GIC_SPI 36 IRQ_TYPE_EDGE_RISING&gt;;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    };</span></span></span></code></pre></div><h2 id=hardware-implementation>Hardware implementation<a class=anchor href=#hardware-implementation>#</a></h2><p>It is possible for a hardware implementation of VMClock to exist, in the
absence of a hypervisor or virtualization. Using mechanisms such as PCIe PTP, a
device could synchronise the CPU&rsquo;s counter directly against real time and
advertise the result to the operating system.</p><p>Such an implementation is outside the scope of this specification for now, but
only just. We may need to add a new option for the <code>counter_id</code> field which
references the hardware clock available to the PCIe device for PTM
synchronisation, for example the Intel Always Running Timer.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div><a class="flex align-center" href=https://github.com/uapi-group/specifications/edit/main/specs/vmclock.md target=_blank rel="noopener edit"><img src=/specifications/icons/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap justify-between"><span><a href=/specifications/specs/elf_dlopen_metadata/ class="flex align-center"><img src=/specifications/icons/backward.svg class=book-icon alt=Backward>
<span>UAPI.12 dlopen() Metadata for ELF Files</span>
</a></span><span><a href=/specifications/specs/vmgenid/ class="flex align-center"><span>UAPI.14 VMGenID</span>
<img src=/specifications/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#the-vmclock-device>The VMClock device</a></li><li><a href=#the-vmclock_abi-structure>The vmclock_abi structure</a><ul><li><a href=#structure-fields>Structure Fields</a></li><li><a href=#feature-flags-0x18>Feature Flags (0x18)</a></li><li><a href=#clock-status-0x22>Clock Status (0x22)</a></li><li><a href=#leap-second-smearing-hint-0x23>Leap Second Smearing Hint (0x23)</a></li><li><a href=#leap-indicator-0x26>Leap Indicator (0x26)</a></li><li><a href=#vm-generation-count-0x64>VM Generation Count (0x64)</a></li></ul></li><li><a href=#calculating-time>Calculating time</a></li><li><a href=#time-error-calculation>Time error calculation</a></li><li><a href=#discovery-via-acpi>Discovery via ACPI</a></li><li><a href=#discovery-via-device-tree>Discovery via Device Tree</a></li><li><a href=#hardware-implementation>Hardware implementation</a></li></ul></nav></div></aside></main></body></html>