"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/specifications/specs/sysext/",title:"Sysext",section:"Specs",content:`This content has moved to Extension Images
`}),e.add({id:1,href:"/specifications/specs/boot_loader_specification/",title:"Boot Loader Specification",section:"Specs",content:` The Boot Loader Specification # This document defines a set of file formats and naming conventions that allow the boot loader menu entries to be shared between multiple operating systems and boot loaders installed on one device.
Operating systems cooperatively manage boot loader menu entry directories that contain drop-in files, making multi-boot scenarios easy to support. Boot menu entries are defined via two simple formats that can be understood by different boot loader implementations, operating systems, and userspace programs. The same scheme can be used to prepare OS media for cases where the firmware includes a boot loader.
Target Audience # The target audience for this specification is:
Boot loader developers, to write a boot loader that directly reads its menu entries from these files Firmware developers, to add generic boot loading support directly to the firmware itself OS installer developers, to create appropriate partitions and set up the initial boot loader menu entries Distribution developers, to create appropriate menu entry snippets when installing or updating kernel packages UI developers, to implement user interfaces that list and select among the available boot options The Partitions # Everything described below is located on one or two partitions. The boot loader or user-space programs reading the boot loader menu entries should locate them in the following manner:
On disks with an MBR partition table:
The boot partition — a partition with the type ID of 0xEA — shall be used as the single location for boot loader menu entries. On disks with GPT (GUID Partition Table)
The EFI System Partition (ESP for short) — a partition with a GPT type GUID of c12a7328-f81f-11d2-ba4b-00a0c93ec93b — may be used as one of two locations for boot loader menu entries.
Optionally, an Extended Boot Loader Partition (XBOOTLDR partition for short) — a partition with GPT type GUID of bc13c2ff-59e6-4262-a352-b275fd6f7172 — may be used as the second of two locations for boot loader menu entries. This partition must be located on the same disk as the ESP.
Each partition type mentioned above can be present only once on the same disk.
Note: These partitions are shared among all OS installations on the same disk. Instead of maintaining one boot partition per installed OS (as /boot/ was traditionally handled), all installed OSes use the same place for boot loader menu entries.
For systems where the firmware is able to read file systems directly, the ESP must — and the MBR boot and GPT XBOOTLDR partition should — be a file system readable by the firmware. For most systems this means VFAT (16 or 32 bit). Applications accessing both partitions should hence not assume that fancier file system features such as symlinks, hardlinks, access control or case sensitivity are supported.
The \$BOOT Partition Placeholder # In the text below, the placeholder \$BOOT will be used to refer to the partition determined as follows:
On disks with an MBR partition table: → the boot partition, as described above
On disks with a GPT partition table: → the XBOOTLDR partition if it exists
Otherwise, on disks with a GPT partition table: → the ESP
\$BOOT is the primary place to put boot menu entry resources into, but typically not the only one. Most importantly, boot loaders should also pick up menu entries from the ESP, even if XBOOTLDR exists (for details see below).
Creating These Partitions # An installer for an operating system should use this logic when selecting or creating partitions:
If a boot partition (in case of MBR) or an XBOOTLDR partition (in case of GPT) already exists it should be used as \$BOOT and used as primary location to place boot loader menu resources in.
Otherwise, if on GPT and an ESP is found and it is large enough (let\u0026rsquo;s say at least 1G) it should be used as \$BOOT and used as primary location to place boot loader menu resources in.
Otherwise, if on GPT and neither XBOOTLDR nor ESP exist, an ESP should be created of the appropriate size and be used as \$BOOT, and used as primary location to place boot loader menu resources in.
Otherwise, a boot partition (in case of MBR) or XBOOTLDR partition (in case of GPT) should be created of an appropriate size, and be used as \$BOOT, and used as primary location to place boot loader menu resources in.
These partitions shall be determined during installation time, and /etc/fstab entries may be created.
Mount Points # It is recommended to mount \$BOOT (either XBOOTLDR or the ESP) to /boot/. If both XBOOTLDR and the ESP are present, the ESP should be mounted to /efi/.
Effectively, this means that /boot/ is the location where new boot entries shall be written to. For the boot loader itself, the situation is more complicated, because its files may be located under /boot/ or /efi/, depending on whether XBOOTLDR exists.
(Mounting the ESP to /boot/efi/, as was traditionally done, is not recommended. Such a nested setup complicates an implementation via direct autofs mounts — as implemented by systemd for example —, as establishing the inner autofs will trigger the outer one. Mounting the two partitions via autofs is recommended because the simple VFAT file system has weak data integrity properties and should remain unmounted whenever possible.)
Boot Loader Entries # This specification defines two types of boot loader entries. The first type is text based, very simple, and suitable for a variety of firmware, architecture and image types (\u0026ldquo;Type #1\u0026rdquo;). The second type is specific to EFI, but allows single-file images that embed all metadata in the kernel binary itself, which is useful to cryptographically sign them as one file for the purpose of SecureBoot (\u0026ldquo;Type #2\u0026rdquo;).
Not all boot loader entries will apply to all systems. For example, Type #1 entries that use the efi key and all Type #2 entries only apply to EFI systems. Entries using the architecture key might specify an architecture that doesn\u0026rsquo;t match the local one. Boot loaders should ignore all entries that don\u0026rsquo;t match the local platform and what the boot loader can support, and hide them from the user. Only entries matching the feature set of boot loader and system shall be considered and displayed. This allows image builders to put together images that transparently support multiple different architectures.
Note that the three partitions described above are not supposed to be the exclusive territory of this specification. This specification only defines semantics of the /loader/entries/ directory (along with the companion file /loader/entries.srel) and the /EFI/Linux/ directory inside the file system, but it doesn\u0026rsquo;t intend to define contents of the rest of the file system. Boot loaders, firmware, and other software implementing this specification may choose to place other files and directories in the same file system. For example, boot loaders that implement this specification might install their own boot code on the same partition; this is particularly common in the case of the ESP. Implementations of this specification must be able to operate correctly if files or directories other than /loader/entries/ and /EFI/Linux/ are found in the top level directory. Implementations that add their own files or directories to the file systems should use well-named directories, to make name collisions between multiple users of the file system unlikely.
Type #1 Boot Loader Specification Entries # /loader/entries/ in \$BOOT is the primary directory containing Type #1 drop-in snippets defining boot entries, one .conf file for each boot menu item. Each OS may provide one or more such entries.
If the ESP is separate from \$BOOT it may also contain a /loader/entries/ directory, where the boot loader should look for boot entry snippets, as an additional source. The boot loader should enumerate both directories and present a merged list to the user. Note that this is done for compatibility only: while boot loaders should look in both places, OSes should only add their files to \$BOOT.
Note: In all cases the /loader/entries/ directory should be located directly in the root of the ESP or XBOOTLDR filesystem. Specifically, the /loader/entries/ directory should not be located under the /EFI/ subdirectory on the ESP.
The file name of the boot entry snippets is used for identification of the boot item but shall never be presented to the user in the UI. The file name may be chosen freely but should be unique enough to avoid clashes between OS installations. More specifically, it is suggested to include the entry-token (see kernel-install) or machine ID (see /etc/machine-id), and the kernel version (as returned by uname -r, including the OS identifier), so that the whole filename is \$BOOT/loader/entries/\u0026lt;entry-token-or-machine-id\u0026gt;-\u0026lt;version\u0026gt;.conf.
Example: \$BOOT/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf.
In order to maximize compatibility with file system implementations and restricted boot loader environments, and to minimize conflicting character use with other programs, file names shall be chosen from a restricted character set: ASCII upper and lower case characters, digits, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;_\u0026rdquo; and \u0026ldquo;.\u0026rdquo;. Also, the file names should have a length of at least one and at most 255 characters (including the file name suffix).
These boot loader menu snippets shall be UNIX-style text files (i.e. lines separated by a single newline character), in the UTF-8 encoding. The boot loader menu snippets are loosely inspired by Grub1\u0026rsquo;s configuration syntax. Lines beginning with \u0026ldquo;#\u0026rdquo; are used for comments and shall be ignored. The first word of a line is used as key and is separated by one or more spaces from the value.
Type #1 Boot Loader Entry Keys # The following keys are recognized:
title is a human-readable title for this menu item to be displayed in the boot menu. It is a good idea to initialize this from the PRETTY_NAME= of os-release. This name should be descriptive and does not have to be unique. If a boot loader discovers two entries with the same title it should show more than just the raw title in the UI, for example by appending the version field. This field is optional.
Example: title Fedora 18 (Spherical Cow)
version is a human-readable version for this menu item. This is usually the kernel version and is intended for use by OSes to install multiple kernel versions with the same title field. This field is used for sorting entries, so that the boot loader can order entries by age or select the newest one automatically. This field is optional.
See Sorting below.
Example: version 3.7.2-201.fc18.x86_64
machine-id is the machine ID of the OS. This can be used by boot loaders and applications to filter out boot entries, for example to show only a single newest kernel per OS, to group items by OS, or to filter out the currently booted OS when showing only other installed operating systems. This ID shall be formatted as 32 lower case hexadecimal characters (i.e. without any UUID formatting). This key is optional.
Example: machine-id 4098b3f648d74c13b1f04ccfba7798e8
sort-key is a short string used for sorting entries on display. This should typically be initialized from the IMAGE_ID= or ID= fields of os-release, possibly with an additional suffix. This field is optional.
Example: sort-key fedora
linux is the Linux kernel image to execute and takes a path relative to the root of the file system containing the boot entry snippet itself. It is recommended that every distribution creates an entry-token/machine-id and version specific subdirectory and places its kernels and initrd images there (see below).
Example: linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux
initrd is the initrd cpio image to use when executing the kernel. This key may appear more than once in which case all specified images are used, in the order they are listed.
Example: initrd 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd
efi refers to an arbitrary EFI program. If this key is set, and the system is not an EFI system, this entry should be hidden.
options shall contain kernel parameters to pass to the Linux kernel to spawn. This key is optional and may appear more than once in which case all specified parameters are combined in the order they are listed.
Example: options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet
devicetree refers to the binary device tree to use when executing the kernel. This key is optional.
Example: devicetree 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.armv7hl/tegra20-paz00.dtb
devicetree-overlay refers to a list of device tree overlays that should be applied by the boot loader. Multiple overlays are separated by spaces and applied in the same order as they are listed. This key is optional but depends on the devicetree key.
Example: devicetree-overlay /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo
architecture refers to the architecture this entry is for. The argument should be an architecture identifier, using the architecture vocabulary defined by the EFI specification (i.e. IA32, x64, IA64, ARM, AA64, …). If specified and it does not match the local system architecture this entry should be hidden. The comparison should be done case-insensitively.
Example: architecture aa64
Each boot loader menu entry drop-in snippet must include at least a linux or an efi key. Here is an example for a complete drop-in file:
# /boot/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf title Fedora 19 (Rawhide) sort-key fedora machine-id 6a9857a393724b7a981ebb5b8495b9ea version 3.8.0-2.fc19.x86_64 options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet architecture x64 linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux initrd /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd On EFI systems all Linux kernel images should be EFI images. In order to increase compatibility with EFI systems it is highly recommended only to install EFI kernel images, even on non-EFI systems, if that\u0026rsquo;s applicable and supported on the specific architecture.
Conversely, in order to increase compatibility it is recommended to install generic kernel images that make few assumptions about the firmware they run on, i.e. it is a good idea that both images shipped as UEFI PE images and those which are not don\u0026rsquo;t make unnecessary assumption on the underlying firmware, i.e. don\u0026rsquo;t hard depend on legacy BIOS calls or UEFI boot services.
When Type #1 boot loader menu entry snippets refer to other files (for linux, initrd, efi, devicetree, and devicetree-overlay), those files must be located on the same partition, and the paths must be absolute paths relative to the root of that file system. The naming of those files can be chosen by the installer. A recommended scheme is described in the next section. Paths should be normalized, i.e. not include .., . or a sequence of more than one /. Paths may be prefixed with a /, but this is optional and has the same effect as paths without it: all paths are always relative to the root directory of the partition they are referenced from.
Even though the backing file system is typically case-insensitive (i.e. VFAT) it is strongly recommended to reference files in the casing actually used for the directories/files, so that placing these files on other file systems is still safe and robust.
Recommended Directory Layout for Additional Files # It is recommended to place the kernel and other other files comprising a single boot loader entry in a separate directory: /\u0026lt;entry-token-or-machine-id\u0026gt;/\u0026lt;version\u0026gt;/. This naming scheme uses the same elements as the boot loader menu entry snippet, providing the same level of uniqueness.
Example: \$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux \$BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd
Other naming schemes are possible. In particular, traditionally a flat naming scheme with files in the root directory was used. This is not recommended because it is hard to avoid conflicts in a multi-boot installation.
Standard-conformance Marker File # Unfortunately, there are implementations of boot loading infrastructure that are also using the /loader/entries/ directory, but install files that do not follow this specification. In order to minimize confusion, a boot loader implementation may place the file /loader/entries.srel next to the /loader/entries/ directory containing the ASCII string type1 (followed by a UNIX newline). Tools that need to determine whether an existing directory implements the semantics described here may check for this file and contents: if it exists and contains the mentioned string, it shall assume a standards-compliant implementation is in place. If it exists but contains a different string it shall assume other semantics are implemented. If the file does not exist, no assumptions should be made.
Type #2 EFI Unified Kernel Images # A unified kernel image is a single EFI PE executable combining an EFI stub loader, a kernel image, and possibly other, optional resources. See the UKI Specification for details. The primary place for such unified images is the /EFI/Linux/ directory in \$BOOT. Operating systems should place unified EFI kernels only in the \$BOOT partition. Boot loaders should also look in the /EFI/Linux/ of the ESP — if it is different from \$BOOT — and present a merged list of menu entries from both partitions. Regardless if placed in the primary or secondary location: the files must have the extension .efi. Support for images of this type is of course specific to systems with EFI firmware. Ignore this section if you work on systems not supporting EFI.
Type #2 file names should be chosen from the same restricted character set as Type #1 described above (but with the file name suffix of .efi instead of .conf).
Images of this type have the advantage that all metadata and payload that makes up the boot entry is contained in a single PE file that can be signed cryptographically as one for the purpose of EFI SecureBoot.
A valid unified kernel image in the /EFI/Linux/ directory must contain two PE sections:
.cmdline section with the kernel command line, .osrel section with an embedded copy of the os-release file describing the image. The PRETTY_NAME= and VERSION_ID= fields in the embedded os-release file are used the same as title and version in the Type #1 entries. The .cmdline section is used instead of the options field. linux and initrd fields are not necessary, and there is no counterpart for the machine-id field.
On EFI, any such images shall be added to the list of valid boot entries.
Additional Notes # Note that these boot entry snippets and unified kernels do not need to be the only menu entry sources for a boot loader. It may extend this list of entries with additional items from other configuration files (for example its own native configuration files) or automatically detected other entries without explicit configuration.
To make this explicitly clear: this specification is designed with \u0026ldquo;free\u0026rdquo; operating systems in mind, starting Windows or MacOS is out of focus with these boot loader menu entry snippets, use boot-loader specific solutions for that. In the text above, if we say \u0026ldquo;OS\u0026rdquo; we hence imply \u0026ldquo;free\u0026rdquo;, i.e. primarily Linux (though this could be easily be extended to the BSDs and whatnot).
Note that all paths used in the boot loader menu entry snippets use a Unix-style \u0026ldquo;/\u0026rdquo; as path separator. This needs to be converted to an EFI-style \u0026ldquo;\\\u0026rdquo; separator in EFI boot loaders.
Locating Boot Entries # A boot loader locates the XBOOTLDR partition and the ESP, then simply reads all the files /loader/entries/*.conf in them, and populates its boot menu (and handle gracefully if one of the two partitions is missing). On EFI, it then extends this with any unified kernel images found in /EFI/Linux/*.efi in the two partitions. It may also add additional entries, for example a \u0026ldquo;Reboot into firmware\u0026rdquo; option. Optionally it may sort the menu based on the sort-key, machine-id and version fields, and possibly others. It uses the file name to identify specific items, for example in case it supports storing away default entry information somewhere. A boot loader should generally not modify these files.
For \u0026ldquo;Boot Loader Specification Entries\u0026rdquo; (Type #1), the kernel package installer installs the kernel and initrd images to \$BOOT. It is recommended to place these files in a vendor and OS and installation specific directory. It then generates a boot loader menu entry snippet, placing it in \$BOOT/loader/entries/xyz.conf, with \u0026ldquo;xyz\u0026rdquo; as concatenation of entry-token/machine-id and version information (see above). The files created by a kernel package are tied to the kernel package and should be removed along with it.
For \u0026ldquo;EFI Unified Kernel Images\u0026rdquo; (Type #2), the vendor or kernel package installer should create the combined image and drop it into \$BOOT/EFI/Linux/. This file is also tied to the kernel package and should be removed along with it.
A UI application intended to show available boot options shall operate similarly to a boot loader (and thus search both \$BOOT and the ESP if distinct), but might apply additional filters, for example by filtering the booted OS via the machine ID, or by suppressing all but the newest kernel versions.
An OS installer picks the right place for \$BOOT as defined above (possibly creating a partition and file system for it) and creates the /loader/entries/ directory and the /loader/entries.srel file in it (the latter only if the directory didn\u0026rsquo;t exist yet). It then installs an appropriate boot loader that can read these snippets. Finally, it installs one or more kernel packages.
Boot counting # The main idea is that when boot entries are initially installed, they are marked as \u0026ldquo;indeterminate\u0026rdquo; and assigned a number of boot attempts. Each time the boot loader tries to boot an entry, it decreases this count by one. If the operating system considers the boot as successful, it removes the counter altogether and the entry becomes \u0026ldquo;good\u0026rdquo;. Otherwise, once the assigned number of boots is exhausted, the entry is marked as \u0026ldquo;bad\u0026rdquo;.
Which boots are \u0026ldquo;successful\u0026rdquo; is determined by the operating system. systemd provides a generic mechanism that can be extended with arbitrary checks and actions, see Automatic Boot Assessment, but the boot counting mechanism described in this specification can also be used with other implementations.
The boot counting data is stored in the name of the boot loader entry. A boot loader entry file name may contain a plus (+) followed by a number. This may optionally be followed by a minus (-) followed by a second number. The dot (.) and file name suffix (conf or efi) must immediately follow. Boot counting is enabled for entries which match this pattern.
The first number is the \u0026ldquo;tries left\u0026rdquo; counter signifying how many attempts to boot this entry shall still be made. The second number is the \u0026ldquo;tries done\u0026rdquo; counter, showing how many failed attempts to boot it have already been made. Each time a boot loader entry marked this way is booted, the first counter is decremented, and the second one incremented. (If the second counter is missing, then it is assumed to be equivalent to zero.) If the \u0026ldquo;tries left\u0026rdquo; counter is above zero the entry is still considered \u0026ldquo;indeterminate\u0026rdquo;. A boot entry with the \u0026ldquo;tries left\u0026rdquo; counter at zero is considered \u0026ldquo;bad\u0026rdquo;.
If the boot attempt completed successfully the entry\u0026rsquo;s counters are removed from the name (entry state becomes \u0026ldquo;good\u0026rdquo;), thus turning off boot counting for this entry.
Sorting # The boot loader menu should generally show entries in some order meaningful to the user. The title key is free-form and not suitable to be used as the primary sorting key. Instead, the boot loader should use the following rules:
Entries which are subject to boot counting and are marked as \u0026ldquo;bad\u0026rdquo;, should be sorted later than all other entries. Entries which are marked as \u0026ldquo;indeterminate\u0026rdquo; or \u0026ldquo;good\u0026rdquo; (or were not subject to boot counting at all), are thus sorted earlier.
If sort-key is set on both entries, use in order of priority, the sort-key (A-Z, increasing alphanumerical order), machine-id (A-Z, increasing alphanumerical order), and version keys (decreasing version order).
If sort-key is set on one entry, it sorts earlier.
At the end, if necessary, when sort-key is not set or those fields are not set or are all equal, the boot loader should sort using the file name of the entry (decreasing version sort), with the suffix removed.
Note: This description assumes that the boot loader shows entries in a traditional menu, with newest and \u0026ldquo;best\u0026rdquo; entries at the top, thus entries with a higher version number are sorter earlier. The boot loader is free to use a different direction (or none at all) during display.
Note: The boot loader should allow booting \u0026ldquo;bad\u0026rdquo; entries, e.g. in case no other entries are left or they are unusable for other reasons. It may deemphasize or hide such entries by default.
Note: \u0026ldquo;Bad\u0026rdquo; boot entries have a suffix of \u0026ldquo;+0-n\u0026rdquo;, where n is the number of failed boot attempts. Removal of the suffix is not necessary for comparisons described by the last point above. In the unlikely scenario that we have multiple such boot entries that differ only by the boot counting data, we would sort them by n.
Alphanumerical Order # Free-form strings and machine IDs should be compared using a method equivalent to strcmp(3) on their UTF-8 representations. If just one of the strings is unspecified or empty, it compares lower. If both strings are unspecified or empty, they compare equal.
Version Order # The version format and the comparison algorithm are defined in the Version Format Specification. A specific separator character between the version and other tokens in a string is not mandated by this specification, as it often depends on existing kernel packages which differ between distributions and packaging formats.
Additional discussion # Why is there a need for this specification? # This specification brings the following advantages:
Installation of new boot entries is more robust, as no explicit rewriting of configuration files is required.
It allows an out-of-the-box boot experience on any platform without the need of traditional firmware mechanisms (e.g. BIOS calls, UEFI Boot Services).
It improves dual-boot scenarios. Without cooperation, multiple Linux installations tend to fight over which boot loader becomes the primary one in possession of the MBR or the boot partition, and only that one installation can then update the boot loader configuration. Other Linux installs have to be manually configured to never touch the MBR and instead install a chain-loaded boot loader in their own partition headers. In this new scheme all installations share a loader directory and no manual configuration has to take place. All participants implicitly cooperate due to removal of name collisions and can install/remove their own boot menu entries without interfering with the entries of other installed operating systems.
Drop-in directories are now pretty ubiquitous on Linux as an easy way to extend boot loader menus without having to edit, regenerate or manipulate configuration files. For the sake of uniformity, we should do the same for the boot menu.
Userspace code can sanely parse boot loader menu entries which is essential with modern firmware which does not necessarily initialize USB keyboards during boot, which makes boot menus hard to reach for the user. If userspace code can parse the boot loader menu entries too, UI can be written that select a boot menu item to boot into before rebooting the machine, thus not requiring interactivity during early boot.
To unify and thus simplify menu entries of the various boot loaders, which makes configuration of the boot loading process easier for users, administrators, and developers alike.
For boot loaders with configuration scripts such as grub2, adopting this spec allows for mostly static scripts that are generated only once at first installation, but then do not need to be updated anymore as that is done via drop-in files exclusively.
Why not simply rely on the EFI boot menu logic? # EFI is not ubiquitous, especially not in embedded systems. But even on systems with EFI, which provides a boot options logic that can offer similar functionality, this specification is still needed for the following reasons:
The various EFI implementations implement the boot order/boot item logic to different levels. Some firmware implementations do not offer a boot menu at all and instead unconditionally follow the EFI boot order, booting the first item that is working.
If the firmware setup is used to reset data, usually all EFI boot entries are lost, making the system entirely unbootable, as the firmware setups generally do not offer a UI to define additional boot items. By placing the menu item information on disk, it is always available, even if the firmware configuration is lost.
Harddisk images should be movable between machines and be bootable without requiring firmware configuration. This also requires that the list of boot options is defined on disk, and not in EFI variables alone.
EFI is not universal yet (especially on non-x86 platforms), this specification is useful both for EFI and non-EFI boot loaders.
Many EFI systems disable USB support during early boot to optimize boot times, thus making keyboard input unavailable in the EFI menu. It is thus useful if the OS UI has a standardized way to discover available boot options which can be booted to.
Why is the version comparison logic so complicated? # The sort-key allows us to group entries by \u0026ldquo;operating system\u0026rdquo;, e.g. all versions of Fedora together, no matter if they identify themselves as \u0026ldquo;Fedora Workstation\u0026rdquo; or \u0026ldquo;Fedora Rawhide (prerelease)\u0026rdquo;. The sort-key was introduced only recently, so we need to provide a meaningful order for entries both with and without it. Since it is a new concept, it is assumed that entries with sort-key are newer.
In a traditional menu with entries displayed vertically, we want names to be sorter alpabetically (CentOS, Debian, Fedora, OpenSUSE, …), it would be strange to have them in reverse order. But when multiple kernels are available for the same installation, we want to display the latest kernel with highest priority, i.e. earlier in the list.
Why do you use file renames to store the counter? Why not a regular file? # Mainly two reasons: it\u0026rsquo;s relatively likely that renames can be implemented atomically even in simpler file systems, as renaming generally avoids allocating or releasing data blocks. Writing to file contents has a much bigger chance to be result in incomplete or corrupt data. Moreover renaming has the benefit that the boot count metadata is directly attached to the boot loader entry file, and thus the lifecycle of the metadata and the entry itself are bound together. This means no additional clean-up needs to take place to drop the boot loader counting information for an entry when it is removed.
Why not use EFI variables for storing the boot counter? # The memory chips used to back the persistent EFI variables are generally not of the highest quality, hence shouldn\u0026rsquo;t be written to more than necessary. This means we can\u0026rsquo;t really use it for changes made regularly during boot, but should use it only for seldom-made configuration changes.
Out of Focus # There are a couple of items that are out of focus for this specification:
If userspace can figure out the available boot options, then this is only useful so much: we\u0026rsquo;d still need to come up with a way how userspace could communicate to the boot loader the default boot loader entry temporarily or persistently. Defining a common scheme for this is certainly a good idea, but out of focus for this specification.
This specification is just about \u0026ldquo;Free\u0026rdquo; Operating systems. Hooking in other operating systems (like Windows and macOS) into the boot menu is a different story and should probably happen outside of this specification. For example, boot loaders might choose to detect other available OSes dynamically at runtime without explicit configuration (like systemd-boot does it), or via native configuration (for example via explicit Grub2 configuration generated once at installation).
This specification leaves undefined what to do about systems which are upgraded from an OS that does not implement this specification. As the previous boot loader logic was largely handled by in distribution-specific ways we probably should leave the upgrade path (and whether there actually is one) to the distributions. The simplest solution might be to simply continue with the old scheme for old installations and use this new scheme only for new installations.
Referencing kernels or initrds on other partitions other than the partition containing the Type #1 boot loader entry. This is by design, as specifying other partitions or devices would require a non-trivial language for denoting device paths. In particular this means that on non-EFI systems boot loader menu entry snippets following this specification cannot be used to spawn other operating systems (such as Windows).
Links # GUID Partition Table
Boot Loader Interface
Discoverable Partitions Specification
systemd-boot(7)
bootctl(1)
systemd-gpt-auto-generator(8)
`}),e.add({id:2,href:"/specifications/specs/configuration_files_specification/",title:"Configuration Files Specification",section:"Specs",content:` Configuration Files Specification # Introduction # Various specifications attempt to define configuration files and file formats. This specification establishes where these files should be looked for, in which order, and how precedence, masking, extensions and overrides work.
The purpose of the rules defined here is to allow OS vendors to implement the hermetic-usr pattern, where all vendor files are shipped in the vendor tree itself (/usr/), including configuration files with system defaults, while allowing local or vendor overrides without modifying the original files, for easier management. This is especially beneficial for image-based deployments, where the vendor tree is read-only.
These rules are derived from existing real-world usage from the systemd project and the libeconf project. It is highly recommended to use libeconf, which is readily available and maintained in all major distributions, rather than reimplementing this specification locally.
This specification is agnostic toward the actual format and content of the configuration files, the precise path used under each top-level hierarchy, and also toward the filenames and extensions, with the exception of the .d/ notation for drop-ins directories. It is strongly encouraged to enforce a specific suffix for the configuration files, in order to disambiguate (e.g.: with backup files), but the choice of which suffix to use is left to each implementation.
Storage Directories and Overrides # In order to allow shipping system defaults owned by the OS vendor, while at the same time letting local users or admins override those defaults, /usr/ and /etc/ are both supported for storage of configuration files, with the latter having higher priority. The precise location under /usr/ is left open for the implementation to decide - it could be hard-coded to /usr/lib/ or it could be left to each application to pick from various options, such as /usr/share/ or /usr/etc/. Programs must work correctly if no configuration files are found in /etc/. Optionally, /run/ is also supported for ephemeral overrides.
For example, /usr/lib/foo/bar.conf provides the default configuration file. If /run/foo/bar.conf is present and supported, it would take precedence over /usr/lib/foo/bar.conf. Finally, a user can create /etc/foo/bar.conf which would take precedence and completely override both.
Masking # As a special override case, it must be possible to mask files across different locations by creating a symlink to /dev/null or an empty file.
For example, an empty /etc/foo/bar.conf means that /usr/lib/foo/bar.conf is masked and thus not parsed.
Drop-ins # All configuration paths must support drop-ins, except for configuration file formats where automatic combining of multiple files is not feasible, for example scripts or structured documents. Supporting drop-ins means that in addition to parsing a full configuration file, an implementation also parses the drop-in files in the drop-in directories associated with it.
Drop-ins always have higher precedence than the configuration file they refer to. Drop-ins are sorted in the lexicographic order using the file name without the path, regardless of the hierarchy under which they are stored. The drop-ins that are later in this order have higher precedence.
Considering the following files are present on the filesystem, this would be the order in which the files are parsed. Note, that files with the same name override each other. The configuration in bar.conf has the lowest priority, and is read before a.conf and b.conf. b.conf has the highest priority:
/usr/lib/foo/bar.conf (overridden by /etc/foo/bar.conf) /etc/foo/bar.conf /usr/lib/foo/bar.conf.d/a.conf (overridden by /etc/foo/bar.conf.d/a.conf) /etc/foo/bar.conf.d/a.conf /usr/lib/foo/bar.conf.d/b.conf If a config file is masked, drop-ins must still be parsed, unless they are masked themselves.
For example, even if /usr/lib/foo/bar.conf is masked by an empty /etc/foo/bar.conf, /usr/lib/foo/bar.conf.d/a.conf must still be parsed and applied, unless there is also an empty /etc/foo/bar.conf.d/a.conf, in which case the drop-in is masked too.
Drop-ins are not recursive, so a drop-in cannot have a directory of drop-ins.
For example, /etc/foo/bar.conf.d/a.conf cannot be overridden by /etc/foo/bar.conf.d/a.conf.d/b.conf, and the latter must be ignored if it exists.
Drop-ins without Main Configuration File # Optionally, schemes with only drop-ins, without a \u0026lsquo;main\u0026rsquo; configuration file, should also be supported by implementations. In such schemes many drop-ins are loaded from a common directory in each hierarchy.
For example, /usr/lib/foo.d/a.conf, /usr/lib/foo.d/b.conf and /etc/foo.d/c.conf are all loaded and parsed in this scheme, in this order.
`}),e.add({id:3,href:"/specifications/specs/discoverable_disk_image/",title:"Discoverable Disk Image",section:"Specs",content:` Discoverable Disk Image (DDI) # DDIs (Discoverable Disk Images) are self-describing file system images that follow the DPS ( Discoverable Partitions Specification), wrapped in a GPT partition table, that may contain root (or /usr/) filesystems for bootable OS images, system extensions, configuration extensions, portable services, containers and more, and shall be protected by signed dm-verity all combined into one. They are designed to be composable and stackable, and provide security by default.
Image Format # The images use the GPT partition table verbatim, so it will not be redefined here. Each partition contains a standard Linux filesystem (e.g.: erofs), so again this will not be redefined here. The DPS defines the GUIDs to use and the format of the dm-verity signature partition\u0026rsquo;s JSON content.
It is recommended to use a sector size of 512 bytes or 4096 for DDIs. Software operating with DDIs should automatically derive the sector size used for a DDI by looking for the EFI PART magic string at offsets 512 or 4096, as per GPT specification.
Naming # DDIs should use .raw as file suffix. A secondary suffix may be used to clarify the specific usage class of a DDI. For now the two secondary suffixes .sysext.raw and .confext.raw are defined (for system extension DDIs and configuration extension DDIs, see Extension Images for details).
The MIME type for DDIs is application/vnd.efi.img, as per IANA.
Image Version # If the DDI is versioned, the version format described in the Version Format Specification must be used. The underscore character (_) must be used to separate the version from the name of the image. For example: foo_1.2.raw denotes a foo DDI with version 1.2.
`}),e.add({id:4,href:"/specifications/specs/discoverable_partitions_specification/",title:"Discoverable Partitions Specification",section:"Specs",content:` The Discoverable Partitions Specification (DPS) # TL;DR: Let\u0026rsquo;s automatically discover, mount and enable the root partition, /home/, /srv/, /var/ and /var/tmp/ and the swap partitions based on GUID Partition Tables (GPT)!
This specification describes the use of GUID Partition Table (GPT) UUIDs to enable automatic discovery of partitions and their intended mountpoints. Traditionally Linux has made little use of partition types, mostly just defining one UUID for file system/data partitions and another one for swap partitions. With this specification, we introduce additional partition types for specific uses. This has many benefits:
OS installers can automatically discover and make sense of partitions of existing Linux installations. The OS can discover and mount the necessary file systems with a non-existent or incomplete /etc/fstab file and without the root= kernel command line option. Container managers (such as nspawn and libvirt-lxc) can introspect and set up file systems contained in GPT disk images automatically and mount them to the right places, thus allowing booting the same, identical images on bare metal and in Linux containers. This enables true, natural portability of disk images between physical machines and Linux containers. As a help to administrators and users partition manager tools can show more descriptive information about partitions tables. Note that the OS side of this specification is currently implemented in systemd 211 and newer in the systemd-gpt-auto-generator(8) generator tool. Note that automatic discovery of the root only works if the boot loader communicates this information to the OS, by implementing the Boot Loader Interface.
Defined Partition Type UUIDs # Name Partition Type UUID Allowed File Systems Explanation Root Partition (Alpha) 6523f8ae-3eb1-4e2a-a05a-18b695ae656f SD_GPT_ROOT_ALPHA Any native, optionally in LUKS On systems with matching architecture, the first partition with this type UUID on the disk containing the active EFI ESP is automatically mounted to the root directory /. If the partition is encrypted with LUKS or has dm-verity integrity data (see below), the device mapper file will be named /dev/mapper/root. Root Partition (ARC) d27f46ed-2919-4cb8-bd25-9531f3c16534 SD_GPT_ROOT_ARC ditto ditto Root Partition (32-bit ARM) 69dad710-2ce4-4e3c-b16c-21a1d49abed3 SD_GPT_ROOT_ARM ditto ditto Root Partition (64-bit ARM/AArch64) b921b045-1df0-41c3-af44-4c6f280d3fae SD_GPT_ROOT_ARM64 ditto ditto Root Partition (Itanium/IA-64) 993d8d3d-f80e-4225-855a-9daf8ed7ea97 SD_GPT_ROOT_IA64 ditto ditto Root Partition (LoongArch 64-bit) 77055800-792c-4f94-b39a-98c91b762bb6 SD_GPT_ROOT_LOONGARCH64 ditto ditto Root Partition (32-bit MIPS BigEndian (mips)) e9434544-6e2c-47cc-bae2-12d6deafb44c ditto ditto Root Partition (64-bit MIPS BigEndian (mips64)) d113af76-80ef-41b4-bdb6-0cff4d3d4a25 ditto ditto Root Partition (32-bit MIPS LittleEndian (mipsel)) 37c58c8a-d913-4156-a25f-48b1b64e07f0 SD_GPT_ROOT_MIPS_LE ditto ditto Root Partition (64-bit MIPS LittleEndian (mips64el)) 700bda43-7a34-4507-b179-eeb93d7a7ca3 SD_GPT_ROOT_MIPS64_LE ditto ditto Root Partition (HPPA/PARISC) 1aacdb3b-5444-4138-bd9e-e5c2239b2346 SD_GPT_ROOT_PARISC ditto ditto Root Partition (32-bit PowerPC) 1de3f1ef-fa98-47b5-8dcd-4a860a654d78 SD_GPT_ROOT_PPC ditto ditto Root Partition (64-bit PowerPC BigEndian) 912ade1d-a839-4913-8964-a10eee08fbd2 SD_GPT_ROOT_PPC64 ditto ditto Root Partition (64-bit PowerPC LittleEndian) c31c45e6-3f39-412e-80fb-4809c4980599 SD_GPT_ROOT_PPC64_LE ditto ditto Root Partition (RISC-V 32-bit) 60d5a7fe-8e7d-435c-b714-3dd8162144e1 SD_GPT_ROOT_RISCV32 ditto ditto Root Partition (RISC-V 64-bit) 72ec70a6-cf74-40e6-bd49-4bda08e8f224 SD_GPT_ROOT_RISCV64 ditto ditto Root Partition (s390) 08a7acea-624c-4a20-91e8-6e0fa67d23f9 SD_GPT_ROOT_S390 ditto ditto Root Partition (s390x) 5eead9a9-fe09-4a1e-a1d7-520d00531306 SD_GPT_ROOT_S390X ditto ditto Root Partition (TILE-Gx) c50cdd70-3862-4cc3-90e1-809a8c93ee2c SD_GPT_ROOT_TILEGX ditto ditto Root Partition (x86) 44479540-f297-41b2-9af7-d131d5f0458a SD_GPT_ROOT_X86 ditto ditto Root Partition (amd64/x86_64) 4f68bce3-e8cd-4db1-96e7-fbcaf984b709 SD_GPT_ROOT_X86_64 ditto ditto /usr/ Partition (Alpha) e18cf08c-33ec-4c0d-8246-c6c6fb3da024 SD_GPT_USR_ALPHA Any native, optionally in LUKS Similar semantics to root partition, but just the /usr/ partition. /usr/ Partition (ARC) 7978a683-6316-4922-bbee-38bff5a2fecc SD_GPT_USR_ARC ditto ditto /usr/ Partition (32-bit ARM) 7d0359a3-02b3-4f0a-865c-654403e70625 SD_GPT_USR_ARM ditto ditto /usr/ Partition (64-bit ARM/AArch64) b0e01050-ee5f-4390-949a-9101b17104e9 SD_GPT_USR_ARM64 ditto ditto /usr/ Partition (Itanium/IA-64) 4301d2a6-4e3b-4b2a-bb94-9e0b2c4225ea SD_GPT_USR_IA64 ditto ditto /usr/ Partition (LoongArch 64-bit) e611c702-575c-4cbe-9a46-434fa0bf7e3f SD_GPT_USR_LOONGARCH64 ditto ditto /usr/ Partition (32-bit MIPS BigEndian (mips)) 773b2abc-2a99-4398-8bf5-03baac40d02b ditto ditto /usr/ Partition (64-bit MIPS BigEndian (mips64)) 57e13958-7331-4365-8e6e-35eeee17c61b ditto ditto /usr/ Partition (32-bit MIPS LittleEndian (mipsel)) 0f4868e9-9952-4706-979f-3ed3a473e947 SD_GPT_USR_MIPS_LE ditto ditto /usr/ Partition (64-bit MIPS LittleEndian (mips64el)) c97c1f32-ba06-40b4-9f22-236061b08aa8 SD_GPT_USR_MIPS64_LE ditto ditto /usr/ Partition (HPPA/PARISC) dc4a4480-6917-4262-a4ec-db9384949f25 SD_GPT_USR_PARISC ditto ditto /usr/ Partition (32-bit PowerPC) 7d14fec5-cc71-415d-9d6c-06bf0b3c3eaf SD_GPT_USR_PPC ditto ditto /usr/ Partition (64-bit PowerPC BigEndian) 2c9739e2-f068-46b3-9fd0-01c5a9afbcca SD_GPT_USR_PPC64 ditto ditto /usr/ Partition (64-bit PowerPC LittleEndian) 15bb03af-77e7-4d4a-b12b-c0d084f7491c SD_GPT_USR_PPC64_LE ditto ditto /usr/ Partition (RISC-V 32-bit) b933fb22-5c3f-4f91-af90-e2bb0fa50702 SD_GPT_USR_RISCV32 ditto ditto /usr/ Partition (RISC-V 64-bit) beaec34b-8442-439b-a40b-984381ed097d SD_GPT_USR_RISCV64 ditto ditto /usr/ Partition (s390) cd0f869b-d0fb-4ca0-b141-9ea87cc78d66 SD_GPT_USR_S390 ditto ditto /usr/ Partition (s390x) 8a4f5770-50aa-4ed3-874a-99b710db6fea SD_GPT_USR_S390X ditto ditto /usr/ Partition (TILE-Gx) 55497029-c7c1-44cc-aa39-815ed1558630 SD_GPT_USR_TILEGX ditto ditto /usr/ Partition (x86) 75250d76-8cc6-458e-bd66-bd47cc81a812 SD_GPT_USR_X86 ditto ditto /usr/ Partition (amd64/x86_64) 8484680c-9521-48c6-9c11-b0720656f69e SD_GPT_USR_X86_64 ditto ditto Root Verity Partition (Alpha) fc56d9e9-e6e5-4c06-be32-e74407ce09a5 SD_GPT_ROOT_ALPHA_VERITY A dm-verity superblock followed by hash data Contains dm-verity integrity hash data for the matching root partition. If this feature is used the partition UUID of the root partition should be the first 128 bits of the root hash of the dm-verity hash data, and the partition UUID of this dm-verity partition should be the final 128 bits of it, so that the root partition and its Verity partition can be discovered easily, simply by specifying the root hash. Root Verity Partition (ARC) 24b2d975-0f97-4521-afa1-cd531e421b8d SD_GPT_ROOT_ARC_VERITY ditto ditto Root Verity Partition (32-bit ARM) 7386cdf2-203c-47a9-a498-f2ecce45a2d6 SD_GPT_ROOT_ARM_VERITY ditto ditto Root Verity Partition (64-bit ARM/AArch64) df3300ce-d69f-4c92-978c-9bfb0f38d820 SD_GPT_ROOT_ARM64_VERITY ditto ditto Root Verity Partition (Itanium/IA-64) 86ed10d5-b607-45bb-8957-d350f23d0571 SD_GPT_ROOT_IA64_VERITY ditto ditto Root Verity Partition (LoongArch 64-bit) f3393b22-e9af-4613-a948-9d3bfbd0c535 SD_GPT_ROOT_LOONGARCH64_VERITY ditto ditto Root Verity Partition (32-bit MIPS BigEndian (mips)) 7a430799-f711-4c7e-8e5b-1d685bd48607 ditto ditto Root Verity Partition (64-bit MIPS BigEndian (mips64)) 579536f8-6a33-4055-a95a-df2d5e2c42a8 ditto ditto Root Verity Partition (32-bit MIPS LittleEndian (mipsel)) d7d150d2-2a04-4a33-8f12-16651205ff7b SD_GPT_ROOT_MIPS_LE_VERITY ditto ditto Root Verity Partition (64-bit MIPS LittleEndian (mips64el)) 16b417f8-3e06-4f57-8dd2-9b5232f41aa6 SD_GPT_ROOT_MIPS64_LE_VERITY ditto ditto Root Verity Partition (HPPA/PARISC) d212a430-fbc5-49f9-a983-a7feef2b8d0e SD_GPT_ROOT_PARISC_VERITY ditto ditto Root Verity Partition (64-bit PowerPC LittleEndian) 906bd944-4589-4aae-a4e4-dd983917446a SD_GPT_ROOT_PPC64_LE_VERITY ditto ditto Root Verity Partition (64-bit PowerPC BigEndian) 9225a9a3-3c19-4d89-b4f6-eeff88f17631 SD_GPT_ROOT_PPC64_VERITY ditto ditto Root Verity Partition (32-bit PowerPC) 98cfe649-1588-46dc-b2f0-add147424925 SD_GPT_ROOT_PPC_VERITY ditto ditto Root Verity Partition (RISC-V 32-bit) ae0253be-1167-4007-ac68-43926c14c5de SD_GPT_ROOT_RISCV32_VERITY ditto ditto Root Verity Partition (RISC-V 64-bit) b6ed5582-440b-4209-b8da-5ff7c419ea3d SD_GPT_ROOT_RISCV64_VERITY ditto ditto Root Verity Partition (s390) 7ac63b47-b25c-463b-8df8-b4a94e6c90e1 SD_GPT_ROOT_S390_VERITY ditto ditto Root Verity Partition (s390x) b325bfbe-c7be-4ab8-8357-139e652d2f6b SD_GPT_ROOT_S390X_VERITY ditto ditto Root Verity Partition (TILE-Gx) 966061ec-28e4-4b2e-b4a5-1f0a825a1d84 SD_GPT_ROOT_TILEGX_VERITY ditto ditto Root Verity Partition (amd64/x86_64) 2c7357ed-ebd2-46d9-aec1-23d437ec2bf5 SD_GPT_ROOT_X86_64_VERITY ditto ditto Root Verity Partition (x86) d13c5d3b-b5d1-422a-b29f-9454fdc89d76 SD_GPT_ROOT_X86_VERITY ditto ditto /usr/ Verity Partition (Alpha) 8cce0d25-c0d0-4a44-bd87-46331bf1df67 SD_GPT_USR_ALPHA_VERITY A dm-verity superblock followed by hash data Similar semantics to root Verity partition, but just for the /usr/ partition. /usr/ Verity Partition (ARC) fca0598c-d880-4591-8c16-4eda05c7347c SD_GPT_USR_ARC_VERITY ditto ditto /usr/ Verity Partition (32-bit ARM) c215d751-7bcd-4649-be90-6627490a4c05 SD_GPT_USR_ARM_VERITY ditto ditto /usr/ Verity Partition (64-bit ARM/AArch64) 6e11a4e7-fbca-4ded-b9e9-e1a512bb664e SD_GPT_USR_ARM64_VERITY ditto ditto /usr/ Verity Partition (Itanium/IA-64) 6a491e03-3be7-4545-8e38-83320e0ea880 SD_GPT_USR_IA64_VERITY ditto ditto /usr/ Verity Partition (LoongArch 64-bit) f46b2c26-59ae-48f0-9106-c50ed47f673d SD_GPT_USR_LOONGARCH64_VERITY ditto ditto /usr/ Verity Partition (32-bit MIPS BigEndian (mips)) 6e5a1bc8-d223-49b7-bca8-37a5fcceb996 ditto ditto /usr/ Verity Partition (64-bit MIPS BigEndian (mips64)) 81cf9d90-7458-4df4-8dcf-c8a3a404f09b ditto ditto /usr/ Verity Partition (32-bit MIPS LittleEndian (mipsel)) 46b98d8d-b55c-4e8f-aab3-37fca7f80752 SD_GPT_USR_MIPS_LE_VERITY ditto ditto /usr/ Verity Partition (64-bit MIPS LittleEndian (mips64el)) 3c3d61fe-b5f3-414d-bb71-8739a694a4ef SD_GPT_USR_MIPS64_LE_VERITY ditto ditto /usr/ Verity Partition (HPPA/PARISC) 5843d618-ec37-48d7-9f12-cea8e08768b2 SD_GPT_USR_PARISC_VERITY ditto ditto /usr/ Verity Partition (64-bit PowerPC LittleEndian) ee2b9983-21e8-4153-86d9-b6901a54d1ce SD_GPT_USR_PPC64_LE_VERITY ditto ditto /usr/ Verity Partition (64-bit PowerPC BigEndian) bdb528a5-a259-475f-a87d-da53fa736a07 SD_GPT_USR_PPC64_VERITY ditto ditto /usr/ Verity Partition (32-bit PowerPC) df765d00-270e-49e5-bc75-f47bb2118b09 SD_GPT_USR_PPC_VERITY ditto ditto /usr/ Verity Partition (RISC-V 32-bit) cb1ee4e3-8cd0-4136-a0a4-aa61a32e8730 SD_GPT_USR_RISCV32_VERITY ditto ditto /usr/ Verity Partition (RISC-V 64-bit) 8f1056be-9b05-47c4-81d6-be53128e5b54 SD_GPT_USR_RISCV64_VERITY ditto ditto /usr/ Verity Partition (s390) b663c618-e7bc-4d6d-90aa-11b756bb1797 SD_GPT_USR_S390_VERITY ditto ditto /usr/ Verity Partition (s390x) 31741cc4-1a2a-4111-a581-e00b447d2d06 SD_GPT_USR_S390X_VERITY ditto ditto /usr/ Verity Partition (TILE-Gx) 2fb4bf56-07fa-42da-8132-6b139f2026ae SD_GPT_USR_TILEGX_VERITY ditto ditto /usr/ Verity Partition (amd64/x86_64) 77ff5f63-e7b6-4633-acf4-1565b864c0e6 SD_GPT_USR_X86_64_VERITY ditto ditto /usr/ Verity Partition (x86) 8f461b0d-14ee-4e81-9aa9-049b6fb97abd SD_GPT_USR_X86_VERITY ditto ditto Root Verity Signature Partition (Alpha) d46495b7-a053-414f-80f7-700c99921ef8 SD_GPT_ROOT_ALPHA_VERITY_SIG A serialized JSON object, see below Contains a root hash and a PKCS#7 signature for it, permitting signed dm-verity GPT images. Root Verity Signature Partition (ARC) 143a70ba-cbd3-4f06-919f-6c05683a78bc SD_GPT_ROOT_ARC_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit ARM) 42b0455f-eb11-491d-98d3-56145ba9d037 SD_GPT_ROOT_ARM_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit ARM/AArch64) 6db69de6-29f4-4758-a7a5-962190f00ce3 SD_GPT_ROOT_ARM64_VERITY_SIG ditto ditto Root Verity Signature Partition (Itanium/IA-64) e98b36ee-32ba-4882-9b12-0ce14655f46a SD_GPT_ROOT_IA64_VERITY_SIG ditto ditto Root Verity Signature Partition (LoongArch 64-bit) 5afb67eb-ecc8-4f85-ae8e-ac1e7c50e7d0 SD_GPT_ROOT_LOONGARCH64_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit MIPS BigEndian (mips)) bba210a2-9c5d-45ee-9e87-ff2ccbd002d0 ditto ditto Root Verity Signature Partition (64-bit MIPS BigEndian (mips64)) 43ce94d4-0f3d-4999-8250-b9deafd98e6e ditto ditto Root Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) c919cc1f-4456-4eff-918c-f75e94525ca5 SD_GPT_ROOT_MIPS_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) 904e58ef-5c65-4a31-9c57-6af5fc7c5de7 SD_GPT_ROOT_MIPS64_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (HPPA/PARISC) 15de6170-65d3-431c-916e-b0dcd8393f25 SD_GPT_ROOT_PARISC_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit PowerPC LittleEndian) d4a236e7-e873-4c07-bf1d-bf6cf7f1c3c6 SD_GPT_ROOT_PPC64_LE_VERITY_SIG ditto ditto Root Verity Signature Partition (64-bit PowerPC BigEndian) f5e2c20c-45b2-4ffa-bce9-2a60737e1aaf SD_GPT_ROOT_PPC64_VERITY_SIG ditto ditto Root Verity Signature Partition (32-bit PowerPC) 1b31b5aa-add9-463a-b2ed-bd467fc857e7 SD_GPT_ROOT_PPC_VERITY_SIG ditto ditto Root Verity Signature Partition (RISC-V 32-bit) 3a112a75-8729-4380-b4cf-764d79934448 SD_GPT_ROOT_RISCV32_VERITY_SIG ditto ditto Root Verity Signature Partition (RISC-V 64-bit) efe0f087-ea8d-4469-821a-4c2a96a8386a SD_GPT_ROOT_RISCV64_VERITY_SIG ditto ditto Root Verity Signature Partition (s390) 3482388e-4254-435a-a241-766a065f9960 SD_GPT_ROOT_S390_VERITY_SIG ditto ditto Root Verity Signature Partition (s390x) c80187a5-73a3-491a-901a-017c3fa953e9 SD_GPT_ROOT_S390X_VERITY_SIG ditto ditto Root Verity Signature Partition (TILE-Gx) b3671439-97b0-4a53-90f7-2d5a8f3ad47b SD_GPT_ROOT_TILEGX_VERITY_SIG ditto ditto Root Verity Signature Partition (amd64/x86_64) 41092b05-9fc8-4523-994f-2def0408b176 SD_GPT_ROOT_X86_64_VERITY_SIG ditto ditto Root Verity Signature Partition (x86) 5996fc05-109c-48de-808b-23fa0830b676 SD_GPT_ROOT_X86_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (Alpha) 5c6e1c76-076a-457a-a0fe-f3b4cd21ce6e SD_GPT_USR_ALPHA_VERITY_SIG A serialized JSON object, see below Similar semantics to root Verity signature partition, but just for the /usr/ partition. /usr/ Verity Signature Partition (ARC) 94f9a9a1-9971-427a-a400-50cb297f0f35 SD_GPT_USR_ARC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit ARM) d7ff812f-37d1-4902-a810-d76ba57b975a SD_GPT_USR_ARM_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit ARM/AArch64) c23ce4ff-44bd-4b00-b2d4-b41b3419e02a SD_GPT_USR_ARM64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (Itanium/IA-64) 8de58bc2-2a43-460d-b14e-a76e4a17b47f SD_GPT_USR_IA64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (LoongArch 64-bit) b024f315-d330-444c-8461-44bbde524e99 SD_GPT_USR_LOONGARCH64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit MIPS BigEndian (mips)) 97ae158d-f216-497b-8057-f7f905770f54 ditto ditto /usr/ Verity Signature Partition (64-bit MIPS BigEndian (mips64)) 05816ce2-dd40-4ac6-a61d-37d32dc1ba7d ditto ditto /usr/ Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) 3e23ca0b-a4bc-4b4e-8087-5ab6a26aa8a9 SD_GPT_USR_MIPS_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) f2c2c7ee-adcc-4351-b5c6-ee9816b66e16 SD_GPT_USR_MIPS64_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (HPPA/PARISC) 450dd7d1-3224-45ec-9cf2-a43a346d71ee SD_GPT_USR_PARISC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit PowerPC LittleEndian) c8bfbd1e-268e-4521-8bba-bf314c399557 SD_GPT_USR_PPC64_LE_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (64-bit PowerPC BigEndian) 0b888863-d7f8-4d9e-9766-239fce4d58af SD_GPT_USR_PPC64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (32-bit PowerPC) 7007891d-d371-4a80-86a4-5cb875b9302e SD_GPT_USR_PPC_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (RISC-V 32-bit) c3836a13-3137-45ba-b583-b16c50fe5eb4 SD_GPT_USR_RISCV32_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (RISC-V 64-bit) d2f9000a-7a18-453f-b5cd-4d32f77a7b32 SD_GPT_USR_RISCV64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (s390) 17440e4f-a8d0-467f-a46e-3912ae6ef2c5 SD_GPT_USR_S390_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (s390x) 3f324816-667b-46ae-86ee-9b0c0c6c11b4 SD_GPT_USR_S390X_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (TILE-Gx) 4ede75e2-6ccc-4cc8-b9c7-70334b087510 SD_GPT_USR_TILEGX_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (amd64/x86_64) e7bb33fb-06cf-4e81-8273-e543b413e2e2 SD_GPT_USR_X86_64_VERITY_SIG ditto ditto /usr/ Verity Signature Partition (x86) 974a71c0-de41-43c3-be5d-5c5ccd1ad2c0 SD_GPT_USR_X86_VERITY_SIG ditto ditto EFI System Partition c12a7328-f81f-11d2-ba4b-00a0c93ec93b SD_GPT_ESP VFAT The ESP used for the current boot is automatically mounted to /boot/ or /efi/, unless a different partition is mounted there (possibly via /etc/fstab) or the mount point directory is non-empty on the root disk. If both ESP and XBOOTLDR exist, the /efi/ mount point shall be used for ESP. This partition type is defined by the UEFI Specification. Extended Boot Loader Partition bc13c2ff-59e6-4262-a352-b275fd6f7172 SD_GPT_XBOOTLDR Typically VFAT The Extended Boot Loader Partition (XBOOTLDR) used for the current boot is automatically mounted to /boot/, unless a different partition is mounted there (possibly via /etc/fstab) or the mount point directory is non-empty on the root disk. This partition type is defined by the Boot Loader Specification. Swap 0657fd6d-a4ab-43c4-84e5-0933c84b4f4f SD_GPT_SWAP Swap, optionally in LUKS All swap partitions on the disk containing the root partition are automatically enabled. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/swap. This partition type predates the Discoverable Partitions Specification. Home Partition 933ac7e1-2eb4-4f13-b844-0e14e2aef915 SD_GPT_HOME Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /home/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/home. Server Data Partition 3b8f8425-20e0-4f3b-907f-1a25a76f98e8 SD_GPT_SRV Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /srv/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/srv. Variable Data Partition 4d21b016-b534-45c2-a9fb-5c16e091fd2d SD_GPT_VAR Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/ — under the condition that its partition UUID matches the first 128 bits of HMAC-SHA256(machine-id, 0x4d21b016b53445c2a9fb5c16e091fd2d) (i.e. the SHA256 HMAC hash of the binary type UUID keyed by the machine ID as read from /etc/machine-id. This special requirement is made because /var/ (unlike the other partition types listed here) is inherently private to a specific installation and cannot possibly be shared between multiple OS installations on the same disk, and thus should be bound to a specific instance of the OS, identified by its machine ID. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/var. Temporary Data Partition 7ec6f557-3bc5-4aca-b293-16ef5df639d1 SD_GPT_TMP Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/tmp/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/tmp. Note that the intended mount point is indeed /var/tmp/, not /tmp/. The latter is typically maintained in memory via tmpfs and does not require a partition on disk. In some cases it might be desirable to make /tmp/ persistent too, in which case it is recommended to make it a symlink or bind mount to /var/tmp/, thus not requiring its own partition type UUID. Per-user Home Partition 773f91ef-66d4-49b5-bd83-d683bf40ad16 SD_GPT_USER_HOME Any native, optionally in LUKS A home partition of a user, managed by systemd-homed. Generic Linux Data Partition 0fc63daf-8483-4772-8e79-3d69d8477de4 SD_GPT_LINUX_GENERIC Any native, optionally in LUKS No automatic mounting takes place for other Linux data partitions. This partition type should be used for all partitions that carry Linux file systems. The installer needs to mount them explicitly via entries in /etc/fstab. Optionally, these partitions may be encrypted with LUKS. This partition type predates the Discoverable Partitions Specification. Other GPT type IDs might be used on Linux, for example to mark software RAID or LVM partitions. The definitions of those GPT types is outside of the scope of this specification.
systemd-id128(1)\u0026rsquo;s show command may be used to list those GPT partition type UUIDs.
Partition Names # For partitions of the types listed above it is recommended to use human-friendly, descriptive partition names in the GPT partition table, for example \u0026ldquo;Home\u0026rdquo;, \u0026ldquo;Server Data\u0026rdquo;, \u0026ldquo;Fedora Root\u0026rdquo; and similar, possibly localized.
For the Root/Verity/Verity signature partitions it might make sense to use a versioned naming scheme reflecting the OS name and its version, e.g. \u0026ldquo;fooOS_2021.4\u0026rdquo; or similar. For details about the version format see the Version Format Specification. The underscore character (_) must be used to separate the version from the name of the image.
Partition Attribute Flags # This specification defines three GPT partition attribute flags that may be set for the partition types defined above:
For the root, /usr/, Verity, Verity signature, home, server data, variable data, temporary data, swap, and extended boot loader partitions, the partition flag bit 63 (\u0026quot;no-auto\u0026quot;, SD_GPT_FLAG_NO_AUTO) may be used to turn off auto-discovery for the specific partition. If set, the partition will not be automatically mounted or enabled.
For the root, /usr/, Verity, Verity signature home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 60 (\u0026quot;read-only\u0026quot;, SD_GPT_FLAG_READ_ONLY) may be used to mark a partition for read-only mounts only. If set, the partition will be mounted read-only instead of read-write. Note that the variable data partition and the temporary data partition will generally not be able to serve their purpose if marked read-only, since by their very definition they are supposed to be mutable. (The home and server data partitions are generally assumed to be mutable as well, but the requirement for them is not equally strong.) Because of that, while the read-only flag is defined and supported, it\u0026rsquo;s almost never a good idea to actually use it for these partitions. Also note that Verity and signature partitions are by their semantics always read-only. The flag is hence of little effect for them, and it is recommended to set it unconditionally for the Verity and signature partition types.
For the root, /usr/, home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 59 (\u0026quot;grow-file-system\u0026quot;, SD_GPT_FLAG_GROWFS) may be used to mark a partition for automatic growing of the contained file system to the size of the partition when mounted. Tools that automatically mount disk image with a GPT partition table are suggested to implicitly grow the contained file system to the partition size they are contained in, if they are found to be smaller. This flag is without effect on partitions marked \u0026ldquo;read-only\u0026rdquo;.
Note that the first two flag definitions happen to correspond nicely to the same ones used by Microsoft Basic Data Partitions.
All three of these flags generally affect only auto-discovery and automatic mounting of disk images. If partitions marked with these flags are mounted using low-level commands like mount(8) or directly with mount(2), they typically have no effect.
Verity # The Root//usr/ partition types and their matching Verity and Verity signature partitions enable relatively automatic handling of dm-verity protected setups. These types are defined with two modes of operation in mind:
A trusted Verity root hash is passed in externally, for example is specified on the kernel command line that is signed along with the kernel image using SecureBoot PE signing (which in turn is tested against a set of firmware-provided set of signing keys). If so, discovery and setup of a Verity volume may be fully automatic: if the root partition\u0026rsquo;s UUID is chosen to match the first 128 bit of the root hash, and the matching Verity partition UUIDs is chosen to match the last 128bit of the root hash, then automatic discovery and match-up of the two partitions is possible, as the root hash is enough to both find the partitions and then combine them in a Verity volume. In this mode a Verity signature partition is not used and unnecessary.
A Verity signature partition is included on the disk, with a signature to be tested against a system-provided set of signing keys. The signature partition primarily contains two fields: the root hash to use, and a PKCS#7 signature of it, using a signature key trusted by the OS. If so, discovery and setup of a Verity volume may be fully automatic. First, the specified root hash is validated with the signature and the OS-provided trusted keys. If the signature checks out the root hash is then used in the same way as in the first mode of operation described above.
Both modes of operation may be combined in a single image. This is particularly useful for images that shall be usable in two different contexts: for example an image that shall be able to boot directly on UEFI systems (in which case it makes sense to include the root hash on the kernel command line that is included in the signed kernel image to boot, as per mode of operation #1 above), but also be able to used as image for a container engine (such as systemd-nspawn), which can use the signature partition to validate the image, without making use of the signed kernel image (and thus following mode of operation #2).
The Verity signature partition\u0026rsquo;s contents should be a serialized JSON object in text form, padded with NUL bytes to the next multiple of 4096 bytes in size. Currently three fields are defined for the JSON object:
The (mandatory) rootHash field should be a string containing the Verity root hash, formatted as series of (lowercase) hex characters.
The (mandatory) signature field should be a string containing the PKCS#7 signature of the root hash, in Base64-encoded DER format. This should be the same format used by the Linux kernel\u0026rsquo;s dm-verity signature logic, i.e. the signed data should be the exact string representation of the hash, as stored in rootHash above.
The (optional) certificateFingerprint field should be a string containing a SHA256 fingerprint of the X.509 certificate in DER format for the key that signed the root hash, formatted as series of (lowercase) hex characters (no : separators or such).
More fields might be added in later revisions of this specification.
Suggested Mode of Operation # An installer that repartitions the hard disk should use the above UUID partition types for appropriate partitions it creates.
An installer which supports a \u0026ldquo;manual partitioning\u0026rdquo; interface may choose to pre-populate the interface with swap, /home/, /srv/, /var/tmp/ partitions of pre-existing Linux installations, identified with the GPT type UUIDs above. The installer should not pre-populate such an interface with any identified root, /usr or /var/ partition unless the intention is to overwrite an existing operating system that might be installed.
An installer may omit creating entries in /etc/fstab for root, /home/, /srv/, /var/, /var/tmp and for the swap partitions if they use these UUID partition types, and are the first partitions on the disk of each type. If the ESP shall be mounted to /efi/ (or /boot/), it may additionally omit creating the entry for it in /etc/fstab. If the EFI partition shall not be mounted to /efi/ or /boot/, it must create /etc/fstab entries for them. If other partitions are used (for example for /usr/local/ or /var/lib/mysql/), the installer must register these in /etc/fstab. The root= parameter passed to the kernel by the boot loader may be omitted if the root partition is the first one on the disk of its type. If the root partition is not the first one on the disk, the root= parameter must be passed to the kernel by the boot loader. An installer that mounts a root, /usr/, /home/, /srv/, /var/, or /var/tmp/ file system with the partition types defined as above which contains a LUKS header must call the device mapper device \u0026ldquo;root\u0026rdquo;, \u0026ldquo;usr\u0026rdquo;, \u0026ldquo;home\u0026rdquo;, \u0026ldquo;srv\u0026rdquo;, \u0026ldquo;var\u0026rdquo; or \u0026ldquo;tmp\u0026rdquo;, respectively. This is necessary to ensure that the automatic discovery will never result in different device mapper names than any static configuration by the installer, thus eliminating possible naming conflicts and ambiguities.
An operating system should automatically discover and mount the first root partition that does not have the no-auto flag set (as described above) by scanning the disk containing the currently used EFI ESP. It should automatically discover and mount the first /usr/, /home/, /srv/, /var/, /var/tmp/ and swap partitions that do not have the no-auto flag set by scanning the disk containing the discovered root partition. It should automatically discover and mount the partition containing the currently used EFI ESP to /efi/ (or /boot/ as fallback). It should automatically discover and mount the partition containing the currently used Extended Boot Loader Partition to /boot/. It should not discover or automatically mount partitions with other UUID partition types, or partitions located on other disks, or partitions with the no-auto flag set. User configuration shall always override automatic discovery and mounting. If a root, /usr/, /home/, /srv/, /boot/, /var/, /var/tmp/, /efi/, /boot/ or swap partition is listed in /etc/fstab or with root= on the kernel command line, it must take precedence over automatically discovered partitions. If a /home/, /usr/, /srv/, /boot/, /var/, /var/tmp/, /efi/ or /boot/ directory is found to be populated already in the root partition, the automatic discovery must not mount any discovered file system over it. Optionally, in case of the root, /usr/ and their Verity partitions instead of strictly mounting the first suitable partition an OS might choose to mount the partition whose label compares the highest according to strverscmp() or similar logic, in order to implement a simple partition-based A/B versioning scheme. The precise rules are left for the implementation to decide, but when in doubt earlier partitions (by their index) should always win over later partitions if the label comparison is inconclusive.
A container manager should automatically discover and mount the root, /usr/, /home/, /srv/, /var/, /var/tmp/ partitions inside a container disk image. It may choose to mount any discovered ESP and/or XBOOTLDR partition to /efi/ or /boot/. It should ignore any swap should they be included in a container disk image.
If a btrfs file system is automatically discovered and mounted by the operating system/container manager it will be mounted with its default subvolume. The installer should make sure to set the default subvolume correctly using \u0026ldquo;btrfs subvolume set-default\u0026rdquo;.
Sharing of File Systems between Installations # If two Linux-based operating systems are installed on the same disk, the scheme above suggests that they may share the swap, /home/, /srv/, /var/tmp/, ESP, XBOOTLDR. However, they should each have their own root, /usr/ and /var/ partition.
Frequently Asked Questions # Why are you taking my /etc/fstab away? # We are not. /etc/fstab always overrides automatic discovery and is indeed mentioned in the specifications. We are simply trying to make the boot and installation processes of Linux a bit more robust and self-descriptive.
Why did you only define the root partition for these listed architectures? # Please submit a patch that adds appropriate partition type UUIDs for the architecture of your choice should they be missing so far. The only reason they aren\u0026rsquo;t defined yet is that nobody submitted them yet.
Why define distinct root partition UUIDs for the various architectures? # This allows disk images that may be booted on multiple architectures to use discovery of the appropriate root partition on each architecture.
Doesn\u0026rsquo;t this break multi-boot scenarios? # No, it doesn\u0026rsquo;t. The specification says that installers may not stop creating /etc/fstab or stop including root= on the kernel command line, unless the used partitions are the first ones of their type on the disk. Additionally, /etc/fstab and root= both override automatic discovery. Multi-boot is hence well supported, since it doesn\u0026rsquo;t change anything for anything but the first installation.
That all said, it\u0026rsquo;s not expected that generic installers generally stop setting root= and creating /etc/fstab anyway. The option to drop these configuration bits is primarily something for appliance-like devices. However, generic installers should still set the right GPT partition types for the partitions they create so that container managers, partition tools and administrators can benefit. Phrased differently, this specification introduces A) the recommendation to use the newly defined partition types to tag things properly and B) the option to then drop root= and /etc/fstab. While we advertise A) to all installers, we only propose B) for simpler, appliance-like installations.
What partitioning tools will create a DPS-compliant partition table? # As of util-linux 2.25.2, the fdisk tool provides type codes to create the root, home, and swap partitions that the DPS expects. By default, fdisk will create an old-style MBR, not a GPT, so typing l to list partition types will not show the choices to let you set the correct UUID. Make sure to first create an empty GPT, then type l in order for the DPS-compliant type codes to be available.
The gdisk tool (from version 1.0.5 onward) and its variants (sgdisk, cgdisk) also support creation of partitions with a matching type code.
Links # Boot Loader Specification
Boot Loader Interface
Safely Building Images
systemd-boot(7)
bootctl(1)
systemd-gpt-auto-generator(8)
`}),e.add({id:5,href:"/specifications/specs/extension_image/",title:"Extension Images",section:"Specs",content:` Extension Images # Extension Images are DDIs ( Discoverable Disk Images) that are built to extend a base system via an overlay. A base system or a root DDI can be extended by several extension DDIs via, usually, a read-only OverlayFS. The defining characteristic of an Extension Image is that it contains an extension-release.\u0026lt;IMAGE\u0026gt; file that identifies itself and the base system or root DDI it applies to, and must not contain an os-release file.
Ordering # The default order in which extensions are applied is based on lexicographic sorting as defined in the Version Format Specification, with images sorting as older being placed lower in the overlay. Implementations may allow a different order to be explicitly specified instead.
Image Format # Extensions are DDIs ( Discoverable Disk Images), so the file format will not be redefined here.
Extension Types # There are two types of extension images, sysext (System Extension) and confext (Configuration Extension). They are differentiated by the directory hierarchies they contain.
sysext (System Extension) # sysext images extend /usr/ (OS vendor tree) and/or /opt/ (third-party vendor tree). They must contain a /usr/lib/extension-release.d/extension-release.\u0026lt;IMAGE\u0026gt; file to identify them.
confext (Configuration Extension) # confext images extend /etc. They must contain a /etc/extension-release.d/extension-release.\u0026lt;IMAGE\u0026gt; file to identify them.
Image Content Extension Images should be additive, and not override content present in the base image or other DDIs. However, there currently is no safe and efficient way to detect collisions and to enforce content uniqueness across the stack of images. In a future version of this specification options for enforcing uniqueness may be provided. Base Directory Immutability / Mutability # By default, applying (\u0026ldquo;merging\u0026rdquo;) an Extension Image on a mutable filesystem renders the underlying base directory (/etc/, /usr/, /opt/) immutable. By implication, merging a confext on a mutable filesystem will result in /etc/ becoming read-only, and merging a sysext might render /usr/ and/or /opt/ read-only, depending on the sysext\u0026rsquo;s contents.
This affects base directories actually contained in extensions merged to a root filesystem: for instance, if a sysext extends /usr/ but not /opt/, /opt/ will remain mutable if it\u0026rsquo;s on a mutable filesystem. However, immutability affects the full base directory. Merging an extension on a mutable filesystem that ships a single custom path e.g. below /etc/appconfig-extra/some/sub/path/ will still render the entirety of /etc/ immutable. The base directory or directories remain immutable for as long as extensions are merged. Mutability, if present before the merge, is regained only after all extensions overlaying a base directory have been un-merged.
Optional Mutability # While overlaid base directories are immutable by default, implementations may provide options for mutability. Retaining mutability may for instance be useful for compatibility with general purpose applications, enabling users to operate a \u0026ldquo;mixed mode\u0026rdquo; with both system and configuration extensions and traditional applications. Mixed mode may also be integrated by distributions to facilitate a smooth transition from traditional package management to a purely image-based composition of the root file system. Lastly, mutability mode may be used on an originally immutable filesystem to allow and to capture temporary changes.
Extension Overlay [Im]Mutability Modes # System and configuration extensions may operate in one of three modes.
Immutable mode - The overlaid base directory is immutable. This is the default. Mutable mode - Writes are directed to an upperdir specified by the user or operator (see \u0026ldquo;Mutability Mode Configuration\u0026rdquo; below). This upperdir will contain all changes made to the overlaid base directory. Upperdir may be specified to be the base directory: may be used to retain mutability of the base directory after extensions have been merged. Alternatively, upperdir may be an entirely separate directory: modifications will be captured but the base directory will remain unchanged, retaining its state from before the extension was merged. Ephemeral Mode - Similar to mutable mode (2.) above but writes are only stored temporarily while extensions are merged, and discarded as soon as extensions are un-merged. Location of temporary storage is implementation-specific. Useful for e.g. development and for one-shot validation operations. Mutability Mode Configuration # Immutable mode is the default. If none of the configurations outlined below were specified then extension overlays operate in immutable mode and base directories are read-only. Implementation of any of the below mutable configurations is optional. If mutable modes are supported by an implementation, configuration option 1. below must be supported for compatibility across implementations.
Mutability modes may be configured in the following ways:
By creating qualified paths or soft-links below /var/lib/extensions.mutable/. See \u0026ldquo;Qualified Paths Definition\u0026rdquo; below for details. This is the most portable option across different implementations. If an implementation supports base directory mutability then this mode must be supported. By setting a respective option in an implementation\u0026rsquo;s configuration file. This option is implementation-specific. Implementations may choose to support a single option, multiple options for system and configuration extensions, and/or multiple options per base directory. Using this option should selectively override any qualified path definitions from 1. By passing a command line parameter upon extension merge or refresh. This option is implementation-specific. Implementations may choose to support a single option and/or multiple options per base directory. Using this option should selectively override any configurations from 1. and 2. Qualified Paths Definition # Mutability Mode 1 enables mutability by creating paths or soft-links below /var/lib/extensions.mutable/. Qualified paths are:
/var/lib/extensions.mutable/etc/ - directory or soft-link to a directory to store writes to /etc/. This is for configuration extensions. /var/lib/extensions.mutable/usr/ - directory or soft-link to a directory to store writes to /usr/. This is for system extensions. /var/lib/extensions.mutable/opt/ - directory or soft-link to a directory to store writes to /opt/. This is for system extensions. Each base directory is treated separately. The existence and the type of each qualified path determines the mutability mode used. The following mutability modes are supported:
Path does not exist - immutable mode. Path is a directory, subvolume, or mount point - the path at /var/lib/extensions.mutable/\u0026lt;basedir\u0026gt;/ is used to store writes to /\u0026lt;basedir\u0026gt;/. A tmpfs mount at the qualified path may be used for a custom ephemeral mode. In this case, clean-up of the tmpfs is left to the user and/or is implementation-specific. Path is a soft link - the soft link is followed and writes are stored at the link\u0026rsquo;s destination. If the destination is the base directory - i.e. /var/lib/extensions.mutable/\u0026lt;basedir\u0026gt;/ points to /\u0026lt;basedir\u0026gt;/ - then the stacking order changes and \u0026lt;basedir\u0026gt; becomes upperdir. Writes are directed to the base directory and files and paths present in the base directory override files and paths in extensions if present. The soft link may point to a tmpfs destination for custom ephemeral mode. In this case, clean-up of the tmpfs is left to the user and/or is implementation-specific. If the destination does not exist, immutable mode is used. File Suffix # Since extensions images are DDIs, they should carry the .raw suffix. In order to make discerning system extensions and configuration extensions easy it is recommended to use the .sysext.raw suffix for system extensions, and .confext.raw for configuration extensions.
Identification # An Extension Image must contain a extension-release.\u0026lt;IMAGE\u0026gt; file, where \u0026lt;IMAGE\u0026gt; must either match the name of the sysext minus the suffix, or alternatively extension-release.\u0026lt;IMAGE\u0026gt; must be tagged with a user.extension-release.strict xattr set to the string \u0026quot;0\u0026quot; in order to be valid. This is to make it obvious to users that a sysext is used for its purpose. The format of extension-release.\u0026lt;IMAGE\u0026gt; is the same as the os-release file, and it is a newline-separated list of environment-like shell-compatible variable assignments. New fields SYSEXT_LEVEL= and CONFEXT_LEVEL= have been introduced to allow an implementation to match a sysext or a confext with the base image upon which it is layered: if the field is present, it must match between the layers or the Extension Image must be ignored, while if it is not present, but VERSION_ID= is, then the latter must match instead. In addition, the ID= field must be present and match the base image\u0026rsquo;s, or be set to the special value _any, in case the Extension Image can be used on any Linux distribution.
Fields in extension-release — Matching with the base system or DDI # The following fields are used in order to match with the base system or DDI.
SYSEXT_LEVEL= CONFEXT_LEVEL= # A lower-case string (mostly numeric, no spaces or other characters outside of 0–9, a–z, \u0026ldquo;.\u0026rdquo;, \u0026ldquo;_\u0026rdquo; and \u0026ldquo;-\u0026rdquo;) identifying the operating system extensions support level, to indicate which extension images are supported.
Examples: \u0026quot;SYSEXT_LEVEL=2\u0026quot;, \u0026quot;CONFEXT_LEVEL=15.14\u0026quot;.
If not present, and if VERSION_ID= is present instead, then this will be checked instead.
VERSION_ID=, ID=, ARCHITECTURE= # VERSION_ID= and ID= are used to match the Extension Image with the root DDI, and ARCHITECTURE= is used to match with the host\u0026rsquo;s CPU architecture, as defined in the os-release specification. ID= and ARCHITECTURE= also support specifying the _any wildcard, which allows the matching mechanism to be bypassed.
Fields in extension-release — Identifying the Extension Image # The identification fields defined in the os-release specification can be used to also identify the sysext itself, by prefixing them with SYSEXT_. For example, SYSEXT_ID=myext SYSEXT_VERSION_ID=0.1 denotes a \u0026lsquo;myext\u0026rsquo; sysext of version \u0026lsquo;0.1\u0026rsquo;. There are also extension-specific fields that do not apply to \u0026lsquo;os-release\u0026rsquo;, SYSEXT_SCOPE=, CONFEXT_SCOPE= and ARCHITECTURE=.
SYSEXT_SCOPE=, CONFEXT_SCOPE= # Takes a space-separated list of one or more of the strings \u0026quot;system\u0026quot;, \u0026quot;initrd\u0026quot; and \u0026quot;portable\u0026quot;. This field is optional and indicates what environments the system extension is applicable to: i.e. to regular systems, to initrds, or to portable service images. If unspecified, \u0026quot;SYSEXT_SCOPE=system portable\u0026quot; is implied, i.e. any system extension without this field is applicable to regular systems and to portable service environments, but not to initrd environments.
ARCHITECTURE= # A string that specifies which CPU architecture the userspace binaries require. This field is optional and should only be used when just single architecture is supported. It may provide redundant information when used in a GPT partition with a GUID type that already encodes the architecture. If this is not the case, the architecture should be specified in e.g., an extension image, to prevent an incompatible host from loading it.
Valid values:
Architecture x86 x86-64 alpha arc arc-be arm arm-be arm64 arm64-be cris ia64 loongarch64 m68k mips mips-le mips64 mips64-le parisc parisc64 ppc ppc-le ppc64 ppc64-le riscv32 riscv64 s390 s390x sh sh64 sparc64 sparc tilegx native any `}),e.add({id:6,href:"/specifications/specs/linux_tpm_pcr_registry/",title:"Linux TPM PCR Registry",section:"Specs",content:` 🔏 Linux TPM PCR Registry 🗒️ # TPM PCRs are a scarce resource, there are only 24 of them in typical standards compliant TPMs. According to the TCG PC Client Specific Platform Firmware Profile Specification | Trusted Computing Group the OS can make use of PCRs 8…15. This document lists which component is using which PCR on a Linux platform in order to minimize conflicts.
PCRs owned by the firmware, i.e. PCRs 0–7 are described here just for convenience. The authoriative description is in the TCG document.
How other operating systems — in particular Windows — use PCRs, is out of scope of this document.
This document is informational in nature: it just describes what is, it is not intended to formally declare “ownership” of a specific PCR, but simply is supposed to reflect which PCR assignments are common in the Linux ecosystems. That said, co-opting PCR usage will likely create problems down the line, in particular if measurement logs are maintained separately. (To be more explicit: on systemd systems the warranty is voided if you write to the PCRs it also uses, as per the list below.)
PCR measurements most commonly serve two distinct purposes:
To implement access policy on TPM sealed objects: policy can dictate that unsealing of such objects shall only be allowed if some PCRs are in a specific literal state, or in any state for which a signature by a specific key pair can be provided. For this it is essential that PCRs only contain measurements for a clearly defined set of objects, that typically is known in advance so that the PCR value can be pre-calculated (hence this is in a way a forward-looking use) To permit reasoning about the boot process and runtime so far, for example for the purpose of remote attestation. In this case it is not that important what objects are measured as long as a record is kept in a measurement log about what it was. The PCRs are in this case used to validate that log (hence this is in a way a backward-looking use) In both cases it is important that data measured into the PCRs is carefully chosen. PCRs that shall be useful for policy binding should only cover data objects known in advance, and thus not contain runtime data that cannot be pre-calculated in advance. PCRs that shall be useful for backward-looking validation should only cover objects that are also written to the appropriate log for the PCR.
PCR#
Used by From Location Measured Objects Log Use Reported By 0
Firmware 💻 UEFI Boot Component Core system firmware executable code UEFI TPM event log n/a 1
Firmware 💻 UEFI Boot Component Core system firmware data/host platform configuration; typically contains serial and model numbers UEFI TPM event log n/a 2
Firmware 💻 UEFI Boot Component Extended or pluggable executable code; includes option ROMs on pluggable hardware UEFI TPM event log n/a 3
Firmware 💻 UEFI Boot Component Extended or pluggable firmware data; includes information about pluggable hardware UEFI TPM event log n/a 4
Firmware 💻 UEFI Boot Component Boot loader and additional drivers; binaries and extensions loaded by the boot loader UEFI TPM event log n/a 5
Firmware 💻 UEFI Boot Component GPT/Partition table UEFI TPM event log n/a 7
Firmware 💻 UEFI Boot Component SecureBoot state UEFI TPM event log n/a 8
grub 🍲 UEFI Boot Component Commands and kernel command line UEFI TPM event log n/a 9
grub 🍲 UEFI Boot Component All files read (including kernel image) UEFI TPM event log n/a Linux kernel 🌰 Kernel All passed initrds (when the new LOAD_FILE2 initrd protocol is used) UEFI TPM event log n/a 10
IMA 📐 Kernel Protection of the IMA measurement log IMA event log n/a 11
systemd-stub 🚀 UEFI Stub All components of unified kernel images (UKIs) UEFI TPM event log in EFI variable StubPcrKernelImage systemd-pcrphase 🚀 Userspace Boot phase strings, indicating various milestones of the boot process Journal (for now) n/a 12
systemd-stub 🚀 UEFI Stub Kernel command line, system credentials and system configuration images UEFI TPM event log in EFI variable StubPcrKernelParameters 13
systemd-stub 🚀 UEFI Stub All system extension images for the initrdUEFI TPM event log in EFI variable StubPcrInitRDSysExts 14
shim 🔑 UEFI Boot Component “MOK” certificates and hashes UEFI TPM event log n/a 15
systemd-cryptsetup@.service 🚀 Userspace Root file system volume encryption key Journal (for now) n/a systemd-pcrmachine.service 🚀 Userspace Machine ID (/etc/machine-id) Journal (for now) n/a systemd-pcrfs@.service 🚀 Userspace File system mount point, UUID, label, partition UUID label of root file system and /var/ Journal (for now) n/a PCR 0 changes on firmware updates; PCR 1 changes on basic hardware/CPU/RAM replacements.
PCR 4 changes on boot loader updates. The shim project will measure the PE binary it chain loads into this PCR. If the Linux kernel is invoked as UEFI PE binary, it is measured here, too. systemd-stub measures system extension images read from the ESP here too (see systemd-sysext and Extension Images).
PCR 5 changes when partitions are added, modified, or removed.
PCR 7 changes when UEFI SecureBoot mode is enabled/disabled, or firmware certificates (PK, KEK, db, dbx, …) are updated. The shim project will measure most of its (non-MOK) certificates and SBAT data into this PCR.
PCR 11 and 15 as shown in the list above are used by multiple components of systemd. These are not conflicting uses; the involved components are properly ordered to cooperatively guarantee predictable behaviour.
systemd-stub measures the ELF kernel image, embedded initrd and other payload of the PE image into PCR 11. Unlike PCR 4 (where the same data should be measured too), those values should be easy to pre-calculate, as they only reflect the static parts of the PE binary. systemd-pcrphase.service measures boot phase strings into this PCR at various milestones of the boot process. Use PCR 11 to bind TPM policies to a specific kernel image, possibly with an embedded initrd, and to a specific boot phase.
systemd-boot measures the kernel command line into PCR 12. systemd-stub measures any manually specified kernel command line (i.e. a kernel command line that overrides the one embedded in the UKI) and loaded credentials into this PCR. This means that if systemd-boot and systemd-stub are used together, the command line might be measured twice.
systemd-stub measures any Extension Images it passes to the booted kernel into PCR 13.
systemd-cryptsetup optionally measures the volume key of activated LUKS volumes into this PCR. systemd-pcrmachine.service measures the machine-id into this PCR. systemd-pcrfs@.service measures mount points, file system UUIDs, labels, partion UUIDs of the root and /var/ filesystems into this PCR.
Sources # systemd-cryptenroll(1) TCG PC Client Specific Platform Firmware Profile Specification shim\u0026rsquo;s README.tpm Measured Boot - GNU GRUB Manual 2.06 Integrity Measurement Architecture (IMA) edk2-TrustedBootChain/4_Other_Trusted_Boot_Chains.md Trusted Platform Module - ArchWiki `}),e.add({id:7,href:"/specifications/specs/unified_kernel_image/",title:"Unified Kernel Image",section:"Specs",content:` Unified Kernel Image (UKI) # A Unified Kernel Image (UKI) is a combination of an UEFI boot stub program, a Linux kernel image, an optional initrd, and further resources in a single UEFI PE file. This file can either be directly invoked by the UEFI firmware (which is useful in particular in some cloud/Confidential Computing environments) or through a boot loader (which is generally useful to allow multiple kernel versions with interactive or automatic selection of version to boot into).
Various components of the UKI are provided as PE/COFF sections of the executable. The stub is a small program that can be executed in UEFI mode that forms the initial executable part of the combined image. The stub program loads other resources from its executable, including in particular the kernel and initrd, and transitions into the kernel.
This specification defines the format and components (mandatory and optional) of UKIs.
systemd-stub provides the reference implementation of the stub.
UKI File Format # The file format for UKIs is PE/COFF (Portable Executable / Common Object File Format). This is a well-known industry-standard file format, used for example in UEFI environments, and UKIs follow the standard, so exact details will not be repeated here.
UKIs are a PE/COFF file with various resources, listed below, stored in PE sections. In principle this file can be created with a relatively simple objcopy invocation, but the recommended way is to use a helper program ( ukify), which takes care of appropriate alignment and facilitates signing for SecureBoot.
UKIs are UEFI applications images, and hence should initialize the Subsystem field of the optional PE header to 0x0A (i.e. IMAGE_SUBSYSTEM_EFI_APPLICATION).
UKI Components # UKIs consist of the following resources:
An UEFI boot stub that forms the initial program. It contains various PE sections normally required for a program, including .text, .reloc, .data, and others. The Linux kernel in the .linux PE section. Optionally, information describing the OS this kernel is intended for, in the .osrel section. The contents of this section are derived from /etc/os-release of the target OS. They can be useful for presentation of the UKI in the boot loader menu, and ordering it against other entries using the included version information. Optionally, the kernel command line in the .cmdline section. If this is absent, the loader implementation may allow local overrides instead. Optionally, the initrd that the kernel shall unpack and invoke, in the .initrd section. Optionally, a microcode initrd in the .ucode section, to be handed to the kernel before any other initrd. Optionally, a splash image to bring to screen before transitioning into the Linux kernel, in the .splash section. Optionally, one or more compiled Device Trees, for systems which need it, each in its separate .dtb section. If multiple .dtb sections exist then one of them is selected according to an implementation-specific algorithm. Optionally, information describing kernel release information (i.e. uname -r output) in the .uname section. This is also useful for presentation of the UKI in the boot loader menu, and ordering it against other entries. Optionally, a CSV file encoding the SBAT metadata for the image, in the .sbat section. The SBAT format is defined by the Shim project, and used for UEFI revocation purposes. Optionally, a JSON file encoding expected PCR 11 hash values seen from userspace once the UKI has booted up, along with signatures of these expected PCR 11 hash values, in the .pcrsig section. The signatures must also match the key pair described below. Optionally, the public part of a public-private key pair in PEM format used to sign the expected PCR 11 value of the image, in the .pcrpkey section. Note that all of the sections defined above are singletons: they may appear at most once, except for the .dtb section which may appear multiple times.
Only the .linux section is required for the image to be considered a Unified Kernel Image.
A UKI will generally also contain various sections required for the boot stub, but we don\u0026rsquo;t document those here.
Boot menus such as sd-boot and other consumers of UKIs may place additional requirements, for example only show kernels with the .osrel section present.
PE Addons # UKIs are PE executables that may be executed directly in UEFI mode, and contain a variety of resources built-in, as described above. Sometimes it\u0026rsquo;s useful to provide a minimal level of modularity and extend UKIs dynamically with additional resources from separate files. For this purpose UKIs can be combined with one or more \u0026ldquo;PE Addons\u0026rdquo;. This are regular PE UEFI application binaries, that can be authenticated via the usual UEFI SecureBoot logic, and may contain additional PE sections from the list above, that shall be used in combination with any PE sections of the UKI itself. At UKI invocation time, the EFI stub contained in the UKI may load additional of these PE Addons and apply them (after authenticating them via UEFI APIs), combining them with the resources of the UKI.
PE Addons may not contain .linux PE sections (this may be used to distinguish them from UKIs, which must have this section, see above).
PE Addons must contain at least one section of the following types:
.cmdline .dtb .ucode PE Addons should be sorted by their filename, and applied in this order. In case of .cmdline all command lines provided by addons are suffixed in this order to any command line included in the UKI. In case of .dtb any such section included in the UKI shall be applied first, and those provided by add-ons should then by applied in order as a fix-up. In case of .ucode the contained cpio archives should be prefixed to the regular initrds passed to the kernel, in reverse order.
PE Addons may include sections of multiple types (e.g. both a .cmdline and a .dtb section), in which case all of them should be applied.
Just like UKIs PE Addons should have the Subystem field of the optional PE header set to 0x0A.
The PE header\u0026rsquo;s Machine field should be set to the local CPU type for the target machine of the Addon. When enumerating PE Addons to apply, candidates should be skipped when their header field reports a non-native CPU architecture.
PE Addons may contain executable code in a .text section. This code may be useful to write a friendly error message to the UEFI console when executed as regular programs. The code should be ignored when the addon is applied on an UKI.
UKI TPM PCR Measurements # On systems with a Trusted Platform Module (TPM) the UEFI boot stub shall measure the sections listed above, starting from the .linux section, in the order as listed (which should be considered the canonical order). The .pcrsig section is not measured.
For each section two measurements shall be made into PCR 11 with the event code EV_IPL:
The section name in ASCII (including one trailing NUL byte) The (binary) section contents The above should be repeated for every section defined above, so that the measurements are interleaved: section name followed by section data, followed by the next section name and its section data, and so on.
If multiple .dtb sections are present, they shall be measured in the order they appear in the PE file.
JSON Format for .pcrsig # The format is a single JSON object, encoded as a zero-terminated UTF-8 string. Each name in the object shall be unique as per recommendations of RFC8259. Strings shall not contain any control character, nor use \\uXXX escaping.
When it comes to JSON numbers, this specification assumes that JSON parsers processing this information are capable of reproducing the full signed 53bit integer range (i.e. -2⁵³+1…+2⁵³-1) as well as the full 64bit IEEE floating point number range losslessly (with the exception of NaN/-inf/+inf, since JSON cannot encode that), as per recommendations of RFC8259. Fields in these JSON objects are thus permitted to encode numeric values from these ranges as JSON numbers, and should not use numeric values not covered by these types and ranges.
The content is a JSON object, named after the TPM SHA bank to use, containing an array of measurement objects, each containing an array of PCRs, the SHA256 fingerprint of the public key (DER) used for the signature (pkfp), the expected hash (pol) and the signature encoded in base64 (sig).
Example:
{ \u0026#34;sha1\u0026#34;: [ { \u0026#34;pcrs\u0026#34;: [ 11 ], \u0026#34;pkfp\u0026#34;: \u0026#34;2870989436ec5c24461f36f5f070613043c30a156a895903e27fc985d1b2887f\u0026#34;, \u0026#34;pol\u0026#34;: \u0026#34;4a5cfbca5123490989ac060ec8b1755cfa6f0ea37ec39206e988442a9a9023bb\u0026#34;, \u0026#34;sig\u0026#34;: \u0026#34;X9a07Peo0EaEWr0dfUgZIq3Bsf20AGTjAgMilyH3TkLtPBGJLCEFRzK2jkPohG0VXQjao35765Wp/sV1wfctGC0fx9GOsBzK8YKjsFitOw21aLxlnES31D3PbDLPRqkx+fAhwV0/Akd99hNuiyzGdUewNpbbBNo7WXkd4K62RK61dKKI4g//qtLeAyXlee0TLKVxNcT46Ud1t8eUb1GAwRnO7DxBZx8uFyP/D9wpPNK7+M01to74d9ijcsjLXf2eGKcpiDvenUnhI6ua+OvT6CnmgxkFQutLGz/Ka23spSG/YJHfxGT7VpOYveDG19nqBb/fg30HZiY7lVTolS93UA==\u0026#34; } ], \u0026#34;sha256\u0026#34;: [ { \u0026#34;pcrs\u0026#34;: [ 11 ], \u0026#34;pkfp\u0026#34;: \u0026#34;2870989436ec5c24461f36f5f070613043c30a156a895903e27fc985d1b2887f\u0026#34;, \u0026#34;pol\u0026#34;: \u0026#34;707f5d03325822b2a53bfe5d723e0ca290f397c0e6184131b70d00e35224488a\u0026#34;, \u0026#34;sig\u0026#34;: \u0026#34;moQh6GF18LiVlA8CxRkTtbXr2p0NIIBosLazDALZ9lOJQw/w1PB7tcDZ1Kumvzqtx4FO5WVjOkVTnNFrYmXn9K2PpqIDEuTtwaM/lKgP12LtcC635C+VsJMQg3k9sEFfLwBCzrhYxt5GCpxzPrsfwJtsUpueB23sNw27WJS7C+tVnqWw7br6i9vJ59jP9+HXlex+OlZHliHLzZwpuZA8iPMQT0xvm901ak5yoBqNPv4Yya19dlt2sCuO+Iw1LeZW9U83zdG0hn1mxavRIxZ7s0f7a1n/ScrOksgPQB8xfDdFDf9fssGALanOgjCHyD7hRzV31++Qpgah4uc/LJiesg==\u0026#34; } ] } The systemd-measure tool can be used to generate and sign .pcrsig.
Multi-Profile UKIs # In various contexts it is useful to support multiple different configurations (\u0026ldquo;profiles\u0026rdquo;) an UKI may be booted into. An example: a single UKI that can be booted with one of three different kernel command lines, one covering regular boot, one implementing a factory reset logic, and a third one booting into Storage Target Mode, or similar. In order to support this, Multi-Profile UKIs may be defined, as an optional extension of the regular UKI concept described above.
Multi-profile UKIs extend regular UKIs by introducing an additional PE section with the name .profile which can appear multiple times in a single PE file and both acts as a separator between multiple profiles of the same UKI, and carries meta-information about the profile it is introducing. All regular UKI PE sections listed above may appear multiple times in multi-profile UKIs, but only once before the first .profile PE section, once between each subsequent pair of .profile sections, and once after the last .profile (except for .dtb, which is allowed to be defined multiple times anyway, see above). Each .profile section introduces and defines a profile, which are numbered from zero, and typically denoted with an @ character before the profile number, i.e. @0, @1, @2, … The sections listed in the PE binary before the first .profile section make up a special profile called the base profile.
When a multi-profile UKI is invoked, the EFI stub code will make sure to load the PE sections matching the selected profile. A profile is (optionally) selected by prefixing the EFI stub\u0026rsquo;s invocation parameters (\u0026ldquo;command line\u0026rdquo;) with @0 , @1 , @2 , (i.e. an @ character, the numeric profile index, and a space character) in order to select the desired profile. The stub combines the PE sections of the selected profile with any PE sections from the base profile that are not specified in the selected profile. Or in other words: sections associated with specific profiles comprehensively override those of the same name in the base profile. If a multi-profile UKI is invoked without specification of a profile selector on its command line, profile @0 is automatically selected as default.
The profile selector prefix of the UKI\u0026rsquo;s invocation parameters is stripped after parsing, and is thus neither passed on to the invoked kernel on the kernel\u0026rsquo;s command line, nor is measured as part of the kernel command line.
When measuring PE sections before passing control to the contained kernel, only the sections associated with the selected profile, or the base profile are measured. All others are ignored (neither measured nor used in any other way).
A .profile section may optionally contain meta-information about the profile it introduces that a boot menu can use to automatically synthesize menu entries from the profiles a UKI defines. It contains text data, following a similar syntax as .osrel sections: environment-block like key-value pairs. Currently, two fields are defined: ID= may contain a brief textual, 7bit ASCII identifier for the profile. TITLE= may contain a brief human readable text string that may be shown in a boot menu that allows profile selection.
A brief example for the structure of a hypothetical multi-profile UKI:
Section Contents Profile .linux ELF kernel Base .osrel /etc/os-release Base .cmdline \u0026quot;quiet\u0026quot; Base .profile ID=regular TITLE=\u0026quot;Regular boot\u0026quot; @0 .profile ID=factory-reset TITLE=\u0026quot;Reset Device to Factory Defaults\u0026quot; @1 .cmdline \u0026quot;quiet systemd.unit=factory-reset.target\u0026quot; @1 .profile ID=storagetm TITLE=\u0026quot;Boot into Storage Target Mode\u0026quot; @2 .cmdline \u0026quot;quiet rd.systemd.unit=storage-target-mode.target\u0026quot; @2 (Note: in this example, the .cmdline shown as part of the base profile might as well be moved into profile @0 with identical effect. This is because every other profile overrides it anyway, and thus it only applies to profile @0 either way.)
While the primary usecase for multi-profile UKIs are allowing multiple kernel command line sections (i.e. .cmdline) choices, the concept is not limited to that: any of the UKI PE sections may appear in profiles, for example to allow alternative selection of multiple different CPU microcode or Devicetree blobs.
Note that if the PCR signature mechanism described above is used it is recommended to include a separate .pcrsig PE section in each profile matching precisely the sections that apply to that profile (i.e. the combination of the profile\u0026rsquo;s own sections and those of the base section).
Updatability # UKIs wrap all of the above data in a single file, hence all of the above components can be updated in one go through single file atomic updates, which is useful given that the primary expected storage place for these UKIs is the UEFI System Partition (ESP), which is a vFAT file system, with its limited data safety guarantees.
Security # Given UKIs are regular UEFI PE files, they can thus be signed as one for Secure Boot, protecting all of the individual resources listed above at once, and their combination. Standard Linux tools such as sbsigntool and pesign can be used to sign UKI files. The signature format and process again match the ones already used for PE files, so they will not be redefined here.
Locations for Distribution-built UKIs Installed by Package Managers # UKIs that are built centrally by distributions and installed via the package manager should be installed in /usr/lib/modules/\$UNAME/, where \$UNAME is the output of uname -r of the kernel included in the UKI, so that tools staging or consuming UKIs have a common place to store and look for them.
The installed UKIs should have a filename \u0026lt;version format specification\u0026gt;.efi, i.e. the filename is left to implementers but must be valid for comparisons according to the Version Format Specification.
Locations and Naming for UKI Auxiliary Resources # Auxiliary UKI resources (such as PE addons for kernel command line extensions and similar, as well as systemd-sysext and systemd-confext DDIs) built centrally by distributions and installed via package manager should be installed into locations depending on whether they should be applied to all UKIs installed in the ESP, or only to a single specific UKI.
UKI auxiliary resources that apply to all installed UKIs should be installed into /usr/lib/modules/uki.extra.d/. UKI auxiliary resources that apply to one specific installed UKI should be instead installed into /usr/lib/modules/\$UNAME/\$UKI.efi.extra.d/, where \$UNAME is the output of uname -r of the kernel included in the UKI and \$UKI is the name of the corresponding centrally built UKI with the .efi extension stripped.
The installed UKI auxiliary resources must have a specific file extension, which depends on the resource type:
.addon.efi for PE addons, .sysext.raw for sysext DDIs, .confext.raw for confext DDIs Example # Given a UKI bar_123.efi that includes a kernel 6.9.1-1.foo, consider
a PE addon machine-id that should apply to all installed UKIs, a PE addon proprietary-driver_2000 that is specific to the bar_123 UKI, and a sysext mysysext_1.23.47^3 that should apply to all installed UKIs. The resulting paths would be
/usr/lib/modules/uki.extra.d/machine-id.addon.efi, /usr/lib/modules/6.9.1-1.foo/bar_123.efi.extra.d/proprietary-driver_2000.addon.efi, and /usr/lib/modules/uki.extra.d/mysysext_1.23.47^3.sysext.raw. `}),e.add({id:8,href:"/specifications/specs/version_format_specification/",title:"Version Format Specification",section:"Specs",content:` Version Format Specification # This specification defines the format of version strings and their ordering. Various documents that are part of the uapi-group specification suite, as well as other projects like systemd, rely on this specification to have a sort order for strings that include version components, and use it for various purposes, such as choosing the default boot entry in the Boot Loader Specification.
Version Format # The version string is a sequence of zero or more characters.
The following characters have special meaning:
ASCII digits (0-9) form numerical components. ASCII letters (a-z, A-Z) form alphabetical components. Dot (.) separates parts of a component. Minus (-) separates major parts of the version string. Tilde (~) starts a suffix that always sorts lower. Caret (^) starts a suffix that always sorts higher. Other characters are treated as separators. This includes plus (+) and underscore (_) and other printable or non-printable characters. The underscore MAY be used. The plus SHOULD NOT be used, to avoid confusion with SEMVER which attaches a special meaning to it. Other characters MUST NOT be used in a version string.
Note that in some contexts (for example the DDI specification and DEB package file names), the underscore is used as a separator and cannot be used freely in the version string.
Version Comparison # The following method should be used to compare version strings. The algorithm is based on rpm\u0026rsquo;s rpmvercmp(), but not identical.
Both strings are compared from the beginning until the end, or until the strings are found to compare as different. In a loop:
Any characters which are outside of the set of listed above (a-z, A-Z, 0-9, -, ., ~, ^) are skipped in both strings. In particular, this means that non-ASCII characters that are Unicode digits or letters are skipped too. If the remaining part of one of strings starts with ~: if other remaining part does not start with ~, the string with ~ compares lower. Otherwise, both tilde characters are skipped. If one of the strings has ended: if the other string hasn\u0026rsquo;t, the string that has remaining characters compares higher. Otherwise, the strings compare equal. If the remaining part of one of strings starts with -: if the other remaining part does not start with -, the string with - compares lower. Otherwise, both minus characters are skipped. If the remaining part of one of strings starts with ^: if the other remaining part does not start with ^, the string with ^ compares lower. Otherwise, both caret characters are skipped. If the remaining part of one of strings starts with .: if the other remaining part does not start with ., the string with . compares lower. Otherwise, both dot characters are skipped. If either of the remaining parts starts with a digit: numerical prefixes are compared numerically. Any leading zeroes are skipped. The numerical prefixes (until the first non-digit character) are evaluated as numbers. If one of the prefixes is empty, it evaluates as 0. If the numbers are different, the string with the bigger number compares higher. Otherwise, the comparison continues at the following characters at point 1. Leading alphabetical prefixes are compared alphabetically. The substrings are compared letter-by-letter. If both letters are the same, the comparison continues with the next letter. All capital letters compare lower than lower-case letters (B \u0026lt; a). When the end of one substring has been reached (a non-letter character or the end of the whole string), if the other substring has remaining letters, it compares higher. Otherwise, the comparison continues at the following characters at point 1. Comparison with Other Specifications # Other specifications exist to mandate version formats:
RPM Packaging Guidelines Debian Policy Semantic Versioning All of these, including the present document, share some commonalities but are also incompatible in some ways, as they all evolved in different environments. The main differences are as follows.
to separate components DEB uses _, RPM uses - with positional logic (it assumes different meaning in different positions), and SemVer does not specify anything as it is concerned only with the version part of the string to identify a pre-release suffix RPM and DEB use ~ and SemVer uses - to identify a rebuild suffix DEB uses +, SemVer uses ., and RPM increases the release part of the version to identify an epoch prefix DEB and RPM use :, and SemVer does not specify anything Examples # Examples (with \u0026rsquo;\u0026rsquo; meaning the empty string):
11 == 11 systemd-123 == systemd-123 bar-123 \u0026lt; foo-123 123a \u0026gt; 123 123.a \u0026gt; 123 123.a \u0026lt; 123.b 123a \u0026gt; 123.a 11α == 11β B \u0026lt; a \u0026rsquo;\u0026rsquo; \u0026lt; 0 0. \u0026gt; 0 0.0 \u0026gt; 0 0 \u0026gt; ~ \u0026rsquo;\u0026rsquo; \u0026gt; ~ 1_ == 1 _1 == 1 1_ \u0026lt; 1.2 1_2_3 \u0026gt; 1.3.3 1+ == 1 +1 == 1 1+ \u0026lt; 1.2 1+2+3 \u0026gt; 1.3.3 Note how in the 1_2_3 \u0026gt; 1.3.3 and 1+2+3 \u0026gt; 1.3.3 cases, the underscore and plus characters act as separators between components, so we first compare 1 with 1.3.3 as numerical version strings, and 1 \u0026lt; 1.3.3. The remainder of the first string is not used in the comparison.
122.1 \u0026lt; 123~rc1-1 \u0026lt; 123 \u0026lt; 123-a \u0026lt; 123-a.1 \u0026lt; 123-1 \u0026lt; 123-1.1 \u0026lt; 123^post1 \u0026lt; 123.a-1 \u0026lt; 123.1-1 \u0026lt; 123a-1 \u0026lt; 124-1 In the above example each entry compares smaller than every entry to its right and equal only to itself, conversely each entry compares larger to every entry to its left and compares unequal to all except itself.
Notes # systemd-analyze implements this version comparison algorithm as
systemd-analyze compare-versions \u0026lt;version-a\u0026gt; \u0026lt;version-b\u0026gt; `})})()