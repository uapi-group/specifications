'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/specifications/docs/base_directory_specification/','title':"Base Directory Specification",'section':"Docs",'content':"Base Directory Specification #  Introduction #  Various specifications specify files and file formats. This specification defines where these files should be looked for by defining one or more base directories relative to which files should be located.\nBasics #  The XDG Base Directory Specification is based on the following concepts:\n  There is a single base directory relative to which user-specific data files should be written. This directory is defined by the environment variable $XDG_DATA_HOME.\n  There is a single base directory relative to which user-specific configuration files should be written. This directory is defined by the environment variable $XDG_CONFIG_HOME.\n  There is a single base directory relative to which user-specific state data should be written. This directory is defined by the environment variable $XDG_STATE_HOME.\n  There is a single base directory relative to which user-specific executable files may be written.\n  There is a set of preference ordered base directories relative to which data files should be searched. This set of directories is defined by the environment variable $XDG_DATA_DIRS.\n  There is a set of preference ordered base directories relative to which configuration files should be searched. This set of directories is defined by the environment variable $XDG_CONFIG_DIRS.\n  There is a single base directory relative to which user-specific non-essential (cached) data should be written. This directory is defined by the environment variable $XDG_CACHE_HOME.\n  There is a single base directory relative to which user-specific runtime files and other file objects should be placed. This directory is defined by the environment variable $XDG_RUNTIME_DIR.\n  All paths set in these environment variables must be absolute. If an implementation encounters a relative path in any of these variables it should consider the path invalid and ignore it.\nEnvironment variables #  $XDG_DATA_HOME defines the base directory relative to which user-specific data files should be stored. If $XDG_DATA_HOME is either not set or empty, a default equal to $HOME/.local/share should be used.\n$XDG_CONFIG_HOME defines the base directory relative to which user-specific configuration files should be stored. If $XDG_CONFIG_HOME is either not set or empty, a default equal to $HOME/.config should be used.\n$XDG_STATE_HOME defines the base directory relative to which user-specific state files should be stored. If $XDG_STATE_HOME is either not set or empty, a default equal to $HOME/.local/state should be used.\nThe $XDG_STATE_HOME contains state data that should persist between (application) restarts, but that is not important or portable enough to the user that it should be stored in $XDG_DATA_HOME. It may contain:\n  actions history (logs, history, recently used files, \u0026hellip;)\n  current state of the application that can be reused on a restart (view, layout, open files, undo history, \u0026hellip;)\n  User-specific executable files may be stored in $HOME/.local/bin. Distributions should ensure this directory shows up in the UNIX $PATH environment variable, at an appropriate place.\nSince $HOME might be shared between systems of different achitectures, installing compiled binaries to $HOME/.local/bin could cause problems when used on systems of differing architectures. This is often not a problem, but the fact that $HOME becomes partially achitecture-specific if compiled binaries are placed in it should be kept in mind.\n$XDG_DATA_DIRS defines the preference-ordered set of base directories to search for data files in addition to the $XDG_DATA_HOME base directory. The directories in $XDG_DATA_DIRS should be seperated with a colon \u0026lsquo;:\u0026rsquo;.\nIf $XDG_DATA_DIRS is either not set or empty, a value equal to /usr/local/share/:/usr/share/ should be used.\n$XDG_CONFIG_DIRS defines the preference-ordered set of base directories to search for configuration files in addition to the $XDG_CONFIG_HOME base directory. The directories in $XDG_CONFIG_DIRS should be seperated with a colon \u0026lsquo;:\u0026rsquo;.\nIf $XDG_CONFIG_DIRS is either not set or empty, a value equal to /etc/xdg should be used.\nThe order of base directories denotes their importance; the first directory listed is the most important. When the same information is defined in multiple places the information defined relative to the more important base directory takes precedent. The base directory defined by $XDG_DATA_HOME is considered more important than any of the base directories defined by $XDG_DATA_DIRS. The base directory defined by $XDG_CONFIG_HOME is considered more important than any of the base directories defined by $XDG_CONFIG_DIRS.\n$XDG_CACHE_HOME defines the base directory relative to which user-specific non-essential data files should be stored. If $XDG_CACHE_HOME is either not set or empty, a default equal to $HOME/.cache should be used.\n$XDG_RUNTIME_DIR defines the base directory relative to which user-specific non-essential runtime files and other file objects (such as sockets, named pipes, …) be stored. The directory MUST be owned by the user, and he MUST be the only one having read and write access to it. Its Unix access mode MUST be 0700.\nThe lifetime of the directory MUST be bound to the user being logged in. It MUST be created when the user first logs in and if the user fully logs out the directory MUST be removed. If the user logs in more than once he should get pointed to the same directory, and it is mandatory that the directory continues to exist from his first login to his last logout on the system, and not removed in between. Files in the directory MUST not survive reboot or a full logout/login cycle.\nThe directory MUST be on a local file system and not shared with any other system. The directory MUST by fully-featured by the standards of the operating system. More specifically, on Unix-like operating systems AF_UNIX sockets, symbolic links, hard links, proper permissions, file locking, sparse files, memory mapping, file change notifications, a reliable hard link count must be supported, and no restrictions on the file name character set should be imposed. Files in this directory MAY be subjected to periodic clean-up. To ensure that your files are not removed, they should have their access time timestamp modified at least once every 6 hours of monotonic time or the \u0026lsquo;sticky\u0026rsquo; bit should be set on the file.\nIf $XDG_RUNTIME_DIR is not set applications should fall back to a replacement directory with similar capabilities and print a warning message. Applications should use this directory for communication and synchronization purposes and should not place larger files in it, since it might reside in runtime memory and cannot necessarily be swapped out to disk.\nReferencing this specification #  Other specifications may reference this specification by specifying the location of a data file as $XDG_DATA_DIRS/subdir/filename. This implies that:\n  Such file should be installed to $datadir/subdir/filename with $datadir defaulting to /usr/share.\n  A user-specific version of the data file may be created in $XDG_DATA_HOME/subdir/filename, taking into account the default value for $XDG_DATA_HOME if $XDG_DATA_HOME is not set.\n  Lookups of the data file should search for ./subdir/filename relative to all base directories specified by $XDG_DATA_HOME and $XDG_DATA_DIRS . If an environment variable is either not set or empty, its default value as defined by this specification should be used instead.\n  Specifications may reference this specification by specifying the location of a configuration file as $XDG_CONFIG_DIRS/subdir/filename. This implies that:\n  Default configuration files should be installed to $sysconfdir/xdg/subdir/filename with $sysconfdir defaulting to /etc.\n  A user-specific version of the configuration file may be created in $XDG_CONFIG_HOME/subdir/filename, taking into account the default value for $XDG_CONFIG_HOME if $XDG_CONFIG_HOME is not set.\n  Lookups of the configuration file should search for ./subdir/filename relative to all base directories indicated by $XDG_CONFIG_HOME and $XDG_CONFIG_DIRS . If an environment variable is either not set or empty, its default value as defined by this specification should be used instead.\n  If, when attempting to write a file, the destination directory is non-existent an attempt should be made to create it with permission 0700. If the destination directory exists already the permissions should not be changed. The application should be prepared to handle the case where the file could not be written, either because the directory was non-existent and could not be created, or for any other reason. In such case it may choose to present an error message to the user.\nWhen attempting to read a file, if for any reason a file in a certain directory is unaccessible, e.g. because the directory is non-existent, the file is non-existent or the user is not authorized to open the file, then the processing of the file in that directory should be skipped. If due to this a required file could not be found at all, the application may choose to present an error message to the user.\nA specification that refers to $XDG_DATA_DIRS or $XDG_CONFIG_DIRS should define what the behaviour must be when a file is located under multiple base directories. It could, for example, define that only the file under the most important base directory should be used or, as another example, it could define rules for merging the information from the different files.\n"});index.add({'id':1,'href':'/specifications/docs/boot_loader_specification/','title':"Boot Loader Specification",'section':"Docs",'content':"The Boot Loader Specification #  This document defines a set of file formats and naming conventions that allow the boot loader menu entries to be shared between multiple operating systems and boot loaders installed on one device.\nOperating systems cooperatively manage boot loader menu entry directories that contain drop-in files, making multi-boot scenarios easy to support. Boot menu entries are defined via two simple formats that can be understood by different boot loader implementations, operating systems, and userspace programs. The same scheme can be used to prepare OS media for cases where the firmware includes a boot loader.\nTarget Audience #  The target audience for this specification is:\n Boot loader developers, to write a boot loader that directly reads its menu entries from these files Firmware developers, to add generic boot loading support directly to the firmware itself OS installer developers, to create appropriate partitions and set up the initial boot loader menu entries Distribution developers, to create appropriate menu entry snippets when installing or updating kernel packages UI developers, to implement user interfaces that list and select among the available boot options  The Partitions #  Everything described below is located on one or two partitions. The boot loader or user-space programs reading the boot loader menu entries should locate them in the following manner:\n  On disks with an MBR partition table:\n The boot partition — a partition with the type ID of 0xEA — shall be used as the single location for boot loader menu entries.    On disks with GPT (GUID Partition Table)\n  The EFI System Partition (ESP for short) — a partition with a GPT type GUID of c12a7328-f81f-11d2-ba4b-00a0c93ec93b — may be used as one of two locations for boot loader menu entries.\n  Optionally, an Extended Boot Loader Partition (XBOOTLDR partition for short) — a partition with GPT type GUID of bc13c2ff-59e6-4262-a352-b275fd6f7172 — may be used as the second of two locations for boot loader menu entries. This partition must be located on the same disk as the ESP.\n    There may be at most one partition of each of the types listed above on the same disk.\nNote: These partitions are shared among all OS installations on the same disk. Instead of maintaining one boot partition per installed OS (as /boot/ was traditionally handled), all installed OSes use the same place for boot loader menu entries.\nFor systems where the firmware is able to read file systems directly, the ESP must — and the MBR boot and GPT XBOOTLDR partition should — be a file system readable by the firmware. For most systems this means VFAT (16 or 32 bit). Applications accessing both partitions should hence not assume that fancier file system features such as symlinks, hardlinks, access control or case sensitivity are supported.\nThe $BOOT Partition Placeholder #  In the text below, the placeholder $BOOT will be used to refer to the partition determined as follows:\n  On disks with an MBR partition table: → the boot partition, as described above\n  On disks with a GPT partition table: → the XBOOTLDR partition if it exists\n  Otherwise, on disks with a GPT partition table: → the ESP\n  $BOOT is the primary place to put boot menu entry resources into, but typically not the only one. Most importantly, boot loaders should also pick up menu entries from the ESP, even if XBOOTLDR exists (for details see below).\nCreating These Partitions #  An installer for an operating system should use this logic when selecting or creating partitions:\n  If a boot partition (in case of MBR) or an XBOOTLDR partition (in case of GPT) already exists it should be used as $BOOT and used as primary location to place boot loader menu resources in.\n  Otherwise, if on GPT and an ESP is found and it is large enough (let\u0026rsquo;s say at least 1G) it should be used as $BOOT and used as primary location to place boot loader menu resources in.\n  Otherwise, if on GPT and neither XBOOTLDR nor ESP exist, an ESP should be created of the appropriate size and be used as $BOOT, and used as primary location to place boot loader menu resources in.\n  Otherwise, a boot partition (in case of MBR) or XBOOTLDR partition (in case of GPT) should be created of an appropriate size, and be used as $BOOT, and used as primary location to place boot loader menu resources in.\n  These partitions shall be determined during installation time, and /etc/fstab entries may be created.\nMount Points #  It is recommended to mount $BOOT to /boot/, and the ESP to /efi/. If $BOOT and the ESP are the same, then either a bind mount or a symlink should be established making the partition available under both paths.\n(Mounting the ESP to /boot/efi/, as was traditionally done, is not recommended. Such a nested setup complicates an implementation via direct autofs mounts — as implemented by systemd for example —, as establishing the inner autofs will trigger the outer one. Mounting the two partitions via autofs is recommended because the simple VFAT file system has weak data integrity properties and should remain unmounted whenever possible.)\nBoot Loader Entries #  This specification defines two types of boot loader entries. The first type is text based, very simple, and suitable for a variety of firmware, architecture and image types (\u0026ldquo;Type #1\u0026rdquo;). The second type is specific to EFI, but allows single-file images that embed all metadata in the kernel binary itself, which is useful to cryptographically sign them as one file for the purpose of SecureBoot (\u0026ldquo;Type #2\u0026rdquo;).\nNot all boot loader entries will apply to all systems. For example, Type #1 entries that use the efi key and all Type #2 entries only apply to EFI systems. Entries using the architecture key might specify an architecture that doesn\u0026rsquo;t match the local one. Boot loaders should ignore all entries that don\u0026rsquo;t match the local platform and what the boot loader can support, and hide them from the user. Only entries matching the feature set of boot loader and system shall be considered and displayed. This allows image builders to put together images that transparently support multiple different architectures.\nNote that the three partitions described above are not supposed to be the exclusive territory of this specification. This specification only defines semantics of the /loader/entries/ directory (along with the companion file /loader/entries.srel) and the /EFI/Linux/ directory inside the file system, but it doesn\u0026rsquo;t intend to define contents of the rest of the file system. Boot loaders, firmware, and other software implementing this specification may choose to place other files and directories in the same file system. For example, boot loaders that implement this specification might install their own boot code on the same partition; this is particularly common in the case of the ESP. Implementations of this specification must be able to operate correctly if files or directories other than /loader/entries/ and /EFI/Linux/ are found in the top level directory. Implementations that add their own files or directories to the file systems should use well-named directories, to make name collisions between multiple users of the file system unlikely.\nType #1 Boot Loader Specification Entries #  /loader/entries/ in $BOOT is the primary directory containing Type #1 drop-in snippets defining boot entries, one .conf file for each boot menu item. Each OS may provide one or more such entries.\nIf the ESP is separate from $BOOT it may also contain a /loader/entries/ directory, where the boot loader should look for boot entry snippets, as an additional source. The boot loader should enumerate both directories and present a merged list to the user. Note that this is done for compatibility only: while boot loaders should look in both places, OSes should only add their files to $BOOT.\nNote: In all cases the /loader/entries/ directory should be located directly in the root of the file system. Specifically, the /loader/entries/ directory should not be located under the /EFI/ subdirectory on the ESP.\nThe file name of the boot entry snippets is used for identification of the boot item but shall never be presented to the user in the UI. The file name may be chosen freely but should be unique enough to avoid clashes between OS installations. More specifically, it is suggested to include the entry-token (see kernel-install) or machine ID (see /etc/machine-id), and the kernel version (as returned by uname -r, including the OS identifier), so that the whole filename is $BOOT/loader/entries/\u0026lt;entry-token-or-machine-id\u0026gt;-\u0026lt;version\u0026gt;.conf.\nExample: $BOOT/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf.\nIn order to maximize compatibility with file system implementations and restricted boot loader environments, and to minimize conflicting character use with other programs, file names shall be chosen from a restricted character set: ASCII upper and lower case characters, digits, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;-\u0026rdquo;, \u0026ldquo;_\u0026rdquo; and \u0026ldquo;.\u0026rdquo;. Also, the file names should have a length of at least one and at most 255 characters (including the file name suffix).\nThese boot loader menu snippets shall be UNIX-style text files (i.e. lines separated by a single newline character), in the UTF-8 encoding. The boot loader menu snippets are loosely inspired by Grub1\u0026rsquo;s configuration syntax. Lines beginning with \u0026ldquo;#\u0026rdquo; are used for comments and shall be ignored. The first word of a line is used as key and is separated by one or more spaces from the value.\nType #1 Boot Loader Entry Keys #  The following keys are recognized:\n  title is a human-readable title for this menu item to be displayed in the boot menu. It is a good idea to initialize this from the PRETTY_NAME= of os-release. This name should be descriptive and does not have to be unique. If a boot loader discovers two entries with the same title it should show more than just the raw title in the UI, for example by appending the version field. This field is optional.\nExample: title Fedora 18 (Spherical Cow)\n  version is a human-readable version for this menu item. This is usually the kernel version and is intended for use by OSes to install multiple kernel versions with the same title field. This field is used for sorting entries, so that the boot loader can order entries by age or select the newest one automatically. This field is optional.\nSee Sorting below.\nExample: version 3.7.2-201.fc18.x86_64\n  machine-id is the machine ID of the OS. This can be used by boot loaders and applications to filter out boot entries, for example to show only a single newest kernel per OS, to group items by OS, or to filter out the currently booted OS when showing only other installed operating systems. This ID shall be formatted as 32 lower case hexadecimal characters (i.e. without any UUID formatting). This key is optional.\nExample: machine-id 4098b3f648d74c13b1f04ccfba7798e8\n  sort-key is a short string used for sorting entries on display. This should typically be initialized from the IMAGE_ID= or ID= fields of os-release, possibly with an additional suffix. This field is optional.\nExample: sort-key fedora\n  linux is the Linux kernel image to execute and takes a path relative to the root of the file system containing the boot entry snippet itself. It is recommended that every distribution creates an entry-token/machine-id and version specific subdirectory and places its kernels and initrd images there (see below).\nExample: linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux\n  initrd is the initrd cpio image to use when executing the kernel. This key may appear more than once in which case all specified images are used, in the order they are listed.\nExample: initrd 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd\n  efi refers to an arbitrary EFI program. If this key is set, and the system is not an EFI system, this entry should be hidden.\n  options shall contain kernel parameters to pass to the Linux kernel to spawn. This key is optional and may appear more than once in which case all specified parameters are combined in the order they are listed.\nExample: options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet\n  devicetree refers to the binary device tree to use when executing the kernel. This key is optional.\nExample: devicetree 6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.armv7hl/tegra20-paz00.dtb\n  devicetree-overlay refers to a list of device tree overlays that should be applied by the boot loader. Multiple overlays are separated by spaces and applied in the same order as they are listed. This key is optional but depends on the devicetree key.\nExample: devicetree-overlay /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo\n  architecture refers to the architecture this entry is for. The argument should be an architecture identifier, using the architecture vocabulary defined by the EFI specification (i.e. IA32, x64, IA64, ARM, AA64, …). If specified and it does not match the local system architecture this entry should be hidden. The comparison should be done case-insensitively.\nExample: architecture aa64\n  Each boot loader menu entry drop-in snippet must include at least a linux or an efi key. Here is an example for a complete drop-in file:\n# /boot/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf title Fedora 19 (Rawhide) sort-key fedora machine-id 6a9857a393724b7a981ebb5b8495b9ea version 3.8.0-2.fc19.x86_64 options root=UUID=6d3376e4-fc93-4509-95ec-a21d68011da2 quiet architecture x64 linux /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux initrd /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd  On EFI systems all Linux kernel images should be EFI images. In order to increase compatibility with EFI systems it is highly recommended only to install EFI kernel images, even on non-EFI systems, if that\u0026rsquo;s applicable and supported on the specific architecture.\nConversely, in order to increase compatibility it is recommended to install generic kernel images that make few assumptions about the firmware they run on, i.e. it is a good idea that both images shipped as UEFI PE images and those which are not don\u0026rsquo;t make unnecessary assumption on the underlying firmware, i.e. don\u0026rsquo;t hard depend on legacy BIOS calls or UEFI boot services.\nWhen Type #1 boot loader menu entry snippets refer to other files (for linux, initrd, efi, devicetree, and devicetree-overlay), those files must be located on the same partition, and the paths must be absolute paths relative to the root of that file system. The naming of those files can be chosen by the installer. A recommended scheme is described in the next section. Paths should be normalized, i.e. not include .., . or a sequence of more than one /. Paths may be prefixed with a /, but this is optional and has the same effect as paths without it: all paths are always relative to the root directory of the partition they are referenced from.\nEven though the backing file system is typically case-insensitive (i.e. VFAT) it is strongly recommended to reference files in the casing actually used for the directories/files, so that placing these files on other file systems is still safe and robust.\nRecommended Directory Layout for Additional Files #  It is recommended to place the kernel and other other files comprising a single boot loader entry in a separate directory: /\u0026lt;entry-token-or-machine-id\u0026gt;/\u0026lt;version\u0026gt;/. This naming scheme uses the same elements as the boot loader menu entry snippet, providing the same level of uniqueness.\nExample: $BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux $BOOT/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd\nOther naming schemes are possible. In particular, traditionally a flat naming scheme with files in the root directory was used. This is not recommended because it is hard to avoid conflicts in a multi-boot installation.\nStandard-conformance Marker File #  Unfortunately, there are implementations of boot loading infrastructure that are also using the /loader/entries/ directory, but install files that do not follow this specification. In order to minimize confusion, a boot loader implementation may place the file /loader/entries.srel next to the /loader/entries/ directory containing the ASCII string type1 (followed by a UNIX newline). Tools that need to determine whether an existing directory implements the semantics described here may check for this file and contents: if it exists and contains the mentioned string, it shall assume a standards-compliant implementation is in place. If it exists but contains a different string it shall assume other semantics are implemented. If the file does not exist, no assumptions should be made.\nType #2 EFI Unified Kernel Images #  A unified kernel image is a single EFI PE executable combining an EFI stub loader, a kernel image, an initrd image, and the kernel command line. See systemd-stub(7) for details. The primary place for such unified images is the /EFI/Linux/ directory in $BOOT. Operating systems should place unified EFI kernels only in the $BOOT partition. Boot loaders should also look in the /EFI/Linux/ of the ESP — if it is different from $BOOT — and present a merged list of menu entries from both partitions. Regardless if placed in the primary or secondary location: the files must have the extension .efi. Support for images of this type is of course specific to systems with EFI firmware. Ignore this section if you work on systems not supporting EFI.\nType #2 file names should be chosen from the same restricted character set as Type #1 described above (but with the file name suffix of .efi instead of .conf).\nImages of this type have the advantage that all metadata and payload that makes up the boot entry is contained in a single PE file that can be signed cryptographically as one for the purpose of EFI SecureBoot.\nA valid unified kernel image in the /EFI/Linux/ directory must contain two PE sections:\n .cmdline section with the kernel command line, .osrel section with an embedded copy of the os-release file describing the image.  The PRETTY_NAME= and VERSION_ID= fields in the embedded os-release file are used the same as title and version in the Type #1 entries. The .cmdline section is used instead of the options field. linux and initrd fields are not necessary, and there is no counterpart for the machine-id field.\nOn EFI, any such images shall be added to the list of valid boot entries.\nAdditional Notes #  Note that these boot entry snippets and unified kernels do not need to be the only menu entry sources for a boot loader. It may extend this list of entries with additional items from other configuration files (for example its own native configuration files) or automatically detected other entries without explicit configuration.\nTo make this explicitly clear: this specification is designed with \u0026ldquo;free\u0026rdquo; operating systems in mind, starting Windows or MacOS is out of focus with these boot loader menu entry snippets, use boot-loader specific solutions for that. In the text above, if we say \u0026ldquo;OS\u0026rdquo; we hence imply \u0026ldquo;free\u0026rdquo;, i.e. primarily Linux (though this could be easily be extended to the BSDs and whatnot).\nNote that all paths used in the boot loader menu entry snippets use a Unix-style \u0026ldquo;/\u0026rdquo; as path separator. This needs to be converted to an EFI-style \u0026ldquo;\\\u0026rdquo; separator in EFI boot loaders.\nLocating Boot Entries #  A boot loader locates the XBOOTLDR partition and the ESP, then simply reads all the files /loader/entries/*.conf in them, and populates its boot menu (and handle gracefully if one of the two partitions is missing). On EFI, it then extends this with any unified kernel images found in /EFI/Linux/*.efi in the two partitions. It may also add additional entries, for example a \u0026ldquo;Reboot into firmware\u0026rdquo; option. Optionally it may sort the menu based on the sort-key, machine-id and version fields, and possibly others. It uses the file name to identify specific items, for example in case it supports storing away default entry information somewhere. A boot loader should generally not modify these files.\nFor \u0026ldquo;Boot Loader Specification Entries\u0026rdquo; (Type #1), the kernel package installer installs the kernel and initrd images to $BOOT. It is recommended to place these files in a vendor and OS and installation specific directory. It then generates a boot loader menu entry snippet, placing it in $BOOT/loader/entries/xyz.conf, with \u0026ldquo;xyz\u0026rdquo; as concatenation of entry-token/machine-id and version information (see above). The files created by a kernel package are tied to the kernel package and should be removed along with it.\nFor \u0026ldquo;EFI Unified Kernel Images\u0026rdquo; (Type #2), the vendor or kernel package installer should create the combined image and drop it into $BOOT/EFI/Linux/. This file is also tied to the kernel package and should be removed along with it.\nA UI application intended to show available boot options shall operate similarly to a boot loader (and thus search both $BOOT and the ESP if distinct), but might apply additional filters, for example by filtering the booted OS via the machine ID, or by suppressing all but the newest kernel versions.\nAn OS installer picks the right place for $BOOT as defined above (possibly creating a partition and file system for it) and creates the /loader/entries/ directory and the /loader/entries.srel file in it (the latter only if the directory didn\u0026rsquo;t exist yet). It then installs an appropriate boot loader that can read these snippets. Finally, it installs one or more kernel packages.\nBoot counting #  The main idea is that when boot entries are initially installed, they are marked as \u0026ldquo;indeterminate\u0026rdquo; and assigned a number of boot attempts. Each time the boot loader tries to boot an entry, it decreases this count by one. If the operating system considers the boot as successful, it removes the counter altogether and the entry becomes \u0026ldquo;good\u0026rdquo;. Otherwise, once the assigned number of boots is exhausted, the entry is marked as \u0026ldquo;bad\u0026rdquo;.\nWhich boots are \u0026ldquo;successful\u0026rdquo; is determined by the operating system. systemd provides a generic mechanism that can be extended with arbitrary checks and actions, see Automatic Boot Assessment, but the boot counting mechanism described in this specification can also be used with other implementations.\nThe boot counting data is stored in the name of the boot loader entry. A boot loader entry file name may contain a plus (+) followed by a number. This may optionally be followed by a minus (-) followed by a second number. The dot (.) and file name suffix (conf of efi) must immediately follow. Boot counting is enabled for entries which match this pattern.\nThe first number is the \u0026ldquo;tries left\u0026rdquo; counter signifying how many attempts to boot this entry shall still be made. The second number is the \u0026ldquo;tries done\u0026rdquo; counter, showing how many failed attempts to boot it have already been made. Each time a boot loader entry marked this way is booted, the first counter is decremented, and the second one incremented. (If the second counter is missing, then it is assumed to be equivalent to zero.) If the \u0026ldquo;tries left\u0026rdquo; counter is above zero the entry is still considered \u0026ldquo;indeterminate\u0026rdquo;. A boot entry with the \u0026ldquo;tries left\u0026rdquo; counter at zero is considered \u0026ldquo;bad\u0026rdquo;.\nIf the boot attempt completed successfully the entry\u0026rsquo;s counters are removed from the name (entry state becomes \u0026ldquo;good\u0026rdquo;), thus turning off boot counting for this entry.\nSorting #  The boot loader menu should generally show entries in some order meaningful to the user. The title key is free-form and not suitable to be used as the primary sorting key. Instead, the boot loader should use the following rules:\n  Entries which are subject to boot counting and are marked as \u0026ldquo;bad\u0026rdquo;, should be sorted later than all other entries. Entries which are marked as \u0026ldquo;indeterminate\u0026rdquo; or \u0026ldquo;good\u0026rdquo; (or were not subject to boot counting at all), are thus sorted earlier.\n  If sort-key is set on both entries, use in order of priority, the sort-key (A-Z, increasing alphanumerical order), machine-id (A-Z, increasing alphanumerical order), and version keys (decreasing version order).\n  If sort-key is set on one entry, it sorts earlier.\n  At the end, if necessary, when sort-key is not set or those fields are not set or are all equal, the boot loader should sort using the file name of the entry (decreasing version sort), with the suffix removed.\n  Note: This description assumes that the boot loader shows entries in a traditional menu, with newest and \u0026ldquo;best\u0026rdquo; entries at the top, thus entries with a higher version number are sorter earlier. The boot loader is free to use a different direction (or none at all) during display.\nNote: The boot loader should allow booting \u0026ldquo;bad\u0026rdquo; entries, e.g. in case no other entries are left or they are unusable for other reasons. It may deemphasize or hide such entries by default.\nNote: \u0026ldquo;Bad\u0026rdquo; boot entries have a suffix of \u0026ldquo;+0-n\u0026rdquo;, where n is the number of failed boot attempts. Removal of the suffix is not necessary for comparisons described by the last point above. In the unlikely scenario that we have multiple such boot entries that differ only by the boot counting data, we would sort them by n.\nAlphanumerical Order #  Free-form strings and machine IDs should be compared using a method equivalent to strcmp(3) on their UTF-8 representations. If just one of the strings is unspecified or empty, it compares lower. If both strings are unspecified or empty, they compare equal.\nVersion Order #  The following method should be used to compare version strings. The algorithm is based on rpm\u0026rsquo;s rpmvercmp(), but not identical.\nASCII letters (a-z, A-Z) and digits (0-9) form alphanumerical components of the version. Minus (-) separates the version and release parts. Dot (.) separates parts of version or release. Tilde (~) is a prefix that always compares lower. Caret (^) is a prefix that always compares higher.\nBoth strings are compared from the beginning until the end, or until the strings are found to compare as different. In a loop:\n Any characters which are outside of the set of listed above (a-z, A-Z, 0-9, -, ., ~, ^) are skipped in both strings. In particular, this means that non-ASCII characters that are Unicode digits or letters are skipped too. If one of the strings has ended: if the other string hasn\u0026rsquo;t, the string that has remaining characters compares higher. Otherwise, the strings compare equal. If the remaining part of one of strings starts with ~: if other remaining part does not start with ~, the string with ~ compares lower. Otherwise, both tilde characters are skipped. The check from point 2. is repeated here. If the remaining part of one of strings starts with -: if the other remaining part does not start with -, the string with - compares lower. Otherwise, both minus characters are skipped. If the remaining part of one of strings starts with ^: if the other remaining part does not start with ^, the string with ^ compares higher. Otherwise, both caret characters are skipped. If the remaining part of one of strings starts with .: if the other remaining part does not start with ., the string with . compares lower. Otherwise, both dot characters are skipped. If either of the remaining parts starts with a digit, numerical prefixes are compared numerically. Any leading zeroes are skipped. The numerical prefixes (until the first non-digit character) are evaluated as numbers. If one of the prefixes is empty, it evaluates as 0. If the numbers are different, the string with the bigger number compares higher. Otherwise, the comparison continues at the following characters at point 1. Leading alphabetical prefixes are compared alphabetically. The substrings are compared letter-by-letter. If both letters are the same, the comparison continues with the next letter. Capital letters compare lower than lower-case letters (A \u0026lt; a). When the end of one substring has been reached (a non-letter character or the end of the whole string), if the other substring has remaining letters, it compares higher. Otherwise, the comparison continues at the following characters at point 1.  Examples (with '' meaning the empty string):\n 11 == 11 systemd-123 == systemd-123 bar-123 \u0026lt; foo-123 123a \u0026gt; 123 123.a \u0026gt; 123 123.a \u0026lt; 123.b 123a \u0026gt; 123.a 11α == 11β A \u0026lt; a '' \u0026lt; 0 0. \u0026gt; 0 0.0 \u0026gt; 0 0 \u0026lt; ~ '' \u0026lt; ~  Note: systemd-analyze implements this version comparison algorithm as\nsystemd-analyze compare-versions \u0026lt;version-a\u0026gt; \u0026lt;version-b\u0026gt; Additional discussion #  Why is there a need for this specification? #  This specification brings the following advantages:\n  Installation of new boot entries is more robust, as no explicit rewriting of configuration files is required.\n  It allows an out-of-the-box boot experience on any platform without the need of traditional firmware mechanisms (e.g. BIOS calls, UEFI Boot Services).\n  It improves dual-boot scenarios. Without cooperation, multiple Linux installations tend to fight over which boot loader becomes the primary one in possession of the MBR or the boot partition, and only that one installation can then update the boot loader configuration. Other Linux installs have to be manually configured to never touch the MBR and instead install a chain-loaded boot loader in their own partition headers. In this new scheme all installations share a loader directory and no manual configuration has to take place. All participants implicitly cooperate due to removal of name collisions and can install/remove their own boot menu entries without interfering with the entries of other installed operating systems.\n  Drop-in directories are now pretty ubiquitous on Linux as an easy way to extend boot loader menus without having to edit, regenerate or manipulate configuration files. For the sake of uniformity, we should do the same for the boot menu.\n  Userspace code can sanely parse boot loader menu entries which is essential with modern firmware which does not necessarily initialize USB keyboards during boot, which makes boot menus hard to reach for the user. If userspace code can parse the boot loader menu entries too, UI can be written that select a boot menu item to boot into before rebooting the machine, thus not requiring interactivity during early boot.\n  To unify and thus simplify menu entries of the various boot loaders, which makes configuration of the boot loading process easier for users, administrators, and developers alike.\n  For boot loaders with configuration scripts such as grub2, adopting this spec allows for mostly static scripts that are generated only once at first installation, but then do not need to be updated anymore as that is done via drop-in files exclusively.\n  Why not simply rely on the EFI boot menu logic? #  EFI is not ubiquitous, especially not in embedded systems. But even on systems with EFI, which provides a boot options logic that can offer similar functionality, this specification is still needed for the following reasons:\n  The various EFI implementations implement the boot order/boot item logic to different levels. Some firmware implementations do not offer a boot menu at all and instead unconditionally follow the EFI boot order, booting the first item that is working.\n  If the firmware setup is used to reset data, usually all EFI boot entries are lost, making the system entirely unbootable, as the firmware setups generally do not offer a UI to define additional boot items. By placing the menu item information on disk, it is always available, even if the firmware configuration is lost.\n  Harddisk images should be movable between machines and be bootable without requiring firmware configuration. This also requires that the list of boot options is defined on disk, and not in EFI variables alone.\n  EFI is not universal yet (especially on non-x86 platforms), this specification is useful both for EFI and non-EFI boot loaders.\n  Many EFI systems disable USB support during early boot to optimize boot times, thus making keyboard input unavailable in the EFI menu. It is thus useful if the OS UI has a standardized way to discover available boot options which can be booted to.\n  Why is the version comparison logic so complicated? #  The sort-key allows us to group entries by \u0026ldquo;operating system\u0026rdquo;, e.g. all versions of Fedora together, no matter if they identify themselves as \u0026ldquo;Fedora Workstation\u0026rdquo; or \u0026ldquo;Fedora Rawhide (prerelease)\u0026rdquo;. The sort-key was introduced only recently, so we need to provide a meaningful order for entries both with and without it. Since it is a new concept, it is assumed that entries with sort-key are newer.\nIn a traditional menu with entries displayed vertically, we want names to be sorter alpabetically (CentOS, Debian, Fedora, OpenSUSE, …), it would be strange to have them in reverse order. But when multiple kernels are available for the same installation, we want to display the latest kernel with highest priority, i.e. earlier in the list.\nWhy do you use file renames to store the counter? Why not a regular file? #  Mainly two reasons: it\u0026rsquo;s relatively likely that renames can be implemented atomically even in simpler file systems, as renaming generally avoids allocating or releasing data blocks. Writing to file contents has a much bigger chance to be result in incomplete or corrupt data. Moreover renaming has the benefit that the boot count metadata is directly attached to the boot loader entry file, and thus the lifecycle of the metadata and the entry itself are bound together. This means no additional clean-up needs to take place to drop the boot loader counting information for an entry when it is removed.\nWhy not use EFI variables for storing the boot counter? #  The memory chips used to back the persistent EFI variables are generally not of the highest quality, hence shouldn\u0026rsquo;t be written to more than necessary. This means we can\u0026rsquo;t really use it for changes made regularly during boot, but should use it only for seldom-made configuration changes.\nOut of Focus #  There are a couple of items that are out of focus for this specification:\n  If userspace can figure out the available boot options, then this is only useful so much: we\u0026rsquo;d still need to come up with a way how userspace could communicate to the boot loader the default boot loader entry temporarily or persistently. Defining a common scheme for this is certainly a good idea, but out of focus for this specification.\n  This specification is just about \u0026ldquo;Free\u0026rdquo; Operating systems. Hooking in other operating systems (like Windows and macOS) into the boot menu is a different story and should probably happen outside of this specification. For example, boot loaders might choose to detect other available OSes dynamically at runtime without explicit configuration (like systemd-boot does it), or via native configuration (for example via explicit Grub2 configuration generated once at installation).\n  This specification leaves undefined what to do about systems which are upgraded from an OS that does not implement this specification. As the previous boot loader logic was largely handled by in distribution-specific ways we probably should leave the upgrade path (and whether there actually is one) to the distributions. The simplest solution might be to simply continue with the old scheme for old installations and use this new scheme only for new installations.\n  Referencing kernels or initrds on other partitions other than the partition containing the Type #1 boot loader entry. This is by design, as specifying other partitions or devices would require a non-trivial language for denoting device paths. In particular this means that on non-EFI systems boot loader menu entry snippets following this specification cannot be used to spawn other operating systems (such as Windows).\n  Links #  GUID Partition Table\nBoot Loader Interface\nDiscoverable Partitions Specification\nsystemd-boot(7)\nbootctl(1)\nsystemd-gpt-auto-generator(8)\n"});index.add({'id':2,'href':'/specifications/docs/discoverable_partitions/','title':"Discoverable Partitions Specification",'section':"Docs",'content':"The Discoverable Partitions Specification (DPS) #  TL;DR: Let\u0026rsquo;s automatically discover, mount and enable the root partition, /home/, /srv/, /var/ and /var/tmp/ and the swap partitions based on GUID Partition Tables (GPT)!\nThis specification describes the use of GUID Partition Table (GPT) UUIDs to enable automatic discovery of partitions and their intended mountpoints. Traditionally Linux has made little use of partition types, mostly just defining one UUID for file system/data partitions and another one for swap partitions. With this specification, we introduce additional partition types for specific uses. This has many benefits:\n OS installers can automatically discover and make sense of partitions of existing Linux installations. The OS can discover and mount the necessary file systems with a non-existent or incomplete /etc/fstab file and without the root= kernel command line option. Container managers (such as nspawn and libvirt-lxc) can introspect and set up file systems contained in GPT disk images automatically and mount them to the right places, thus allowing booting the same, identical images on bare metal and in Linux containers. This enables true, natural portability of disk images between physical machines and Linux containers. As a help to administrators and users partition manager tools can show more descriptive information about partitions tables.  Note that the OS side of this specification is currently implemented in systemd 211 and newer in the systemd-gpt-auto-generator(8) generator tool. Note that automatic discovery of the root only works if the boot loader communicates this information to the OS, by implementing the Boot Loader Interface.\nDefined Partition Type UUIDs #     Name Partition Type UUID Allowed File Systems Explanation     Root Partition (Alpha) 6523f8ae-3eb1-4e2a-a05a-18b695ae656f SD_GPT_ROOT_ALPHA Any native, optionally in LUKS On systems with matching architecture, the first partition with this type UUID on the disk containing the active EFI ESP is automatically mounted to the root directory /. If the partition is encrypted with LUKS or has dm-verity integrity data (see below), the device mapper file will be named /dev/mapper/root.   Root Partition (ARC) d27f46ed-2919-4cb8-bd25-9531f3c16534 SD_GPT_ROOT_ARC ditto ditto   Root Partition (32-bit ARM) 69dad710-2ce4-4e3c-b16c-21a1d49abed3 SD_GPT_ROOT_ARM ditto ditto   Root Partition (64-bit ARM/AArch64) b921b045-1df0-41c3-af44-4c6f280d3fae SD_GPT_ROOT_ARM64 ditto ditto   Root Partition (Itanium/IA-64) 993d8d3d-f80e-4225-855a-9daf8ed7ea97 SD_GPT_ROOT_IA64 ditto ditto   Root Partition (LoongArch 64-bit) 77055800-792c-4f94-b39a-98c91b762bb6 SD_GPT_ROOT_LOONGARCH64 ditto ditto   Root Partition (32-bit MIPS LittleEndian (mipsel)) 37c58c8a-d913-4156-a25f-48b1b64e07f0 SD_GPT_ROOT_MIPS_LE ditto ditto   Root Partition (64-bit MIPS LittleEndian (mips64el)) 700bda43-7a34-4507-b179-eeb93d7a7ca3 SD_GPT_ROOT_MIPS64_LE ditto ditto   Root Partition (HPPA/PARISC) 1aacdb3b-5444-4138-bd9e-e5c2239b2346 SD_GPT_ROOT_PARISC ditto ditto   Root Partition (32-bit PowerPC) 1de3f1ef-fa98-47b5-8dcd-4a860a654d78 SD_GPT_ROOT_PPC ditto ditto   Root Partition (64-bit PowerPC BigEndian) 912ade1d-a839-4913-8964-a10eee08fbd2 SD_GPT_ROOT_PPC64 ditto ditto   Root Partition (64-bit PowerPC LittleEndian) c31c45e6-3f39-412e-80fb-4809c4980599 SD_GPT_ROOT_PPC64_LE ditto ditto   Root Partition (RISC-V 32-bit) 60d5a7fe-8e7d-435c-b714-3dd8162144e1 SD_GPT_ROOT_RISCV32 ditto ditto   Root Partition (RISC-V 64-bit) 72ec70a6-cf74-40e6-bd49-4bda08e8f224 SD_GPT_ROOT_RISCV64 ditto ditto   Root Partition (s390) 08a7acea-624c-4a20-91e8-6e0fa67d23f9 SD_GPT_ROOT_S390 ditto ditto   Root Partition (s390x) 5eead9a9-fe09-4a1e-a1d7-520d00531306 SD_GPT_ROOT_S390X ditto ditto   Root Partition (TILE-Gx) c50cdd70-3862-4cc3-90e1-809a8c93ee2c SD_GPT_ROOT_TILEGX ditto ditto   Root Partition (x86) 44479540-f297-41b2-9af7-d131d5f0458a SD_GPT_ROOT_X86 ditto ditto   Root Partition (amd64/x86_64) 4f68bce3-e8cd-4db1-96e7-fbcaf984b709 SD_GPT_ROOT_X86_64 ditto ditto   /usr/ Partition (Alpha) e18cf08c-33ec-4c0d-8246-c6c6fb3da024 SD_GPT_USR_ALPHA Any native, optionally in LUKS Similar semantics to root partition, but just the /usr/ partition.   /usr/ Partition (ARC) 7978a683-6316-4922-bbee-38bff5a2fecc SD_GPT_USR_ARC ditto ditto   /usr/ Partition (32-bit ARM) 7d0359a3-02b3-4f0a-865c-654403e70625 SD_GPT_USR_ARM ditto ditto   /usr/ Partition (64-bit ARM/AArch64) b0e01050-ee5f-4390-949a-9101b17104e9 SD_GPT_USR_ARM64 ditto ditto   /usr/ Partition (Itanium/IA-64) 4301d2a6-4e3b-4b2a-bb94-9e0b2c4225ea SD_GPT_USR_IA64 ditto ditto   /usr/ Partition (LoongArch 64-bit) e611c702-575c-4cbe-9a46-434fa0bf7e3f SD_GPT_USR_LOONGARCH64 ditto ditto   /usr/ Partition (32-bit MIPS LittleEndian (mipsel)) 0f4868e9-9952-4706-979f-3ed3a473e947 SD_GPT_USR_MIPS_LE ditto ditto   /usr/ Partition (64-bit MIPS LittleEndian (mips64el)) c97c1f32-ba06-40b4-9f22-236061b08aa8 SD_GPT_USR_MIPS64_LE ditto ditto   /usr/ Partition (HPPA/PARISC) dc4a4480-6917-4262-a4ec-db9384949f25 SD_GPT_USR_PARISC ditto ditto   /usr/ Partition (32-bit PowerPC) 7d14fec5-cc71-415d-9d6c-06bf0b3c3eaf SD_GPT_USR_PPC ditto ditto   /usr/ Partition (64-bit PowerPC BigEndian) 2c9739e2-f068-46b3-9fd0-01c5a9afbcca SD_GPT_USR_PPC64 ditto ditto   /usr/ Partition (64-bit PowerPC LittleEndian) 15bb03af-77e7-4d4a-b12b-c0d084f7491c SD_GPT_USR_PPC64_LE ditto ditto   /usr/ Partition (RISC-V 32-bit) b933fb22-5c3f-4f91-af90-e2bb0fa50702 SD_GPT_USR_RISCV32 ditto ditto   /usr/ Partition (RISC-V 64-bit) beaec34b-8442-439b-a40b-984381ed097d SD_GPT_USR_RISCV64 ditto ditto   /usr/ Partition (s390) cd0f869b-d0fb-4ca0-b141-9ea87cc78d66 SD_GPT_USR_S390 ditto ditto   /usr/ Partition (s390x) 8a4f5770-50aa-4ed3-874a-99b710db6fea SD_GPT_USR_S390X ditto ditto   /usr/ Partition (TILE-Gx) 55497029-c7c1-44cc-aa39-815ed1558630 SD_GPT_USR_TILEGX ditto ditto   /usr/ Partition (x86) 75250d76-8cc6-458e-bd66-bd47cc81a812 SD_GPT_USR_X86 ditto ditto   /usr/ Partition (amd64/x86_64) 8484680c-9521-48c6-9c11-b0720656f69e SD_GPT_USR_X86_64 ditto ditto   Root Verity Partition (Alpha) fc56d9e9-e6e5-4c06-be32-e74407ce09a5 SD_GPT_ROOT_ALPHA_VERITY A dm-verity superblock followed by hash data Contains dm-verity integrity hash data for the matching root partition. If this feature is used the partition UUID of the root partition should be the first 128 bits of the root hash of the dm-verity hash data, and the partition UUID of this dm-verity partition should be the final 128 bits of it, so that the root partition and its Verity partition can be discovered easily, simply by specifying the root hash.   Root Verity Partition (ARC) 24b2d975-0f97-4521-afa1-cd531e421b8d SD_GPT_ROOT_ARC_VERITY ditto ditto   Root Verity Partition (32-bit ARM) 7386cdf2-203c-47a9-a498-f2ecce45a2d6 SD_GPT_ROOT_ARM_VERITY ditto ditto   Root Verity Partition (64-bit ARM/AArch64) df3300ce-d69f-4c92-978c-9bfb0f38d820 SD_GPT_ROOT_ARM64_VERITY ditto ditto   Root Verity Partition (Itanium/IA-64) 86ed10d5-b607-45bb-8957-d350f23d0571 SD_GPT_ROOT_IA64_VERITY ditto ditto   Root Verity Partition (LoongArch 64-bit) f3393b22-e9af-4613-a948-9d3bfbd0c535 SD_GPT_ROOT_LOONGARCH64_VERITY ditto ditto   Root Verity Partition (32-bit MIPS LittleEndian (mipsel)) d7d150d2-2a04-4a33-8f12-16651205ff7b SD_GPT_ROOT_MIPS_LE_VERITY ditto ditto   Root Verity Partition (64-bit MIPS LittleEndian (mips64el)) 16b417f8-3e06-4f57-8dd2-9b5232f41aa6 SD_GPT_ROOT_MIPS64_LE_VERITY ditto ditto   Root Verity Partition (HPPA/PARISC) d212a430-fbc5-49f9-a983-a7feef2b8d0e SD_GPT_ROOT_PARISC_VERITY ditto ditto   Root Verity Partition (64-bit PowerPC LittleEndian) 906bd944-4589-4aae-a4e4-dd983917446a SD_GPT_ROOT_PPC64_LE_VERITY ditto ditto   Root Verity Partition (64-bit PowerPC BigEndian) 9225a9a3-3c19-4d89-b4f6-eeff88f17631 SD_GPT_ROOT_PPC64_VERITY ditto ditto   Root Verity Partition (32-bit PowerPC) 98cfe649-1588-46dc-b2f0-add147424925 SD_GPT_ROOT_PPC_VERITY ditto ditto   Root Verity Partition (RISC-V 32-bit) ae0253be-1167-4007-ac68-43926c14c5de SD_GPT_ROOT_RISCV32_VERITY ditto ditto   Root Verity Partition (RISC-V 64-bit) b6ed5582-440b-4209-b8da-5ff7c419ea3d SD_GPT_ROOT_RISCV64_VERITY ditto ditto   Root Verity Partition (s390) 7ac63b47-b25c-463b-8df8-b4a94e6c90e1 SD_GPT_ROOT_S390_VERITY ditto ditto   Root Verity Partition (s390x) b325bfbe-c7be-4ab8-8357-139e652d2f6b SD_GPT_ROOT_S390X_VERITY ditto ditto   Root Verity Partition (TILE-Gx) 966061ec-28e4-4b2e-b4a5-1f0a825a1d84 SD_GPT_ROOT_TILEGX_VERITY ditto ditto   Root Verity Partition (amd64/x86_64) 2c7357ed-ebd2-46d9-aec1-23d437ec2bf5 SD_GPT_ROOT_X86_64_VERITY ditto ditto   Root Verity Partition (x86) d13c5d3b-b5d1-422a-b29f-9454fdc89d76 SD_GPT_ROOT_X86_VERITY ditto ditto   /usr/ Verity Partition (Alpha) 8cce0d25-c0d0-4a44-bd87-46331bf1df67 SD_GPT_USR_ALPHA_VERITY A dm-verity superblock followed by hash data Similar semantics to root Verity partition, but just for the /usr/ partition.   /usr/ Verity Partition (ARC) fca0598c-d880-4591-8c16-4eda05c7347c SD_GPT_USR_ARC_VERITY ditto ditto   /usr/ Verity Partition (32-bit ARM) c215d751-7bcd-4649-be90-6627490a4c05 SD_GPT_USR_ARM_VERITY ditto ditto   /usr/ Verity Partition (64-bit ARM/AArch64) 6e11a4e7-fbca-4ded-b9e9-e1a512bb664e SD_GPT_USR_ARM64_VERITY ditto ditto   /usr/ Verity Partition (Itanium/IA-64) 6a491e03-3be7-4545-8e38-83320e0ea880 SD_GPT_USR_IA64_VERITY ditto ditto   /usr/ Verity Partition (LoongArch 64-bit) f46b2c26-59ae-48f0-9106-c50ed47f673d SD_GPT_USR_LOONGARCH64_VERITY ditto ditto   /usr/ Verity Partition (32-bit MIPS LittleEndian (mipsel)) 46b98d8d-b55c-4e8f-aab3-37fca7f80752 SD_GPT_USR_MIPS_LE_VERITY ditto ditto   /usr/ Verity Partition (64-bit MIPS LittleEndian (mips64el)) 3c3d61fe-b5f3-414d-bb71-8739a694a4ef SD_GPT_USR_MIPS64_LE_VERITY ditto ditto   /usr/ Verity Partition (HPPA/PARISC) 5843d618-ec37-48d7-9f12-cea8e08768b2 SD_GPT_USR_PARISC_VERITY ditto ditto   /usr/ Verity Partition (64-bit PowerPC LittleEndian) ee2b9983-21e8-4153-86d9-b6901a54d1ce SD_GPT_USR_PPC64_LE_VERITY ditto ditto   /usr/ Verity Partition (64-bit PowerPC BigEndian) bdb528a5-a259-475f-a87d-da53fa736a07 SD_GPT_USR_PPC64_VERITY ditto ditto   /usr/ Verity Partition (32-bit PowerPC) df765d00-270e-49e5-bc75-f47bb2118b09 SD_GPT_USR_PPC_VERITY ditto ditto   /usr/ Verity Partition (RISC-V 32-bit) cb1ee4e3-8cd0-4136-a0a4-aa61a32e8730 SD_GPT_USR_RISCV32_VERITY ditto ditto   /usr/ Verity Partition (RISC-V 64-bit) 8f1056be-9b05-47c4-81d6-be53128e5b54 SD_GPT_USR_RISCV64_VERITY ditto ditto   /usr/ Verity Partition (s390) b663c618-e7bc-4d6d-90aa-11b756bb1797 SD_GPT_USR_S390_VERITY ditto ditto   /usr/ Verity Partition (s390x) 31741cc4-1a2a-4111-a581-e00b447d2d06 SD_GPT_USR_S390X_VERITY ditto ditto   /usr/ Verity Partition (TILE-Gx) 2fb4bf56-07fa-42da-8132-6b139f2026ae SD_GPT_USR_TILEGX_VERITY ditto ditto   /usr/ Verity Partition (amd64/x86_64) 77ff5f63-e7b6-4633-acf4-1565b864c0e6 SD_GPT_USR_X86_64_VERITY ditto ditto   /usr/ Verity Partition (x86) 8f461b0d-14ee-4e81-9aa9-049b6fb97abd SD_GPT_USR_X86_VERITY ditto ditto   Root Verity Signature Partition (Alpha) d46495b7-a053-414f-80f7-700c99921ef8 SD_GPT_ROOT_ALPHA_VERITY_SIG A serialized JSON object, see below Contains a root hash and a PKCS#7 signature for it, permitting signed dm-verity GPT images.   Root Verity Signature Partition (ARC) 143a70ba-cbd3-4f06-919f-6c05683a78bc SD_GPT_ROOT_ARC_VERITY_SIG ditto ditto   Root Verity Signature Partition (32-bit ARM) 42b0455f-eb11-491d-98d3-56145ba9d037 SD_GPT_ROOT_ARM_VERITY_SIG ditto ditto   Root Verity Signature Partition (64-bit ARM/AArch64) 6db69de6-29f4-4758-a7a5-962190f00ce3 SD_GPT_ROOT_ARM64_VERITY_SIG ditto ditto   Root Verity Signature Partition (Itanium/IA-64) e98b36ee-32ba-4882-9b12-0ce14655f46a SD_GPT_ROOT_IA64_VERITY_SIG ditto ditto   Root Verity Signature Partition (LoongArch 64-bit) 5afb67eb-ecc8-4f85-ae8e-ac1e7c50e7d0 SD_GPT_ROOT_LOONGARCH64_VERITY_SIG ditto ditto   Root Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) c919cc1f-4456-4eff-918c-f75e94525ca5 SD_GPT_ROOT_MIPS_LE_VERITY_SIG ditto ditto   Root Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) 904e58ef-5c65-4a31-9c57-6af5fc7c5de7 SD_GPT_ROOT_MIPS64_LE_VERITY_SIG ditto ditto   Root Verity Signature Partition (HPPA/PARISC) 15de6170-65d3-431c-916e-b0dcd8393f25 SD_GPT_ROOT_PARISC_VERITY_SIG ditto ditto   Root Verity Signature Partition (64-bit PowerPC LittleEndian) d4a236e7-e873-4c07-bf1d-bf6cf7f1c3c6 SD_GPT_ROOT_PPC64_LE_VERITY_SIG ditto ditto   Root Verity Signature Partition (64-bit PowerPC BigEndian) f5e2c20c-45b2-4ffa-bce9-2a60737e1aaf SD_GPT_ROOT_PPC64_VERITY_SIG ditto ditto   Root Verity Signature Partition (32-bit PowerPC) 1b31b5aa-add9-463a-b2ed-bd467fc857e7 SD_GPT_ROOT_PPC_VERITY_SIG ditto ditto   Root Verity Signature Partition (RISC-V 32-bit) 3a112a75-8729-4380-b4cf-764d79934448 SD_GPT_ROOT_RISCV32_VERITY_SIG ditto ditto   Root Verity Signature Partition (RISC-V 64-bit) efe0f087-ea8d-4469-821a-4c2a96a8386a SD_GPT_ROOT_RISCV64_VERITY_SIG ditto ditto   Root Verity Signature Partition (s390) 3482388e-4254-435a-a241-766a065f9960 SD_GPT_ROOT_S390_VERITY_SIG ditto ditto   Root Verity Signature Partition (s390x) c80187a5-73a3-491a-901a-017c3fa953e9 SD_GPT_ROOT_S390X_VERITY_SIG ditto ditto   Root Verity Signature Partition (TILE-Gx) b3671439-97b0-4a53-90f7-2d5a8f3ad47b SD_GPT_ROOT_TILEGX_VERITY_SIG ditto ditto   Root Verity Signature Partition (amd64/x86_64) 41092b05-9fc8-4523-994f-2def0408b176 SD_GPT_ROOT_X86_64_VERITY_SIG ditto ditto   Root Verity Signature Partition (x86) 5996fc05-109c-48de-808b-23fa0830b676 SD_GPT_ROOT_X86_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (Alpha) 5c6e1c76-076a-457a-a0fe-f3b4cd21ce6e SD_GPT_USR_ALPHA_VERITY_SIG A serialized JSON object, see below Similar semantics to root Verity signature partition, but just for the /usr/ partition.   /usr/ Verity Signature Partition (ARC) 94f9a9a1-9971-427a-a400-50cb297f0f35 SD_GPT_USR_ARC_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (32-bit ARM) d7ff812f-37d1-4902-a810-d76ba57b975a SD_GPT_USR_ARM_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (64-bit ARM/AArch64) c23ce4ff-44bd-4b00-b2d4-b41b3419e02a SD_GPT_USR_ARM64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (Itanium/IA-64) 8de58bc2-2a43-460d-b14e-a76e4a17b47f SD_GPT_USR_IA64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (LoongArch 64-bit) b024f315-d330-444c-8461-44bbde524e99 SD_GPT_USR_LOONGARCH64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (32-bit MIPS LittleEndian (mipsel)) 3e23ca0b-a4bc-4b4e-8087-5ab6a26aa8a9 SD_GPT_USR_MIPS_LE_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (64-bit MIPS LittleEndian (mips64el)) f2c2c7ee-adcc-4351-b5c6-ee9816b66e16 SD_GPT_USR_MIPS64_LE_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (HPPA/PARISC) 450dd7d1-3224-45ec-9cf2-a43a346d71ee SD_GPT_USR_PARISC_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (64-bit PowerPC LittleEndian) c8bfbd1e-268e-4521-8bba-bf314c399557 SD_GPT_USR_PPC64_LE_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (64-bit PowerPC BigEndian) 0b888863-d7f8-4d9e-9766-239fce4d58af SD_GPT_USR_PPC64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (32-bit PowerPC) 7007891d-d371-4a80-86a4-5cb875b9302e SD_GPT_USR_PPC_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (RISC-V 32-bit) c3836a13-3137-45ba-b583-b16c50fe5eb4 SD_GPT_USR_RISCV32_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (RISC-V 64-bit) d2f9000a-7a18-453f-b5cd-4d32f77a7b32 SD_GPT_USR_RISCV64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (s390) 17440e4f-a8d0-467f-a46e-3912ae6ef2c5 SD_GPT_USR_S390_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (s390x) 3f324816-667b-46ae-86ee-9b0c0c6c11b4 SD_GPT_USR_S390X_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (TILE-Gx) 4ede75e2-6ccc-4cc8-b9c7-70334b087510 SD_GPT_USR_TILEGX_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (amd64/x86_64) e7bb33fb-06cf-4e81-8273-e543b413e2e2 SD_GPT_USR_X86_64_VERITY_SIG ditto ditto   /usr/ Verity Signature Partition (x86) 974a71c0-de41-43c3-be5d-5c5ccd1ad2c0 SD_GPT_USR_X86_VERITY_SIG ditto ditto   EFI System Partition c12a7328-f81f-11d2-ba4b-00a0c93ec93b SD_GPT_ESP VFAT The ESP used for the current boot is automatically mounted to /efi/ (or /boot/ as fallback), unless a different partition is mounted there (possibly via /etc/fstab, or because the Extended Boot Loader Partition — see below — exists) or the directory is non-empty on the root disk. This partition type is defined by the UEFI Specification.   Extended Boot Loader Partition bc13c2ff-59e6-4262-a352-b275fd6f7172 SD_GPT_XBOOTLDR Typically VFAT The Extended Boot Loader Partition (XBOOTLDR) used for the current boot is automatically mounted to /boot/, unless a different partition is mounted there (possibly via /etc/fstab) or the directory is non-empty on the root disk. This partition type is defined by the Boot Loader Specification.   Swap 0657fd6d-a4ab-43c4-84e5-0933c84b4f4f SD_GPT_SWAP Swap, optionally in LUKS All swap partitions on the disk containing the root partition are automatically enabled. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/swap. This partition type predates the Discoverable Partitions Specification.   Home Partition 933ac7e1-2eb4-4f13-b844-0e14e2aef915 SD_GPT_HOME Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /home/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/home.   Server Data Partition 3b8f8425-20e0-4f3b-907f-1a25a76f98e8 SD_GPT_SRV Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /srv/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/srv.   Variable Data Partition 4d21b016-b534-45c2-a9fb-5c16e091fd2d SD_GPT_VAR Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/ — under the condition that its partition UUID matches the first 128 bits of HMAC-SHA256(machine-id, 0x4d21b016b53445c2a9fb5c16e091fd2d) (i.e. the SHA256 HMAC hash of the binary type UUID keyed by the machine ID as read from /etc/machine-id. This special requirement is made because /var/ (unlike the other partition types listed here) is inherently private to a specific installation and cannot possibly be shared between multiple OS installations on the same disk, and thus should be bound to a specific instance of the OS, identified by its machine ID. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/var.   Temporary Data Partition 7ec6f557-3bc5-4aca-b293-16ef5df639d1 SD_GPT_TMP Any native, optionally in LUKS The first partition with this type UUID on the disk containing the root partition is automatically mounted to /var/tmp/. If the partition is encrypted with LUKS, the device mapper file will be named /dev/mapper/tmp. Note that the intended mount point is indeed /var/tmp/, not /tmp/. The latter is typically maintained in memory via tmpfs and does not require a partition on disk. In some cases it might be desirable to make /tmp/ persistent too, in which case it is recommended to make it a symlink or bind mount to /var/tmp/, thus not requiring its own partition type UUID.   Per-user Home Partition 773f91ef-66d4-49b5-bd83-d683bf40ad16 SD_GPT_USER_HOME Any native, optionally in LUKS A home partition of a user, managed by systemd-homed.   Generic Linux Data Partition 0fc63daf-8483-4772-8e79-3d69d8477de4 SD_GPT_LINUX_GENERIC Any native, optionally in LUKS No automatic mounting takes place for other Linux data partitions. This partition type should be used for all partitions that carry Linux file systems. The installer needs to mount them explicitly via entries in /etc/fstab. Optionally, these partitions may be encrypted with LUKS. This partition type predates the Discoverable Partitions Specification.    Other GPT type IDs might be used on Linux, for example to mark software RAID or LVM partitions. The definitions of those GPT types is outside of the scope of this specification.\nsystemd-id128(1)\u0026rsquo;s show command may be used to list those GPT partition type UUIDs.\nPartition Names #  For partitions of the types listed above it is recommended to use human-friendly, descriptive partition names in the GPT partition table, for example \u0026ldquo;Home\u0026rdquo;, \u0026ldquo;Server Data\u0026rdquo;, \u0026ldquo;Fedora Root\u0026rdquo; and similar, possibly localized.\nFor the Root/Verity/Verity signature partitions it might make sense to use a versioned naming scheme reflecting the OS name and its version, e.g. \u0026ldquo;fooOS_2021.4\u0026rdquo; or similar.\nPartition Attribute Flags #  This specification defines three GPT partition attribute flags that may be set for the partition types defined above:\n  For the root, /usr/, Verity, Verity signature, home, server data, variable data, temporary data, swap, and extended boot loader partitions, the partition flag bit 63 (\u0026quot;no-auto\u0026quot;, SD_GPT_FLAG_NO_AUTO) may be used to turn off auto-discovery for the specific partition. If set, the partition will not be automatically mounted or enabled.\n  For the root, /usr/, Verity, Verity signature home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 60 (\u0026quot;read-only\u0026quot;, SD_GPT_FLAG_READ_ONLY) may be used to mark a partition for read-only mounts only. If set, the partition will be mounted read-only instead of read-write. Note that the variable data partition and the temporary data partition will generally not be able to serve their purpose if marked read-only, since by their very definition they are supposed to be mutable. (The home and server data partitions are generally assumed to be mutable as well, but the requirement for them is not equally strong.) Because of that, while the read-only flag is defined and supported, it\u0026rsquo;s almost never a good idea to actually use it for these partitions. Also note that Verity and signature partitions are by their semantics always read-only. The flag is hence of little effect for them, and it is recommended to set it unconditionally for the Verity and signature partition types.\n  For the root, /usr/, home, server data, variable data, temporary data and extended boot loader partitions, the partition flag bit 59 (\u0026quot;grow-file-system\u0026quot;, SD_GPT_FLAG_GROWFS) may be used to mark a partition for automatic growing of the contained file system to the size of the partition when mounted. Tools that automatically mount disk image with a GPT partition table are suggested to implicitly grow the contained file system to the partition size they are contained in, if they are found to be smaller. This flag is without effect on partitions marked \u0026ldquo;read-only\u0026rdquo;.\n  Note that the first two flag definitions happen to correspond nicely to the same ones used by Microsoft Basic Data Partitions.\nAll three of these flags generally affect only auto-discovery and automatic mounting of disk images. If partitions marked with these flags are mounted using low-level commands like mount(8) or directly with mount(2), they typically have no effect.\nVerity #  The Root//usr/ partition types and their matching Verity and Verity signature partitions enable relatively automatic handling of dm-verity protected setups. These types are defined with two modes of operation in mind:\n  A trusted Verity root hash is passed in externally, for example is specified on the kernel command line that is signed along with the kernel image using SecureBoot PE signing (which in turn is tested against a set of firmware-provided set of signing keys). If so, discovery and setup of a Verity volume may be fully automatic: if the root partition\u0026rsquo;s UUID is chosen to match the first 128 bit of the root hash, and the matching Verity partition UUIDs is chosen to match the last 128bit of the root hash, then automatic discovery and match-up of the two partitions is possible, as the root hash is enough to both find the partitions and then combine them in a Verity volume. In this mode a Verity signature partition is not used and unnecessary.\n  A Verity signature partition is included on the disk, with a signature to be tested against a system-provided set of signing keys. The signature partition primarily contains two fields: the root hash to use, and a PKCS#7 signature of it, using a signature key trusted by the OS. If so, discovery and setup of a Verity volume may be fully automatic. First, the specified root hash is validated with the signature and the OS-provided trusted keys. If the signature checks out the root hash is then used in the same way as in the first mode of operation described above.\n  Both modes of operation may be combined in a single image. This is particularly useful for images that shall be usable in two different contexts: for example an image that shall be able to boot directly on UEFI systems (in which case it makes sense to include the root hash on the kernel command line that is included in the signed kernel image to boot, as per mode of operation #1 above), but also be able to used as image for a container engine (such as systemd-nspawn), which can use the signature partition to validate the image, without making use of the signed kernel image (and thus following mode of operation #2).\nThe Verity signature partition\u0026rsquo;s contents should be a serialized JSON object in text form, padded with NUL bytes to the next multiple of 4096 bytes in size. Currently three fields are defined for the JSON object:\n  The (mandatory) rootHash field should be a string containing the Verity root hash, formatted as series of (lowercase) hex characters.\n  The (mandatory) signature field should be a string containing the PKCS#7 signature of the root hash, in Base64-encoded DER format. This should be the same format used by the Linux kernel\u0026rsquo;s dm-verity signature logic, i.e. the signed data should be the exact string representation of the hash, as stored in rootHash above.\n  The (optional) certificateFingerprint field should be a string containing a SHA256 fingerprint of the X.509 certificate in DER format for the key that signed the root hash, formatted as series of (lowercase) hex characters (no : separators or such).\n  More fields might be added in later revisions of this specification.\nSuggested Mode of Operation #  An installer that repartitions the hard disk should use the above UUID partition types for appropriate partitions it creates.\nAn installer which supports a \u0026ldquo;manual partitioning\u0026rdquo; interface may choose to pre-populate the interface with swap, /home/, /srv/, /var/tmp/ partitions of pre-existing Linux installations, identified with the GPT type UUIDs above. The installer should not pre-populate such an interface with any identified root, /usr or /var/ partition unless the intention is to overwrite an existing operating system that might be installed.\nAn installer may omit creating entries in /etc/fstab for root, /home/, /srv/, /var/, /var/tmp and for the swap partitions if they use these UUID partition types, and are the first partitions on the disk of each type. If the ESP shall be mounted to /efi/ (or /boot/), it may additionally omit creating the entry for it in /etc/fstab. If the EFI partition shall not be mounted to /efi/ or /boot/, it must create /etc/fstab entries for them. If other partitions are used (for example for /usr/local/ or /var/lib/mysql/), the installer must register these in /etc/fstab. The root= parameter passed to the kernel by the boot loader may be omitted if the root partition is the first one on the disk of its type. If the root partition is not the first one on the disk, the root= parameter must be passed to the kernel by the boot loader. An installer that mounts a root, /usr/, /home/, /srv/, /var/, or /var/tmp/ file system with the partition types defined as above which contains a LUKS header must call the device mapper device \u0026ldquo;root\u0026rdquo;, \u0026ldquo;usr\u0026rdquo;, \u0026ldquo;home\u0026rdquo;, \u0026ldquo;srv\u0026rdquo;, \u0026ldquo;var\u0026rdquo; or \u0026ldquo;tmp\u0026rdquo;, respectively. This is necessary to ensure that the automatic discovery will never result in different device mapper names than any static configuration by the installer, thus eliminating possible naming conflicts and ambiguities.\nAn operating system should automatically discover and mount the first root partition that does not have the no-auto flag set (as described above) by scanning the disk containing the currently used EFI ESP. It should automatically discover and mount the first /usr/, /home/, /srv/, /var/, /var/tmp/ and swap partitions that do not have the no-auto flag set by scanning the disk containing the discovered root partition. It should automatically discover and mount the partition containing the currently used EFI ESP to /efi/ (or /boot/ as fallback). It should automatically discover and mount the partition containing the currently used Extended Boot Loader Partition to /boot/. It should not discover or automatically mount partitions with other UUID partition types, or partitions located on other disks, or partitions with the no-auto flag set. User configuration shall always override automatic discovery and mounting. If a root, /usr/, /home/, /srv/, /boot/, /var/, /var/tmp/, /efi/, /boot/ or swap partition is listed in /etc/fstab or with root= on the kernel command line, it must take precedence over automatically discovered partitions. If a /home/, /usr/, /srv/, /boot/, /var/, /var/tmp/, /efi/ or /boot/ directory is found to be populated already in the root partition, the automatic discovery must not mount any discovered file system over it. Optionally, in case of the root, /usr/ and their Verity partitions instead of strictly mounting the first suitable partition an OS might choose to mount the partition whose label compares the highest according to strverscmp() or similar logic, in order to implement a simple partition-based A/B versioning scheme. The precise rules are left for the implementation to decide, but when in doubt earlier partitions (by their index) should always win over later partitions if the label comparison is inconclusive.\nA container manager should automatically discover and mount the root, /usr/, /home/, /srv/, /var/, /var/tmp/ partitions inside a container disk image. It may choose to mount any discovered ESP and/or XBOOTLDR partition to /efi/ or /boot/. It should ignore any swap should they be included in a container disk image.\nIf a btrfs file system is automatically discovered and mounted by the operating system/container manager it will be mounted with its default subvolume. The installer should make sure to set the default subvolume correctly using \u0026ldquo;btrfs subvolume set-default\u0026rdquo;.\nSharing of File Systems between Installations #  If two Linux-based operating systems are installed on the same disk, the scheme above suggests that they may share the swap, /home/, /srv/, /var/tmp/, ESP, XBOOTLDR. However, they should each have their own root, /usr/ and /var/ partition.\nFrequently Asked Questions #  Why are you taking my /etc/fstab away? #  We are not. /etc/fstab always overrides automatic discovery and is indeed mentioned in the specifications. We are simply trying to make the boot and installation processes of Linux a bit more robust and self-descriptive.\nWhy did you only define the root partition for these listed architectures? #  Please submit a patch that adds appropriate partition type UUIDs for the architecture of your choice should they be missing so far. The only reason they aren\u0026rsquo;t defined yet is that nobody submitted them yet.\nWhy define distinct root partition UUIDs for the various architectures? #  This allows disk images that may be booted on multiple architectures to use discovery of the appropriate root partition on each architecture.\nDoesn\u0026rsquo;t this break multi-boot scenarios? #  No, it doesn\u0026rsquo;t. The specification says that installers may not stop creating /etc/fstab or stop including root= on the kernel command line, unless the used partitions are the first ones of their type on the disk. Additionally, /etc/fstab and root= both override automatic discovery. Multi-boot is hence well supported, since it doesn\u0026rsquo;t change anything for anything but the first installation.\nThat all said, it\u0026rsquo;s not expected that generic installers generally stop setting root= and creating /etc/fstab anyway. The option to drop these configuration bits is primarily something for appliance-like devices. However, generic installers should still set the right GPT partition types for the partitions they create so that container managers, partition tools and administrators can benefit. Phrased differently, this specification introduces A) the recommendation to use the newly defined partition types to tag things properly and B) the option to then drop root= and /etc/fstab. While we advertise A) to all installers, we only propose B) for simpler, appliance-like installations.\nWhat partitioning tools will create a DPS-compliant partition table? #  As of util-linux 2.25.2, the fdisk tool provides type codes to create the root, home, and swap partitions that the DPS expects. By default, fdisk will create an old-style MBR, not a GPT, so typing l to list partition types will not show the choices to let you set the correct UUID. Make sure to first create an empty GPT, then type l in order for the DPS-compliant type codes to be available.\nThe gdisk tool (from version 1.0.5 onward) and its variants (sgdisk, cgdisk) also support creation of partitions with a matching type code.\nLinks #  Boot Loader Specification\nBoot Loader Interface\nSafely Building Images\nsystemd-boot(7)\nbootctl(1)\nsystemd-gpt-auto-generator(8)\n"});index.add({'id':3,'href':'/specifications/docs/linux-tpm-pcr-registry/','title':"Linux TPM PCR Registry",'section':"Docs",'content':"🔏 Linux TPM PCR Registry 🗒️ #  TPM PCRs are a scarce resource, there are only 24 of them in typical standards compliant TPMs. According to the TCG PC Client Specific Platform Firmware Profile Specification | Trusted Computing Group PCRs 8…15 are for the OS to make use of. In this document we intend to document for Linux platforms which component is using which PCR in order to minimize conflicts.\nOut of scope for this is how other OSes, in particular Windows’ use the PCRs. Also out of scope are PCRs owned by the firmware, i.e. 0\u0026hellip;7.\nThis document is informational in nature: it just describes what is, it is not intended to formally declare “ownership” of a specific PCR, but simply is supposed to reflect which PCR assignments are common in the Linux ecosystems. That said, co-opting PCR usage will likely create problems down the line, in particular if measurement logs are maintained separately. (To be more explicit: on systemd systems the warranty is voided if you write to the PCRs it also uses, as per the list below.)\nPCR measurements most commonly serve two distinct purposes:\n To implement access policy on TPM sealed objects: policy can dictate that unsealing of such objects shall only be allowed if some PCRs are in a specific literal state, or in any state for which a signature by a specific key pair can be provided. For this it is essential that PCRs only contain measurements for a clearly defined set of objects, that typically is known in advance so that the PCR value can be pre-calculated (hence this is in a way a forward-looking use) To permit reasoning about the boot process and runtime so far, for example for the purpose of remote attestation. In this case it is not that important what objects are measured as long as a record is kept in a measurement log about what it was. The PCRs are in this case used to validate that log (hence this is in a way a backward-looking use)  In both cases it is important that data measured into the PCRs is carefully chosen. PCRs that shall be useful for policy binding should only cover data objects known in advance, and thus not contain runtime data that cannot be pre-calculated in advance. PCRs that shall be useful for backward-looking validation should only cover objects that are also written to the appropriate log for the PCR.\n  PCR#\n Used by From Location Measured Objects Log Use Reported By   8\n grub 🍲 UEFI Boot Component Commands and kernel command line UEFI TPM event log n/a   9\n grub 🍲 UEFI Boot Component All files read (including kernel image) UEFI TPM event log n/a   (cont.)\n Linux kernel 🌰 Kernel All passed initrds (when the new LOAD_FILE2 initrd protocol is used) UEFI TPM event log n/a   10\n IMA 📐 Kernel Protection of the IMA measurement log IMA event log n/a   11\n systemd-stub 🚀 UEFI Stub All components of unified kernel images (UKIs) UEFI TPM event log in EFI variable StubPcrKernelImage   (cont.)\n systemd-pcrphase 🚀 Userspace Boot phase strings, indicating various milestones of the boot process Journal (for now) n/a   12\n systemd-stub 🚀 UEFI Stub Kernel command line, system credentials and system configuration images UEFI TPM event log in EFI variable StubPcrKernelParameters   13\n systemd-stub 🚀 UEFI Stub All system extension images for the initrdUEFI TPM event log in EFI variable StubPcrInitRDSysExts   14\n shim 🔑 UEFI Boot Component “MOK” certificates and hashes UEFI TPM event log n/a   15\n systemd-cryptsetup@.service 🚀 Userspace Root file system volume encryption key Journal (for now) n/a    (cont.)\n systemd-pcrmachine.service 🚀 Userspace Machine ID (/etc/machine-id) Journal (for now) n/a   (cont.)\n systemd-pcrfs@.service 🚀 Userspace File system mount point, UUID, label, partition UUID label of root file system and /var/ Journal (for now) n/a   Note that PCR 11 and 15 as shown in the list above are used by multiple components of systemd. These are not conflicting uses, but the involved components are properly ordered to guarantee cooperative, strictly predictable behaviour.\nSources #   systemd-cryptenroll(1) TCG PC Client Specific Platform Firmware Profile Specification shim\u0026rsquo;s README.tpm Measured Boot - GNU GRUB Manual 2.06 Integrity Measurement Architecture (IMA) edk2-TrustedBootChain/4_Other_Trusted_Boot_Chains.md Trusted Platform Module - ArchWiki  "});})();